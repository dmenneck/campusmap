"use strict";

var _Feature = _interopRequireDefault(require("ol/Feature"));

var _Point = _interopRequireDefault(require("ol/geom/Point"));

var _index = require("../index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*eslint-env jest*/
describe('FeatureUtil', function () {
  var coords;
  var geom;
  var props;
  var feat;
  var featId;
  beforeEach(function () {
    featId = 'BVB.BORUSSIA';
    coords = [1909, 1909];
    geom = new _Point["default"]({
      coordinates: coords
    });
    props = {
      name: 'Shinji Kagawa',
      address: 'Borsigplatz 9',
      city: 'Dortmund',
      homepage: 'https://www.bvb.de/',
      'exists-and-is-undefined': undefined,
      'exists-and-is-null': null
    };
    feat = new _Feature["default"]({
      geometry: geom
    });
    feat.setProperties(props);
    feat.setId(featId);
  });
  describe('Basics', function () {
    it('is defined', function () {
      expect(_index.FeatureUtil).toBeDefined();
    });
  });
  describe('Static methods', function () {
    describe('#getFeatureTypeName', function () {
      it('splits the feature ID at the point character and returns the first part', function () {
        var got = _index.FeatureUtil.getFeatureTypeName(feat);

        expect(got).toBe(featId.split('.')[0]);
        feat.setId('BVB');
        got = _index.FeatureUtil.getFeatureTypeName(feat);
        expect(got).toBe('BVB');
      });
      it('returns undefined if the ID is not set', function () {
        feat.setId(null);

        var got = _index.FeatureUtil.getFeatureTypeName(feat);

        expect(got).toBe(undefined);
      });
    });
    describe('#getFeatureTypeNameFromGetFeatureInfoUrl', function () {
      it('extracts layer name from provided GetFeatureInfo request URL', function () {
        var layerName = 'testLayerName';
        var ns = 'ns';
        var mockUrlUnqualified = "http://mock.de?&REQUEST=GetFeatureInfo&QUERY_LAYERS=".concat(layerName, "&TILED=true");
        var mockUrlQualified = "http://mock.de?&REQUEST=GetFeatureInfo&QUERY_LAYERS=".concat(ns, ":").concat(layerName, "&TILED=true");
        var mockUrlQualified2 = "http://mock.de?&REQUEST=GetFeatureInfo&QUERY_LAYERS=".concat(ns, ":").concat(layerName);

        var gotUnqualified = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(mockUrlUnqualified);

        var gotQualified = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(mockUrlQualified);

        var gotQualified2 = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(mockUrlQualified2);

        var gotQualifiedSplitted = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(mockUrlQualified, false);

        var gotQualifiedSplitted2 = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(mockUrlQualified2, false);

        expect(gotUnqualified).toBe(layerName);
        expect(gotQualified).toBe("".concat(ns, ":").concat(layerName));
        expect(gotQualified2).toBe("".concat(ns, ":").concat(layerName));
        expect(gotQualifiedSplitted).toBe(layerName);
        expect(gotQualifiedSplitted2).toBe(layerName);
      });
      it('returns undefined if no match was found', function () {
        var notMatchingUrl = "http://mock.de?&REQUEST=GetFeatureInfo&SOME_PARAMS=some_values";

        var got = _index.FeatureUtil.getFeatureTypeNameFromGetFeatureInfoUrl(notMatchingUrl);

        expect(got).toBeUndefined();
      });
    });
    describe('#resolveAttributeTemplate', function () {
      it('resolves the given template string with the feature attributes', function () {
        var template = '{{name}}';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe(props.name); // It's case insensitive.

        template = '{{NAmE}}';
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);
        expect(got).toBe(props.name); // It resolves static and non-static content.

        template = 'Contact information: {{name}} {{address}} {{city}}';
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);
        expect(got).toBe("Contact information: ".concat(props.name, " ").concat(props.address, " ").concat(props.city)); // It doesn't harm the template if not attribute placeholder is given.

        template = 'No attribute template';
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);
        expect(got).toBe(template);
      });
      it('can be configured wrt handling inexistant / falsy values', function () {
        var template = '{{exists-and-is-undefined}}|{{exists-and-is-null}}|{{key-does-not-exist}}';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe('undefined|null|n.v.');
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template, '', function (key, val) {
          return val ? val : '';
        });
        expect(got).toBe('||');
        var mockFn = jest.fn(function () {
          return 'FOO';
        });
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template, '', mockFn);
        expect(mockFn.mock.calls.length).toBe(2);
        expect(mockFn.mock.calls[0][0]).toBe('exists-and-is-undefined');
        expect(mockFn.mock.calls[0][1]).toBe(undefined);
        expect(mockFn.mock.calls[1][0]).toBe('exists-and-is-null');
        expect(mockFn.mock.calls[1][1]).toBe(null);
        expect(got).toBe('FOO|FOO|');
      });
      it('wraps an URL occurence with an <a> tag', function () {
        var template = '{{homepage}}';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe("<a href=\"".concat(props.homepage, "\" target=\"_blank\">").concat(props.homepage, "</a>"));
      });
      it('resolves it with a placeholder if attribute could not be found', function () {
        var template = '{{notAvailable}}';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe('n.v.');
        template = '{{name}} {{notAvailable}}';
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);
        expect(got).toBe("".concat(props.name, " n.v.")); // The placeholder is configurable.

        var notFoundPlaceHolder = '【ツ】';
        template = '{{name}} {{notAvailable}}';
        got = _index.FeatureUtil.resolveAttributeTemplate(feat, template, notFoundPlaceHolder);
        expect(got).toBe("".concat(props.name, " ").concat(notFoundPlaceHolder));
      });
      it('returns the id of the feature if no template is given', function () {
        var template = '';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe(featId);
        got = _index.FeatureUtil.resolveAttributeTemplate(feat);
        expect(got).toBe(featId);
      });
      it('replaces newline chars with a <br> tag', function () {
        var template = '{{name}} \n {{city}}';

        var got = _index.FeatureUtil.resolveAttributeTemplate(feat, template);

        expect(got).toBe("".concat(props.name, " <br> ").concat(props.city));
      });
    });
  });
});