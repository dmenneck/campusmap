"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _render = require("ol/render");

var _Observable = require("ol/Observable");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * This class provides some static methods which might be helpful when working
 * with digitize functions to animate features.
 *
 * @class AnimateUtil
 */
var AnimateUtil =
/*#__PURE__*/
function () {
  function AnimateUtil() {
    _classCallCheck(this, AnimateUtil);
  }

  _createClass(AnimateUtil, null, [{
    key: "moveFeature",

    /**
     * Moves / translates an `OlFeature` to the given `pixel` delta in
     * in the end with given `duration` in ms, using the given style.
     *
     * @param {ol.Map} map An OlMap.
     * @param {ol.layer.Vector} layer A vector layer which feature should be moved.
     * @param {ol.Feature} featureToMove The feature to move.
     * @param {number} duration The duration in ms for the moving to complete.
     * @param {Array<number>} pixel Delta of pixels to move the feature.
     * @param {ol.style.Style} style The style to use when moving the feature.
     *
     * @return {string} A listener key from a postrender event.
     */
    value: function moveFeature(map, layer, featureToMove, duration, pixel, style) {
      return new Promise(function (resolve) {
        var listenerKey;
        var geometry = featureToMove.getGeometry();
        var start = new Date().getTime();
        var resolution = map.getView().getResolution();
        var totalDisplacement = pixel * resolution;
        var expectedFrames = duration / 1000 * 60;
        var actualFrames = 0;
        var deltaX = totalDisplacement / expectedFrames;
        var deltaY = totalDisplacement / expectedFrames;
        /**
         * Moves the feature `pixel` right and `pixel` up.
         * @ignore
         */

        var animate = function animate(event) {
          var vectorContext = (0, _render.getVectorContext)(event);
          var frameState = event.frameState;
          var elapsed = frameState.time - start;
          geometry.translate(deltaX, deltaY);

          if (style) {
            vectorContext.setStyle(style);
          }

          vectorContext.drawGeometry(geometry);

          if (elapsed > duration || actualFrames >= expectedFrames) {
            (0, _Observable.unByKey)(listenerKey);
            resolve(featureToMove);
          } // tell OpenLayers to continue postrender animation


          frameState.animate = true;
          actualFrames++;
          map.render();
        };

        listenerKey = layer.on('postrender', animate);
      });
    }
  }]);

  return AnimateUtil;
}();

var _default = AnimateUtil;
exports["default"] = _default;