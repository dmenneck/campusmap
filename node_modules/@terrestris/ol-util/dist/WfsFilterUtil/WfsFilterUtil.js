"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _filter = require("ol/format/filter");

var _WFS = _interopRequireDefault(require("ol/format/WFS"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Helper class for building filters to be used with WFS GetFeature requests.
 *
 * @class WfsFilterUtil
 */
var WfsFilterUtil =
/*#__PURE__*/
function () {
  function WfsFilterUtil() {
    _classCallCheck(this, WfsFilterUtil);
  }

  _createClass(WfsFilterUtil, null, [{
    key: "createWfsFilter",

    /**
     * Creates a filter for a given feature type considering configured
     * search attributes, mapped features types to an array of attribute details and the
     * current search term.
     * Currently supports EQUALTO and LIKE filters only, which can be combined with
     * OR filter if searchAttributes array contains multiple values though.
     *
     * @param {string} featureType Name of feature type to be used in filter.
     * @param {string} searchTerm Search value.
     * @param {Object} searchAttributes An object mapping feature types to an array of
     *   attributes that should be searched through.
     * @param {Object} attributeDetails An object mapping feature types to an
     *   array of attribute details.
     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.
     * @private
     */
    value: function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {
      var attributes = searchAttributes && searchAttributes[featureType];

      if (!attributes) {
        return null;
      }

      var details = attributeDetails && attributeDetails[featureType];
      var propertyFilters = attributes.map(function (attribute) {
        var filterDetails = details && details[attribute];

        if (filterDetails) {
          var type = filterDetails.type;

          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\d]/)) {
            return undefined;
          }

          if (filterDetails.exactSearch) {
            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);
          } else {
            return (0, _filter.like)(attribute, "*".concat(searchTerm, "*"), '*', '.', '!', filterDetails.matchCase || false);
          }
        } else {
          return (0, _filter.like)(attribute, "*".concat(searchTerm, "*"), '*', '.', '!', false);
        }
      }).filter(function (filter) {
        return filter !== undefined;
      });

      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {
        return _filter.or.apply(void 0, _toConsumableArray(propertyFilters));
      } else {
        return propertyFilters[0];
      }
    }
    /**
     * Creates GetFeature request body for all provided featureTypes and
     * applies related filter encoding on it.
     *
     * @param {Object} searchOpts Search options object which has the following
     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/
     * for further options explanations and examples):
     *   * featureNS        {String}   The namespace URI used for features
     *   * featurePrefix    {String}   The prefix for the feature namespace.
     *   * featureTypes     {String[]} The feature type names to search through.
     *   * geometryName     {String}   Geometry name to use in a BBOX filter.
     *   * maxFeatures      {Number}   Maximum number of features to fetch.
     *   * outputFormat     {String}   The output format of the response.
     *   * propertyNames    {String[]} Optional list of property names to serialize.
     *   * srsName          {String}   SRS name.
     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS
     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)
     *   * searchAttributes {Object}   An object mapping feature types to an array
     *                                 of attributes that should be searched through.
     *   * attributeDetails {Object}   A nested object mapping feature types to an
     *                                 object of attribute details, which are also
     *                                 mapped by search attribute name.
     * @param {string} searchTerm Search string to be used with filter.
     */

  }, {
    key: "getCombinedRequests",
    value: function getCombinedRequests(searchOpts, searchTerm) {
      var featureNS = searchOpts.featureNS,
          featurePrefix = searchOpts.featurePrefix,
          featureTypes = searchOpts.featureTypes,
          geometryName = searchOpts.geometryName,
          maxFeatures = searchOpts.maxFeatures,
          outputFormat = searchOpts.outputFormat,
          propertyNames = searchOpts.propertyNames,
          srsName = searchOpts.srsName,
          wfsFormatOptions = searchOpts.wfsFormatOptions,
          searchAttributes = searchOpts.searchAttributes,
          attributeDetails = searchOpts.attributeDetails;
      var requests = featureTypes.map(function (featureType) {
        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);
        var options = {
          featureNS: featureNS,
          featurePrefix: featurePrefix,
          featureTypes: [featureType],
          geometryName: geometryName,
          maxFeatures: maxFeatures,
          outputFormat: outputFormat,
          propertyNames: propertyNames,
          srsName: srsName,
          filter: filter
        };
        var wfsFormat = new _WFS["default"](wfsFormatOptions);
        return wfsFormat.writeGetFeature(options);
      });
      var request = requests[0];
      requests.forEach(function (req) {
        if (req !== request) {
          var query = req.querySelector('Query');
          request.append(query);
        }
      });
      return request;
    }
  }]);

  return WfsFilterUtil;
}();

var _default = WfsFilterUtil;
exports["default"] = _default;