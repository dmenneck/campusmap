"use strict";

var _index = require("../index");

/*eslint-env jest*/
describe('WfsFilterUtil', function () {
  var featureType = 'featureType';
  var stringSearchTerm = 'searchMe';
  var digitSearchTerm = '123';
  var searchAttributes = {
    featureType: []
  };
  var attributeDetails = {
    featureType: {}
  };
  var stringAttr1 = {
    matchCase: false,
    type: 'string',
    exactSearch: false
  };
  var stringAttr2 = {
    matchCase: true,
    type: 'string',
    exactSearch: false
  };
  var numberAttr = {
    matchCase: true,
    type: 'int',
    exactSearch: true
  };
  describe('Basics', function () {
    it('is defined', function () {
      expect(_index.WfsFilterUtil).not.toBeUndefined();
    });
  });
  describe('Static methods', function () {
    describe('#createWfsFilter', function () {
      afterEach(function () {
        searchAttributes = {
          'featureType': []
        };
        Object.keys(attributeDetails[featureType]).forEach(function (prop) {
          delete attributeDetails[featureType][prop];
        });
      });
      it('is defined', function () {
        expect(_index.WfsFilterUtil.createWfsFilter).toBeDefined();
      });
      it('returns null if no search attributes for the provided feature type are found', function () {
        searchAttributes = {
          'someAnotherFeatureType': []
        };
        attributeDetails['featureType']['stringAttr1'] = stringAttr1;

        var got = _index.WfsFilterUtil.createWfsFilter(featureType, stringSearchTerm, searchAttributes, attributeDetails);

        expect(got).toBeNull();
      });
      it('returns simple LIKE filter if only one attribute is provided and exactSearch flag is false or not given', function () {
        searchAttributes[featureType].push('stringAttr2');
        attributeDetails['featureType']['stringAttr2'] = stringAttr2;

        var got = _index.WfsFilterUtil.createWfsFilter(featureType, stringSearchTerm, searchAttributes, attributeDetails);

        expect(got.getTagName()).toBe('PropertyIsLike');
        expect(got.pattern).toEqual("*".concat(stringSearchTerm, "*"));
        expect(got.propertyName).toEqual(searchAttributes[featureType][0]);
        expect(got.matchCase).toEqual(stringAttr2.matchCase);
      });
      it('returns simple LIKE filter if only one attribute is provided and attributeDetails argument is omitted', function () {
        searchAttributes[featureType].push('stringAttr1');

        var got = _index.WfsFilterUtil.createWfsFilter(featureType, stringSearchTerm, searchAttributes);

        expect(got.getTagName()).toBe('PropertyIsLike');
        expect(got.pattern).toEqual("*".concat(stringSearchTerm, "*"));
        expect(got.propertyName).toEqual(searchAttributes[featureType][0]);
        expect(got.matchCase).toBeFalsy();
      });
      it('returns simple EQUALTO filter if only one attribute is provided and exactSearch flag is true', function () {
        searchAttributes[featureType].push('numberAttr');
        attributeDetails['featureType']['numberAttr'] = numberAttr;

        var got = _index.WfsFilterUtil.createWfsFilter(featureType, digitSearchTerm, searchAttributes, attributeDetails);

        expect(got.getTagName()).toBe('PropertyIsEqualTo');
        expect(got.expression).toEqual(digitSearchTerm);
        expect(got.propertyName).toEqual(searchAttributes[featureType][0]);
      });
      it('returns combined OR filter if more than one search attributes are provided', function () {
        var _searchAttributes$fea;

        (_searchAttributes$fea = searchAttributes[featureType]).push.apply(_searchAttributes$fea, ['stringAttr1', 'stringAttr2']);

        attributeDetails = {
          'featureType': {
            'stringAttr1': stringAttr1,
            'stringAttr2': stringAttr2
          }
        };

        var got = _index.WfsFilterUtil.createWfsFilter(featureType, stringSearchTerm, searchAttributes, attributeDetails);

        expect(got.getTagName()).toBe('Or');
        expect(got.conditions.length).toEqual(searchAttributes[featureType].length);
      });
    });
    describe('#getCombinedRequests', function () {
      var searchOpts = {
        featureTypes: ['someNs:someFeatureType', 'someAnotherNs:someAnotherFeatureType'],
        'searchAttributes': {
          'someNs:someFeatureType': ['name'],
          'someAnotherNs:someAnotherFeatureType': ['anotherName']
        }
      };
      var searchTerm = 'findMe';
      it('is defined', function () {
        expect(_index.WfsFilterUtil.getCombinedRequests).toBeDefined();
      });
      it('creates WFS filter for each feature type', function () {
        var filterSpy = jest.spyOn(_index.WfsFilterUtil, 'createWfsFilter');

        _index.WfsFilterUtil.getCombinedRequests(searchOpts, searchTerm);

        expect(filterSpy).toHaveBeenCalledTimes(searchOpts.featureTypes.length);
        filterSpy.mockRestore();
      });
      it('creates WFS GetFeature request body containing queries and filter for each feature type', function () {
        var got = _index.WfsFilterUtil.getCombinedRequests(searchOpts, searchTerm);

        expect(got.tagName).toBe('GetFeature');
        expect(got.querySelectorAll('Query').length).toBe(searchOpts.featureTypes.length);
        got.querySelectorAll('Query').forEach(function (query) {
          expect(query.children[0].tagName).toBe('Filter');
          expect(query.children[0].getElementsByTagName('Literal')[0].innerHTML).toBe("*".concat(searchTerm, "*"));
        });
      });
    });
  });
});