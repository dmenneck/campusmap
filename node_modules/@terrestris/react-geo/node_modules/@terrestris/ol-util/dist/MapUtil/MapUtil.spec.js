"use strict";

var _DragRotateAndZoom = _interopRequireDefault(require("ol/interaction/DragRotateAndZoom"));

var _Draw = _interopRequireDefault(require("ol/interaction/Draw"));

var _Tile = _interopRequireDefault(require("ol/layer/Tile"));

var _Image = _interopRequireDefault(require("ol/layer/Image"));

var _TileWMS = _interopRequireDefault(require("ol/source/TileWMS"));

var _ImageWMS = _interopRequireDefault(require("ol/source/ImageWMS"));

var _TileJSON = _interopRequireDefault(require("ol/source/TileJSON"));

var _Feature = _interopRequireDefault(require("ol/Feature"));

var _Point = _interopRequireDefault(require("ol/geom/Point"));

var _Group = _interopRequireDefault(require("ol/layer/Group"));

var _Map = _interopRequireDefault(require("ol/Map"));

var _View = _interopRequireDefault(require("ol/View"));

var _Logger = _interopRequireDefault(require("@terrestris/base-util/dist/Logger"));

var _TestUtil = _interopRequireDefault(require("../TestUtil"));

var _index = require("../index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*eslint-env jest*/
describe('MapUtil', function () {
  var testResolutions = {
    degrees: 0.000004807292355257246,
    m: 0.5345462690925383,
    ft: 1.7537607253692198,
    'us-ft': 1.7537572178477696
  };
  var testScale = 1909.09;
  var map;
  beforeEach(function () {
    map = _TestUtil["default"].createMap();
  });
  afterEach(function () {
    _TestUtil["default"].removeMap(map);
  });
  it('is defined', function () {
    expect(_index.MapUtil).toBeDefined();
  });
  describe('#getInteractionsByName', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getInteractionsByName).toBeDefined();
    });
    it('needs to be called with a map instance', function () {
      var logSpy = jest.spyOn(_Logger["default"], 'debug');

      var returnedInteractions = _index.MapUtil.getInteractionsByName(null, 'BVB!');

      expect(logSpy).toHaveBeenCalled();
      expect(returnedInteractions).toHaveLength(0);
      logSpy.mockRestore();
    });
    it('returns an empty array if no interaction candidate is found', function () {
      var dragInteractionName = 'Drag Queen';
      var dragInteraction = new _DragRotateAndZoom["default"]();
      dragInteraction.set('name', dragInteractionName);
      map.addInteraction(dragInteraction);

      var returnedInteractions = _index.MapUtil.getInteractionsByName(map, "".concat(dragInteractionName, " NOT AVAILABLE"));

      expect(returnedInteractions).toHaveLength(0);
    });
    it('returns the requested interactions by name', function () {
      var dragInteractionName = 'Drag Queen';
      var dragInteraction = new _DragRotateAndZoom["default"]();
      dragInteraction.set('name', dragInteractionName);
      map.addInteraction(dragInteraction);

      var returnedInteractions = _index.MapUtil.getInteractionsByName(map, dragInteractionName);

      expect(returnedInteractions).toHaveLength(1);
      var anotherDragInteraction = new _DragRotateAndZoom["default"]();
      anotherDragInteraction.set('name', dragInteractionName);
      map.addInteraction(anotherDragInteraction);
      returnedInteractions = _index.MapUtil.getInteractionsByName(map, dragInteractionName);
      expect(returnedInteractions).toHaveLength(2);
    });
  });
  describe('#getInteractionsByClass', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getInteractionsByClass).toBeDefined();
    });
    it('needs to be called with a map instance', function () {
      var logSpy = jest.spyOn(_Logger["default"], 'debug');

      var returnedInteractions = _index.MapUtil.getInteractionsByClass(null, _DragRotateAndZoom["default"]);

      expect(logSpy).toHaveBeenCalled();
      expect(returnedInteractions).toHaveLength(0);
      logSpy.mockRestore();
    });
    it('returns an empty array if no interaction candidate is found', function () {
      var dragInteraction = new _DragRotateAndZoom["default"]();
      map.addInteraction(dragInteraction);

      var returnedInteractions = _index.MapUtil.getInteractionsByClass(map, _Draw["default"]);

      expect(returnedInteractions).toHaveLength(0);
    });
    it('returns the requested interactions by class', function () {
      var dragInteraction = new _DragRotateAndZoom["default"]();
      map.addInteraction(dragInteraction);

      var returnedInteractions = _index.MapUtil.getInteractionsByClass(map, _DragRotateAndZoom["default"]);

      expect(returnedInteractions).toHaveLength(1);
      var anotherDragInteraction = new _DragRotateAndZoom["default"]();
      map.addInteraction(anotherDragInteraction);
      returnedInteractions = _index.MapUtil.getInteractionsByClass(map, _DragRotateAndZoom["default"]);
      expect(returnedInteractions).toHaveLength(2);
    });
  });
  describe('#getResolutionForScale', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getResolutionForScale).toBeDefined();
    });
    it('returns expected values for valid units', function () {
      var units = ['degrees', 'm', 'ft', 'us-ft'];
      units.forEach(function (unit) {
        expect(_index.MapUtil.getResolutionForScale(testScale, unit)).toBe(testResolutions[unit]);
      });
    });
    it('returns inverse of getScaleForResolution', function () {
      var unit = 'm';
      var resolutionToTest = 190919.09;

      var calculateScale = _index.MapUtil.getScaleForResolution(resolutionToTest, unit);

      expect(_index.MapUtil.getResolutionForScale(calculateScale, unit)).toBe(resolutionToTest);
    });
  });
  describe('#getScaleForResolution', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getScaleForResolution).toBeDefined();
    });
    it('returns expected values for valid units', function () {
      var units = ['degrees', 'm', 'ft', 'us-ft'];
      /**
       * Helper method to round number to two floating digits
       */

      var roundToTwoDecimals = function roundToTwoDecimals(num) {
        return Math.round(num * 100) / 100;
      };

      units.forEach(function (unit) {
        expect(roundToTwoDecimals(_index.MapUtil.getScaleForResolution(testResolutions[unit], unit))).toBe(testScale);
      });
    });
    it('returns inverse of getResolutionForScale', function () {
      var unit = 'm';

      var calculateScale = _index.MapUtil.getResolutionForScale(testScale, unit);

      expect(_index.MapUtil.getScaleForResolution(calculateScale, unit)).toBe(testScale);
    });
  });
  describe('#getLayerByName', function () {
    it('returns the layer by the given name', function () {
      var layerName = 'Peter';
      var layer = new _Tile["default"]({
        name: layerName
      });
      map.addLayer(layer);

      var got = _index.MapUtil.getLayerByName(map, layerName);

      expect(got).toBe(layer);
    });
    it('returns undefined if the layer could not be found', function () {
      var layerName = 'OSM-WMS';

      var got = _index.MapUtil.getLayerByName(map, layerName);

      expect(got).toBeUndefined();
    });
  });
  describe('#getLayerByNameParam', function () {
    it('returns the layer by the given name', function () {
      var layerName = 'OSM-WMS';
      var layer = new _Tile["default"]({
        visible: false,
        source: new _TileWMS["default"]({
          url: 'https://ows.terrestris.de/osm/service?',
          params: {
            'LAYERS': layerName,
            'TILED': true
          }
        })
      });
      layer.set('key', 'prop');
      map.addLayer(layer);

      var got = _index.MapUtil.getLayerByNameParam(map, layerName);

      expect(got).toBeInstanceOf(_Tile["default"]);
      expect(got.get('key')).toBe('prop');
    });
    it('returns undefined if the layer could not be found', function () {
      var layerName = 'OSM-WMS';

      var got = _index.MapUtil.getLayerByNameParam(map, layerName);

      expect(got).toBeUndefined();
    });
  });
  describe('#getLayerByFeature', function () {
    it('returns the layer by the given feature', function () {
      var namespace = 'BVB_NAMESPACE';
      var layerName = 'BVB';
      var qualifiedLayerName = "".concat(namespace, ":").concat(layerName);
      var featId = "".concat(layerName, ".1909");
      var feat = new _Feature["default"]({
        geometry: new _Point["default"]({
          coordinates: [1909, 1909]
        })
      });
      feat.setId(featId);
      var layer = new _Tile["default"]({
        visible: false,
        source: new _TileWMS["default"]({
          url: 'https://ows.terrestris.de/osm/service?',
          params: {
            'LAYERS': qualifiedLayerName,
            'TILED': true
          }
        })
      });
      layer.set('key', 'prop');
      map.addLayer(layer);

      var got = _index.MapUtil.getLayerByFeature(map, feat, [namespace]);

      expect(got).toBeInstanceOf(_Tile["default"]);
      expect(got.get('key')).toBe('prop');
    });
    it('returns undefined if the layer could not be found', function () {
      var namespace = 'BVB_NAMESPACE';
      var layerName = 'BVB';
      var qualifiedLayerName = "".concat(namespace, ":").concat(layerName);
      var featId = "".concat(layerName, "_INVALID.1909");
      var feat = new _Feature["default"]({
        geometry: new _Point["default"]({
          coordinates: [1909, 1909]
        })
      });
      feat.setId(featId);
      var layer = new _Tile["default"]({
        visible: false,
        source: new _TileWMS["default"]({
          url: 'https://ows.terrestris.de/osm/service?',
          params: {
            'LAYERS': qualifiedLayerName,
            'TILED': true
          }
        })
      });
      map.addLayer(layer);

      var got = _index.MapUtil.getLayerByFeature(map, feat, [namespace]);

      expect(got).toBeUndefined();
    });
  });
  describe('#getLayersByGroup', function () {
    it('returns a flattened array of layers out of a given layergroup', function () {
      var layerGroup = new _Group["default"]({
        layers: [_TestUtil["default"].createVectorLayer({
          name: 'Layer 1'
        }), _TestUtil["default"].createVectorLayer({
          name: 'Layer 2'
        }), new _Group["default"]({
          layers: [_TestUtil["default"].createVectorLayer({
            name: 'Sublayer 1'
          }), _TestUtil["default"].createVectorLayer({
            name: 'Sublayer 2'
          }), new _Group["default"]({
            layers: [_TestUtil["default"].createVectorLayer({
              name: 'Subsublayer 1'
            }), _TestUtil["default"].createVectorLayer({
              name: 'Subsublayer 2'
            })]
          }), _TestUtil["default"].createVectorLayer({
            name: 'Sublayer 3'
          })]
        }), _TestUtil["default"].createVectorLayer({
          name: 'Layer 3'
        })]
      });
      map.setLayerGroup(layerGroup);

      var got = _index.MapUtil.getLayersByGroup(map, layerGroup);

      expect(got).toBeInstanceOf(Array);
      expect(got).toHaveLength(8);
    });
  });
  describe('#getAllLayers', function () {
    var subLayer;
    var nestedLayerGroup;
    var layer1;
    var layer2;
    var layerGroup;
    beforeEach(function () {
      var layerSource1 = new _TileWMS["default"]();
      layer1 = new _Tile["default"]({
        name: 'layer1',
        source: layerSource1
      });
      var layerSource2 = new _TileWMS["default"]();
      layer2 = new _Tile["default"]({
        name: 'layer2',
        visible: false,
        source: layerSource2
      });
      subLayer = new _Tile["default"]({
        name: 'subLayer',
        source: new _TileWMS["default"]()
      });
      nestedLayerGroup = new _Group["default"]({
        name: 'nestedLayerGroup',
        layers: [subLayer]
      });
      layerGroup = new _Group["default"]({
        layers: [layer1, layer2, nestedLayerGroup]
      });
      map.setLayerGroup(layerGroup);
    });
    it('Logs an error and returns an empty array on invalid argument', function () {
      var logSpy = jest.spyOn(_Logger["default"], 'error');

      var got = _index.MapUtil.getAllLayers();

      expect(got).toBeInstanceOf(Array);
      expect(got).toHaveLength(0);
      expect(logSpy).toHaveBeenCalled();
      logSpy.mockRestore();
    });
    it('returns a flat list of all layers (map passed)', function () {
      var got = _index.MapUtil.getAllLayers(map);

      expect(got).toBeInstanceOf(Array);
      expect(got).toHaveLength(4);
      expect(got).toContain(layer1);
      expect(got).toContain(layer2);
      expect(got).toContain(nestedLayerGroup);
      expect(got).toContain(subLayer);
    });
    it('returns a flat list of all layers (layergroup passed)', function () {
      var got = _index.MapUtil.getAllLayers(nestedLayerGroup);

      expect(got).toBeInstanceOf(Array);
      expect(got).toHaveLength(1);
      expect(got).toContain(subLayer);
    });
    it('can be used with a filter', function () {
      var got = _index.MapUtil.getAllLayers(map, function (l) {
        return l.get('name') === 'layer1';
      });

      expect(got).toBeInstanceOf(Array);
      expect(got).toHaveLength(1);
      expect(got).toContain(layer1);
    });
  });
  describe('getLayerPositionInfo', function () {
    var subLayer;
    var nestedLayerGroup;
    var layer1;
    var layer2;
    var layerGroup;
    beforeEach(function () {
      var layerSource1 = new _TileWMS["default"]();
      layer1 = new _Tile["default"]({
        name: 'layer1',
        source: layerSource1
      });
      var layerSource2 = new _TileWMS["default"]();
      layer2 = new _Tile["default"]({
        name: 'layer2',
        visible: false,
        source: layerSource2
      });
      subLayer = new _Tile["default"]({
        name: 'subLayer',
        source: new _TileWMS["default"]()
      });
      nestedLayerGroup = new _Group["default"]({
        name: 'nestedLayerGroup',
        layers: [subLayer]
      });
      layerGroup = new _Group["default"]({
        layers: [layer1, layer2, nestedLayerGroup]
      });
      map.setLayerGroup(layerGroup);
    });
    it('uses the map if second argument is a map', function () {
      var layerPositionInfo = _index.MapUtil.getLayerPositionInfo(layer1, map);

      expect(layerPositionInfo).toEqual({
        position: 0,
        groupLayer: layerGroup
      });
    });
    it('uses the layerGroup if given as second argument', function () {
      var layerPositionInfo = _index.MapUtil.getLayerPositionInfo(subLayer, nestedLayerGroup);

      expect(layerPositionInfo).toEqual({
        position: 0,
        groupLayer: nestedLayerGroup
      });
    });
    it('works iterative', function () {
      var layerPositionInfo = _index.MapUtil.getLayerPositionInfo(subLayer, map);

      expect(layerPositionInfo).toEqual({
        position: 0,
        groupLayer: nestedLayerGroup
      });
    });
  });
  describe('getLegendGraphicUrl', function () {
    var layer1;
    var layer2;
    var layer3;
    var layer4;
    beforeEach(function () {
      layer1 = new _Tile["default"]({
        name: 'OSM-WMS',
        source: new _TileWMS["default"]({
          url: 'https://ows.terrestris.de/osm-gray/service?',
          params: {
            'LAYERS': 'OSM-WMS',
            'TILED': true
          },
          serverType: 'geoserver'
        })
      });
      layer2 = new _Image["default"]({
        name: 'OSM-WMS',
        source: new _ImageWMS["default"]({
          url: 'https://ows.terrestris.de/osm-gray/service',
          params: {
            'LAYERS': 'OSM-WMS',
            'TILED': true
          },
          serverType: 'geoserver'
        })
      });
      layer3 = new _Tile["default"]({
        name: 'Food insecurity',
        source: new _TileJSON["default"]({
          url: 'https://api.tiles.mapbox.com/v3/mapbox.20110804-hoa-foodinsecurity-3month.json?secure',
          crossOrigin: 'anonymous'
        })
      });
      layer4 = new _Tile["default"]({
        name: 'OSM-WMS',
        source: new _TileWMS["default"]({
          urls: ['https://a.example.com/service?humpty=dumpty', 'https://b.example.com/service?foo=bar'],
          params: {
            'LAYERS': 'OSM-WMS',
            'TILED': true
          },
          serverType: 'geoserver'
        })
      });
    });
    it('logs an error if called without a layer', function () {
      var logSpy = jest.spyOn(_Logger["default"], 'error');

      var legendUrl = _index.MapUtil.getLegendGraphicUrl();

      expect(legendUrl).toBeUndefined();
      expect(logSpy).toHaveBeenCalled();
      expect(logSpy).toHaveBeenCalledWith('No layer passed to MapUtil.getLegendGraphicUrl.');
      logSpy.mockRestore();
    });
    it('logs a warning if called with an unsupported layersource', function () {
      var logSpy = jest.spyOn(_Logger["default"], 'warn');

      var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer3);

      expect(legendUrl).toBeUndefined();
      expect(logSpy).toHaveBeenCalledWith('Source of "Food insecurity" is currently not supported by MapUtil.getLegendGraphicUrl.');
      logSpy.mockRestore();
    });
    describe('returns a getLegendGraphicUrl from a given layer', function () {
      it('… for a tiled Layer', function () {
        var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer1);

        var url = 'https://ows.terrestris.de/osm-gray/service?';
        var layerParam = 'LAYER=OSM-WMS';
        var versionParam = 'VERSION=1.3.0';
        var serviceParam = 'SERVICE=WMS';
        var requestParam = 'REQUEST=getLegendGraphic';
        var formatParam = 'FORMAT=image%2Fpng';
        expect(legendUrl).toContain(url);
        expect(legendUrl).toContain(layerParam);
        expect(legendUrl).toContain(versionParam);
        expect(legendUrl).toContain(serviceParam);
        expect(legendUrl).toContain(requestParam);
        expect(legendUrl).toContain(formatParam);
      });
      it('… for an image Layer', function () {
        var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer2);

        var url = 'https://ows.terrestris.de/osm-gray/service?';
        var layerParam = 'LAYER=OSM-WMS';
        var versionParam = 'VERSION=1.3.0';
        var serviceParam = 'SERVICE=WMS';
        var requestParam = 'REQUEST=getLegendGraphic';
        var formatParam = 'FORMAT=image%2Fpng';
        expect(legendUrl).toContain(url);
        expect(legendUrl).toContain(layerParam);
        expect(legendUrl).toContain(versionParam);
        expect(legendUrl).toContain(serviceParam);
        expect(legendUrl).toContain(requestParam);
        expect(legendUrl).toContain(formatParam);
      });
    });
    it('does not append multiple questionmarks in URL', function () {
      var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer1);

      var numQuestionMarks = (legendUrl.match(/\?/g) || []).length;
      expect(legendUrl).toEqual(expect.stringContaining('?'));
      expect(legendUrl).toEqual(expect.not.stringContaining('??'));
      expect(numQuestionMarks).toEqual(1);
    });
    it('works as expected when layer URL contains params', function () {
      var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer4);

      var numQuestionMarks = (legendUrl.match(/\?/g) || []).length;
      var containsParams = /humpty=dumpty/.test(legendUrl);
      expect(numQuestionMarks).toEqual(1);
      expect(containsParams).toBe(true);
    });
    it('accepts extraParams for the request', function () {
      var extraParams = {
        HEIGHT: 10,
        WIDTH: 10
      };

      var legendUrl = _index.MapUtil.getLegendGraphicUrl(layer1, extraParams);

      var url = 'https://ows.terrestris.de/osm-gray/service?';
      var layerParam = 'LAYER=OSM-WMS';
      var versionParam = 'VERSION=1.3.0';
      var serviceParam = 'SERVICE=WMS';
      var requestParam = 'REQUEST=getLegendGraphic';
      var formatParam = 'FORMAT=image%2Fpng';
      var heightParam = 'HEIGHT=10';
      var widthParam = 'WIDTH=10';
      expect(legendUrl).toContain(url);
      expect(legendUrl).toContain(layerParam);
      expect(legendUrl).toContain(versionParam);
      expect(legendUrl).toContain(serviceParam);
      expect(legendUrl).toContain(requestParam);
      expect(legendUrl).toContain(formatParam);
      expect(legendUrl).toContain(heightParam);
      expect(legendUrl).toContain(widthParam);
    });
  });
  describe('layerInResolutionRange', function () {
    it('is defined', function () {
      expect(_index.MapUtil.layerInResolutionRange).not.toBeUndefined();
    });
    it('is a function', function () {
      expect(_index.MapUtil.layerInResolutionRange).toBeInstanceOf(Function);
    });
    it('returns false if not passed a layer', function () {
      expect(_index.MapUtil.layerInResolutionRange()).toBe(false);
    });
    it('returns false if not passed a map', function () {
      var layer = new _Tile["default"]();
      expect(_index.MapUtil.layerInResolutionRange(layer)).toBe(false);
    });
    it('returns false if map does not have a view', function () {
      var layer = new _Tile["default"]();
      var map = new _Map["default"]({
        view: null
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
    it('returns false if map view does not have a resolution', function () {
      var layer = new _Tile["default"]();
      var view = new _View["default"]();
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
    it('returns true: layer (no limits) & any viewRes', function () {
      var layer = new _Tile["default"]();
      var view = new _View["default"]({
        resolution: 42
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns true: layer (w/ minResolution) & viewRes > l.minres', function () {
      var layer = new _Tile["default"]({
        minResolution: 42
      });
      var view = new _View["default"]({
        resolution: 43
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns true: layer (w/ minResolution) & viewRes = l.minres', function () {
      var layer = new _Tile["default"]({
        minResolution: 42
      });
      var view = new _View["default"]({
        resolution: 42
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns true: layer (w/ maxResolution) & viewRes < l.maxres', function () {
      var layer = new _Tile["default"]({
        maxResolution: 42
      });
      var view = new _View["default"]({
        resolution: 41
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns false: layer (w/ maxResolution) & viewRes = l.maxres', function () {
      var layer = new _Tile["default"]({
        maxResolution: 42
      });
      var view = new _View["default"]({
        resolution: 42
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
    it('returns true: layer (w/ min and max) & viewRes  within', function () {
      var layer = new _Tile["default"]({
        minResolution: 42,
        maxResolution: 50
      });
      var view = new _View["default"]({
        resolution: 46
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns false: layer (w/ min and max) & viewRes outside min', function () {
      var layer = new _Tile["default"]({
        minResolution: 42,
        maxResolution: 50
      });
      var view = new _View["default"]({
        resolution: 38
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
    it('returns true: layer (w/ min and max) & viewRes = min', function () {
      var layer = new _Tile["default"]({
        minResolution: 42,
        maxResolution: 50
      });
      var view = new _View["default"]({
        resolution: 42
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(true);
    });
    it('returns false: layer (w/ min and max) & viewRes outside max', function () {
      var layer = new _Tile["default"]({
        minResolution: 42,
        maxResolution: 50
      });
      var view = new _View["default"]({
        resolution: 54
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
    it('returns false: layer (w/ min and max) & viewRes = max', function () {
      var layer = new _Tile["default"]({
        minResolution: 42,
        maxResolution: 50
      });
      var view = new _View["default"]({
        resolution: 50
      });
      var map = new _Map["default"]({
        view: view
      });
      expect(_index.MapUtil.layerInResolutionRange(layer, map)).toBe(false);
    });
  });
  describe('#getLayersByProperty', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getLayersByProperty).not.toBeUndefined();
    });
    it('is a function', function () {
      expect(_index.MapUtil.getLayersByProperty).toBeInstanceOf(Function);
    });
    it('returns the layer for the given property', function () {
      var key = 'key';
      var prop = 'prop';
      var layer = new _Tile["default"]({
        visible: false
      });
      layer.set(key, prop);
      map.addLayer(layer);

      var got = _index.MapUtil.getLayersByProperty(map, key, prop);

      expect(got).toHaveLength(1);
      expect(got[0]).toEqual(layer);
      expect(got[0]).toBeInstanceOf(_Tile["default"]);
      expect(got[0].get('key')).toBe('prop');
    });
    it('returns undefined if the map is null', function () {
      var key = 'key';
      var prop = 'prop';

      var got = _index.MapUtil.getLayersByProperty(null, key, prop);

      expect(got).toBeUndefined();
    });
    it('returns undefined if the key is null', function () {
      var prop = 'prop';

      var got = _index.MapUtil.getLayersByProperty(map, null, prop);

      expect(got).toBeUndefined();
    });
  });
  describe('#getZoomForScale', function () {
    it('is defined', function () {
      expect(_index.MapUtil.getZoomForScale).toBeDefined();
    });
    it('returns 0 if non numeric scale is provided', function () {
      var got = _index.MapUtil.getZoomForScale('scale', [1, 2]);

      expect(got).toBe(0);
    });
    it('returns 0 if negative scale is provided', function () {
      var got = _index.MapUtil.getZoomForScale(-1, [1, 2]);

      expect(got).toBe(0);
    });
    it('calls getResolutionForScale method', function () {
      var spy = jest.spyOn(_index.MapUtil, 'getResolutionForScale');

      _index.MapUtil.getZoomForScale(2000, [1, 2, 3]);

      expect(spy).toHaveBeenCalledTimes(1);
      spy.mockRestore();
    });
    it('returns zoom level for provided resolution', function () {
      var mercatorResolutions = [1.19432856696, // 4265
      0.597164283478, // 2132
      0.298582141739, // 1066
      0.149291070869 // 533
      ];
      var testScales = [5000, 2500, 1000, 500];
      var index = 0;
      testScales.forEach(function (scale) {
        expect(_index.MapUtil.getZoomForScale(scale, mercatorResolutions)).toBe(index);
        index++;
      });
    });
  });
  describe('#zoomToFeatures', function () {
    var features = [new _Feature["default"]({
      geometry: new _Point["default"]([0, 0])
    }), new _Feature["default"]({
      geometry: new _Point["default"]([1, 1])
    }), new _Feature["default"]({
      geometry: new _Point["default"]([2, 2])
    })];
    it('is defined', function () {
      expect(_index.MapUtil.zoomToFeatures).toBeDefined();
    });
    it('returns undefined if no map is given', function () {
      var got = _index.MapUtil.zoomToFeatures(null, features);

      expect(got).toBe(undefined);
    });
    it('fits the view extent to the extent of the given features', function () {
      var view = new _View["default"]({
        zoom: 19
      });
      var map = new _Map["default"]({
        view: view
      });

      _index.MapUtil.zoomToFeatures(map, features);

      var extent = view.calculateExtent();
      expect(extent[0]).toBeCloseTo(-0.866138385868561);
      expect(extent[1]).toBeCloseTo(-0.866138385868561);
      expect(extent[2]).toBeCloseTo(2.866138385868561);
      expect(extent[3]).toBeCloseTo(2.866138385868561);
    });
  });
  describe('#isInScaleRange', function () {
    it('is defined', function () {
      expect(_index.MapUtil.isInScaleRange).toBeDefined();
    });
    it('returns the visibility of a given layer', function () {
      var layer = _TestUtil["default"].createVectorLayer();

      var inScaleRange = _index.MapUtil.isInScaleRange(layer, 5);

      expect(inScaleRange).toBe(true);
      layer.setProperties({
        minResolution: 0,
        maxResolution: 10
      });
      inScaleRange = _index.MapUtil.isInScaleRange(layer, 5);
      expect(inScaleRange).toBe(true);
      inScaleRange = _index.MapUtil.isInScaleRange(layer, 15);
      expect(inScaleRange).toBe(false);
    });
  });
});