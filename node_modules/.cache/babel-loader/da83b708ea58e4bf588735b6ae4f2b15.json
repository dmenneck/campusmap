{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nimport TileState from '../TileState.js';\nimport VectorImageTile, { defaultLoadFunction } from '../VectorImageTile.js';\nimport Tile from '../VectorTile.js';\nimport { toSize } from '../size.js';\nimport UrlTile from './UrlTile.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { createXYZ, extentFromProjection, createForProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize=128] Cache size.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} projection Projection.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level.\n * @property {number} [minZoom] Optional min zoom level.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function() {\n *     var data = // ... fetch data\n *     var format = tile.getFormat();\n *     tile.setProjection(format.readProjection(data));\n *     tile.setFeatures(format.readFeatures(data, {\n *       // featureProjection is not required for ol/format/MVT\n *       featureProjection: map.getView().getProjection()\n *     }));\n *     // the line below is only required for ol/format/MVT\n *     tile.setExtent(format.getLastExtent());\n *   }\n * });\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar VectorTile =\n/*@__PURE__*/\nfunction (UrlTile) {\n  function VectorTile(options) {\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxZoom: options.maxZoom || 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    UrlTile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition\n    });\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n\n    this.format_ = options.format ? options.format : null;\n    /**\n       * @private\n       * @type {Object<string, Tile>}\n       */\n\n    this.sourceTiles_ = {};\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    this.tileGrids_ = {};\n  }\n\n  if (UrlTile) VectorTile.__proto__ = UrlTile;\n  VectorTile.prototype = Object.create(UrlTile && UrlTile.prototype);\n  VectorTile.prototype.constructor = VectorTile;\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n  VectorTile.prototype.getOverlaps = function getOverlaps() {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  VectorTile.prototype.clear = function clear() {\n    this.tileCache.clear();\n    this.sourceTiles_ = {};\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorTile.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return (\n        /** @type {!import(\"../Tile.js\").default} */\n        this.tileCache.get(tileCoordKey)\n      );\n    } else {\n      var tileCoord = [z, x, y];\n      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      var tile = new VectorImageTile(tileCoord, urlTileCoord !== null ? TileState.IDLE : TileState.EMPTY, this.getRevision(), this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction, this.tileGrid, this.getTileGridForProjection(projection), this.sourceTiles_, pixelRatio, projection, this.tileClass, this.handleTileChange.bind(this), tileCoord[0]);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorTile.prototype.getTileGridForProjection = function getTileGridForProjection(projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = this.tileGrids_[code] = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n    }\n\n    return tileGrid;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorTile.prototype.getTilePixelRatio = function getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorTile.prototype.getTilePixelSize = function getTilePixelSize(z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n\n  return VectorTile;\n}(UrlTile);\n\nexport default VectorTile;","map":{"version":3,"sources":["../../../src/ol/source/VectorTile.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\n\nimport TileState from '../TileState.js';\nimport VectorImageTile, {defaultLoadFunction} from '../VectorImageTile.js';\nimport Tile from '../VectorTile.js';\nimport {toSize} from '../size.js';\nimport UrlTile from './UrlTile.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection, createForProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize=128] Cache size.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} projection Projection.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level.\n * @property {number} [minZoom] Optional min zoom level.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function() {\n *     var data = // ... fetch data\n *     var format = tile.getFormat();\n *     tile.setProjection(format.readProjection(data));\n *     tile.setFeatures(format.readFeatures(data, {\n *       // featureProjection is not required for ol/format/MVT\n *       featureProjection: map.getView().getProjection()\n *     }));\n *     // the line below is only required for ol/format/MVT\n *     tile.setExtent(format.getLastExtent());\n *   }\n * });\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n */\n\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxZoom: options.maxZoom || 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n       * @private\n       * @type {Object<string, Tile>}\n       */\n    this.sourceTiles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n    this.sourceTiles_ = {};\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return (\n        /** @type {!import(\"../Tile.js\").default} */ (this.tileCache.get(tileCoordKey))\n      );\n    } else {\n      const tileCoord = [z, x, y];\n      const urlTileCoord = this.getTileCoordForTileUrlFunction(\n        tileCoord, projection);\n      const tile = new VectorImageTile(\n        tileCoord,\n        urlTileCoord !== null ? TileState.IDLE : TileState.EMPTY,\n        this.getRevision(),\n        this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction,\n        this.tileGrid, this.getTileGridForProjection(projection),\n        this.sourceTiles_, pixelRatio, projection, this.tileClass,\n        this.handleTileChange.bind(this), tileCoord[0]);\n\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      tileGrid = this.tileGrids_[code] = createForProjection(projection, undefined,\n        sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n    }\n    return tileGrid;\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n\n  /**\n   * @inheritDoc\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  }\n}\n\n\nexport default VectorTile;\n"]},"metadata":{},"sourceType":"module"}