{"ast":null,"code":"/**\n * @module ol/render/canvas/LineStringReplay\n */\nimport { inherits } from '../../util.js';\nimport CanvasInstruction, { strokeInstruction, beginPathInstruction } from '../canvas/Instruction.js';\nimport CanvasReplay from '../canvas/Replay.js';\n/**\n * @constructor\n * @extends {module:ol/render/canvas/Replay}\n * @param {number} tolerance Tolerance.\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\n\nconst CanvasLineStringReplay = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n};\n\ninherits(CanvasLineStringReplay, CanvasReplay);\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @private\n * @return {number} end.\n */\n\nCanvasLineStringReplay.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {\n  const myBegin = this.coordinates.length;\n  const myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n  const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n  this.instructions.push(moveToLineToInstruction);\n  this.hitDetectionInstructions.push(moveToLineToInstruction);\n  return end;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasLineStringReplay.prototype.drawLineString = function (lineStringGeometry, feature) {\n  const state = this.state;\n  const strokeStyle = state.strokeStyle;\n  const lineWidth = state.lineWidth;\n\n  if (strokeStyle === undefined || lineWidth === undefined) {\n    return;\n  }\n\n  this.updateStrokeStyle(state, this.applyStroke);\n  this.beginGeometry(lineStringGeometry, feature);\n  this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n  const flatCoordinates = lineStringGeometry.getFlatCoordinates();\n  const stride = lineStringGeometry.getStride();\n  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n  this.hitDetectionInstructions.push(strokeInstruction);\n  this.endGeometry(lineStringGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasLineStringReplay.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {\n  const state = this.state;\n  const strokeStyle = state.strokeStyle;\n  const lineWidth = state.lineWidth;\n\n  if (strokeStyle === undefined || lineWidth === undefined) {\n    return;\n  }\n\n  this.updateStrokeStyle(state, this.applyStroke);\n  this.beginGeometry(multiLineStringGeometry, feature);\n  this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n  const ends = multiLineStringGeometry.getEnds();\n  const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n  const stride = multiLineStringGeometry.getStride();\n  let offset = 0;\n\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);\n  }\n\n  this.hitDetectionInstructions.push(strokeInstruction);\n  this.endGeometry(multiLineStringGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasLineStringReplay.prototype.finish = function () {\n  const state = this.state;\n\n  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n    this.instructions.push(strokeInstruction);\n  }\n\n  this.reverseHitDetectionInstructions();\n  this.state = null;\n};\n/**\n * @inheritDoc.\n */\n\n\nCanvasLineStringReplay.prototype.applyStroke = function (state) {\n  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n    this.instructions.push(strokeInstruction);\n    state.lastStroke = this.coordinates.length;\n  }\n\n  state.lastStroke = 0;\n  CanvasReplay.prototype.applyStroke.call(this, state);\n  this.instructions.push(beginPathInstruction);\n};\n\nexport default CanvasLineStringReplay;","map":null,"metadata":{},"sourceType":"module"}