{"ast":null,"code":"/**\n * @module ol/layer/Group\n */\nimport { getUid, inherits } from '../util.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { getChangeEventType } from '../Object.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport { assert } from '../asserts.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getIntersection } from '../extent.js';\nimport BaseLayer from '../layer/Base.js';\nimport { assign, clear } from '../obj.js';\nimport SourceState from '../source/State.js';\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {(Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>)} [layers] Child layers.\n */\n\n/**\n * @enum {string}\n * @private\n */\n\nconst Property = {\n  LAYERS: 'layers'\n};\n/**\n * @classdesc\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\n *\n * A generic `change` event is triggered when the group/Collection changes.\n *\n * @constructor\n * @extends {module:ol/layer/Base}\n * @param {module:ol/layer/Group~Options=} opt_options Layer options.\n * @api\n */\n\nconst LayerGroup = function (opt_options) {\n  const options = opt_options || {};\n  const baseOptions =\n  /** @type {module:ol/layer/Group~Options} */\n  assign({}, options);\n  delete baseOptions.layers;\n  let layers = options.layers;\n  BaseLayer.call(this, baseOptions);\n  /**\n   * @private\n   * @type {Array.<module:ol/events~EventsKey>}\n   */\n\n  this.layersListenerKeys_ = [];\n  /**\n   * @private\n   * @type {Object.<string, Array.<module:ol/events~EventsKey>>}\n   */\n\n  this.listenerKeys_ = {};\n  listen(this, getChangeEventType(Property.LAYERS), this.handleLayersChanged_, this);\n\n  if (layers) {\n    if (Array.isArray(layers)) {\n      layers = new Collection(layers.slice(), {\n        unique: true\n      });\n    } else {\n      assert(layers instanceof Collection, 43); // Expected `layers` to be an array or a `Collection`\n\n      layers = layers;\n    }\n  } else {\n    layers = new Collection(undefined, {\n      unique: true\n    });\n  }\n\n  this.setLayers(layers);\n};\n\ninherits(LayerGroup, BaseLayer);\n/**\n * @private\n */\n\nLayerGroup.prototype.handleLayerChange_ = function () {\n  this.changed();\n};\n/**\n * @param {module:ol/events/Event} event Event.\n * @private\n */\n\n\nLayerGroup.prototype.handleLayersChanged_ = function (event) {\n  this.layersListenerKeys_.forEach(unlistenByKey);\n  this.layersListenerKeys_.length = 0;\n  const layers = this.getLayers();\n  this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));\n\n  for (const id in this.listenerKeys_) {\n    this.listenerKeys_[id].forEach(unlistenByKey);\n  }\n\n  clear(this.listenerKeys_);\n  const layersArray = layers.getArray();\n\n  for (let i = 0, ii = layersArray.length; i < ii; i++) {\n    const layer = layersArray[i];\n    this.listenerKeys_[getUid(layer).toString()] = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];\n  }\n\n  this.changed();\n};\n/**\n * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.\n * @private\n */\n\n\nLayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {\n  const layer =\n  /** @type {module:ol/layer/Base} */\n  collectionEvent.element;\n  const key = getUid(layer).toString();\n  this.listenerKeys_[key] = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];\n  this.changed();\n};\n/**\n * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.\n * @private\n */\n\n\nLayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {\n  const layer =\n  /** @type {module:ol/layer/Base} */\n  collectionEvent.element;\n  const key = getUid(layer).toString();\n  this.listenerKeys_[key].forEach(unlistenByKey);\n  delete this.listenerKeys_[key];\n  this.changed();\n};\n/**\n * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n * in this group.\n * @return {!module:ol/Collection.<module:ol/layer/Base>} Collection of\n *   {@link module:ol/layer/Base layers} that are part of this group.\n * @observable\n * @api\n */\n\n\nLayerGroup.prototype.getLayers = function () {\n  return (\n    /** @type {!module:ol/Collection.<module:ol/layer/Base>} */\n    this.get(Property.LAYERS)\n  );\n};\n/**\n * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n * in this group.\n * @param {!module:ol/Collection.<module:ol/layer/Base>} layers Collection of\n *   {@link module:ol/layer/Base layers} that are part of this group.\n * @observable\n * @api\n */\n\n\nLayerGroup.prototype.setLayers = function (layers) {\n  this.set(Property.LAYERS, layers);\n};\n/**\n * @inheritDoc\n */\n\n\nLayerGroup.prototype.getLayersArray = function (opt_array) {\n  const array = opt_array !== undefined ? opt_array : [];\n  this.getLayers().forEach(function (layer) {\n    layer.getLayersArray(array);\n  });\n  return array;\n};\n/**\n * @inheritDoc\n */\n\n\nLayerGroup.prototype.getLayerStatesArray = function (opt_states) {\n  const states = opt_states !== undefined ? opt_states : [];\n  const pos = states.length;\n  this.getLayers().forEach(function (layer) {\n    layer.getLayerStatesArray(states);\n  });\n  const ownLayerState = this.getLayerState();\n\n  for (let i = pos, ii = states.length; i < ii; i++) {\n    const layerState = states[i];\n    layerState.opacity *= ownLayerState.opacity;\n    layerState.visible = layerState.visible && ownLayerState.visible;\n    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);\n    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);\n\n    if (ownLayerState.extent !== undefined) {\n      if (layerState.extent !== undefined) {\n        layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);\n      } else {\n        layerState.extent = ownLayerState.extent;\n      }\n    }\n  }\n\n  return states;\n};\n/**\n * @inheritDoc\n */\n\n\nLayerGroup.prototype.getSourceState = function () {\n  return SourceState.READY;\n};\n\nexport default LayerGroup;","map":null,"metadata":{},"sourceType":"module"}