{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, createEmpty, equals, getIntersection, isEmpty } from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\n\nvar CanvasTileLayerRenderer =\n/*@__PURE__*/\nfunction (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n    IntermediateCanvasRenderer.call(this, tileLayer);\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = opt_noContext ? null : createCanvasContext2D();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.oversampling_;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n\n    this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.imageTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.zDirection = 0;\n  }\n\n  if (IntermediateCanvasRenderer) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype);\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n    var tileLayer =\n    /** @type {import(\"../../layer/Tile.js\").default} */\n    this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tileLayer =\n    /** @type {import(\"../../layer/Tile.js\").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import(\"../../source/Tile.js\").default} */\n    tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var tileLayer =\n    /** @type {import(\"../../layer/Tile.js\").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import(\"../../source/Tile.js\").default} */\n    tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n\n        if (this.isDrawableTile_(tile)) {\n          var uid = getUid(this);\n\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n      var context = this.context;\n\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_) || this.renderedRevision != sourceRevision) {\n            context.clearRect(0, 0, width, height);\n          }\n\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function (a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    var scale = this.renderedResolution / viewResolution;\n    var transform = composeTransform(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    return this.renderedTiles.length > 0;\n  };\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var tileLayer =\n    /** @type {import(\"../../layer/Tile.js\").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import(\"../../source/Tile.js\").default} */\n    tileLayer.getSource();\n\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n    return this.imageTransform_;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    return (\n      /** @type {import(\"../../ImageTile.js\").default} */\n      tile.getImage()\n    );\n  };\n\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvasRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.TILE;\n};\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\n\n\nCanvasTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(\n  /** @type {import(\"../../layer/Tile.js\").default} */\n  layer);\n};\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\n\n\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/TileLayer.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, createEmpty, equals, getIntersection, isEmpty} from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends IntermediateCanvasRenderer {\n\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   * @param {boolean=} opt_noContext Skip the context creation.\n   */\n  constructor(tileLayer, opt_noContext) {\n\n    super(tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED ||\n        tileState == TileState.EMPTY ||\n        tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n\n    const pixelRatio = frameState.pixelRatio;\n    const size = frameState.size;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    let oversampling = Math.round(viewResolution / tileResolution) || 1;\n    let extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    const imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource, projection, tilesToDrawByZ);\n\n    const hints = frameState.viewHints;\n    const animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    let tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n        if (this.isDrawableTile_(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord, tmpTileRange, tmpExtent);\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n\n      }\n    }\n\n    const renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n      this.newTiles_ ||\n          !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||\n          this.renderedRevision != sourceRevision ||\n          oversampling != this.oversampling_ ||\n          !animatingOrInteracting && renderedResolution != this.renderedResolution\n    )) {\n\n      const context = this.context;\n      if (context) {\n        const tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        const width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        const height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        const canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if ((this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) ||\n              this.renderedRevision != sourceRevision) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      const zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function(a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      let currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      let tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (const tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    const scale = this.renderedResolution / viewResolution;\n    const transform = composeTransform(this.imageTransform_,\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n      scale, scale,\n      0,\n      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform,\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\n      0,\n      -viewCenter[0], -viewCenter[1]);\n\n\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n      projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n\n    return this.renderedTiles.length > 0;\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter,\n      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageTransform() {\n    return this.imageTransform_;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return /** @type {import(\"../../ImageTile.js\").default} */ (tile).getImage();\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(/** @type {import(\"../../layer/Tile.js\").default} */ (layer));\n};\n\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\n\nexport default CanvasTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}