{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport { equivalent as equivalentProjection } from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup, { replayDeclutter } from '../../render/canvas/ReplayGroup.js';\nimport { ORDER } from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { create as createTransform, compose as composeTransform, reset as resetTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\n\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\n\nvar VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\n\nvar CanvasVectorTileLayerRenderer =\n/*@__PURE__*/\nfunction (CanvasTileLayerRenderer) {\n  function CanvasVectorTileLayerRenderer(layer) {\n    CanvasTileLayerRenderer.call(this, layer, true);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.tmpTransform_ = createTransform();\n    var renderMode = layer.getRenderMode(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n\n  if (CanvasTileLayerRenderer) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;\n  CanvasVectorTileLayerRenderer.prototype = Object.create(CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype);\n  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_(\n      /** @type {import(\"../../VectorImageTile.js\").default} */\n      tile, pixelRatio, projection);\n\n      if (this.context) {\n        this.renderTileImage_(\n        /** @type {import(\"../../VectorImageTile.js\").default} */\n        tile, pixelRatio, projection);\n      }\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    var tileLayer =\n    /** @type {import(\"../../layer/Tile.js\").default} */\n    this.getLayer();\n    return (\n      /** @type {import(\"../../VectorImageTile.js\").default} */\n      tile.getImage(tileLayer)\n    );\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var layer =\n    /** @type {import(\"../../layer/Vector.js\").default} */\n    this.getLayer();\n    var layerRevision = layer.getRevision();\n\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n\n    this.renderedLayerRevision_ = layerRevision;\n    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);\n  };\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_(tile, pixelRatio, projection) {\n    var this$1 = this;\n    var layer =\n    /** @type {import(\"../../layer/Vector.js\").default} */\n    this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder =\n    /** @type {import(\"../../render.js\").OrderFunction} */\n    layer.getRenderOrder() || null;\n    var replayState = tile.getReplayState(layer);\n\n    if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    var source =\n    /** @type {import(\"../../source/VectorTile.js\").default} */\n    layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var tileExtent = tile.extent;\n\n    var loop = function (t, tt) {\n      var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        return;\n      }\n\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);\n      var tileProjection = sourceTile.getProjection();\n      var reproject = false;\n\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n\n      replayState.dirty = false;\n      var replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n\n      var features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space\n\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this$1, feature);\n        }\n      }\n\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    };\n\n    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop(t, tt);\n\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n\n    var features = {};\n    var renderedTiles =\n    /** @type {Array<import(\"../../VectorImageTile.js\").default>} */\n    this.renderedTiles;\n    var bufferedExtent, found;\n    var i, ii;\n\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      var tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n\n        var replayGroup =\n        /** @type {CanvasReplayGroup} */\n        sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          var key = getUid(feature);\n\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      }\n    }\n\n    return found;\n  };\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_(tile, frameState) {\n    var layer = this.getLayer();\n    var source =\n    /** @type {import(\"../../source/VectorTile.js\").default} */\n    layer.getSource();\n    var tileGrid = source.getTileGrid();\n    var tileCoord = tile.tileCoord;\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var renderResolution = viewState.resolution / pixelRatio;\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var center = viewState.center;\n    var origin = getTopLeft(tileExtent);\n    var size = frameState.size;\n    var offsetX = Math.round(pixelRatio * size[0] / 2);\n    var offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n  };\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState) {\n    var layer =\n    /** @type {import(\"../../layer/Vector.js\").default} */\n    this.getLayer();\n    var renderMode = layer.getRenderMode();\n\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      var declutterReplays = layer.getDeclutter() ? {} : null;\n      var source =\n      /** @type {import(\"../../source/VectorTile.js\").default} */\n      layer.getSource();\n      var replayTypes = VECTOR_REPLAYS[renderMode];\n      var pixelRatio = frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      var size = frameState.size;\n      var offsetX, offsetY;\n\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var tiles = this.renderedTiles;\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var clips = [];\n      var zs = [];\n\n      for (var i = tiles.length - 1; i >= 0; --i) {\n        var tile =\n        /** @type {import(\"../../VectorImageTile.js\").default} */\n        tiles[i];\n\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n\n        var tileCoord = tile.tileCoord;\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        var transform = undefined;\n\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n\n          var replayGroup =\n          /** @type {CanvasReplayGroup} */\n          sourceTile.getReplayGroup(layer, tileCoord.toString());\n\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n\n          var currentZ = sourceTile.tileCoord[0];\n          var currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n\n            if (currentZ < zs[j]) {\n              context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n\n      if (rotation) {\n        rotateAtOffset(context, rotation,\n        /** @type {number} */\n        offsetX,\n        /** @type {number} */\n        offsetY);\n      }\n    }\n\n    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n    }\n\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_(tile, pixelRatio, projection) {\n    var layer =\n    /** @type {import(\"../../layer/Vector.js\").default} */\n    this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var replays = IMAGE_REPLAYS[layer.getRenderMode()];\n\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var source =\n      /** @type {import(\"../../source/VectorTile.js\").default} */\n      layer.getSource();\n      var tileGrid = source.getTileGridForProjection(projection);\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n      var size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n\n      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        var sourceTile = tile.getTile(tile.tileKeys[i]);\n\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n\n        var pixelScale = pixelRatio / resolution;\n        var transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        var replayGroup =\n        /** @type {CanvasReplayGroup} */\n        sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  };\n\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasVectorTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\n\n\nCanvasVectorTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer(\n  /** @type {import(\"../../layer/VectorTile.js\").default} */\n  layer);\n};\n\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/VectorTileLayer.js"],"names":["const","super","let","t","tt","this"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects} from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport {equivalent as equivalentProjection} from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup, {replayDeclutter} from '../../render/canvas/ReplayGroup.js';\nimport {ORDER} from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport {getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\nimport {\n  create as createTransform,\n  compose as composeTransform,\n  reset as resetTransform,\n  scale as scaleTransform,\n  translate as translateTransform\n} from '../../transform.js';\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE,\n    ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n\n    super(layer, true);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    const renderMode = layer.getRenderMode();\n\n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    super.disposeInternal();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tile = super.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      if (this.context) {\n        this.renderTileImage_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    return /** @type {import(\"../../VectorImageTile.js\").default} */ (tile).getImage(tileLayer);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return super.prepareFrame(frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  createReplayGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const revision = layer.getRevision();\n    const renderOrder = /** @type {import(\"../../render.js\").OrderFunction} */ (layer.getRenderOrder()) || null;\n\n    const replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision &&\n        replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const tileExtent = tile.extent;\n\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null :\n        buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\n      const tileProjection = sourceTile.getProjection();\n      let reproject = false;\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      const replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution,\n        pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\n      const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function(feature) {\n        let styles;\n        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this, feature);\n        }\n      }\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    }\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n    const features = {};\n\n    const renderedTiles = /** @type {Array<import(\"../../VectorImageTile.js\").default>} */ (this.renderedTiles);\n\n    let bufferedExtent, found;\n    let i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        const sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            const key = getUid(feature);\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          }, null);\n      }\n    }\n    return found;\n  }\n\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n  getReplayTransform_(tile, frameState) {\n    const layer = this.getLayer();\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const tileGrid = source.getTileGrid();\n    const tileCoord = tile.tileCoord;\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\n    const viewState = frameState.viewState;\n    const pixelRatio = frameState.pixelRatio;\n    const renderResolution = viewState.resolution / pixelRatio;\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const center = viewState.center;\n    const origin = getTopLeft(tileExtent);\n    const size = frameState.size;\n    const offsetX = Math.round(pixelRatio * size[0] / 2);\n    const offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_,\n      offsetX, offsetY,\n      tileResolution / renderResolution, tileResolution / renderResolution,\n      viewState.rotation,\n      (origin[0] - center[0]) / tileResolution,\n      (center[1] - origin[1]) / tileResolution);\n  }\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  handleFontsChanged_(event) {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  postCompose(context, frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const renderMode = layer.getRenderMode();\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      const declutterReplays = layer.getDeclutter() ? {} : null;\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const replayTypes = VECTOR_REPLAYS[renderMode];\n      const pixelRatio = frameState.pixelRatio;\n      const rotation = frameState.viewState.rotation;\n      const size = frameState.size;\n      let offsetX, offsetY;\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n      const viewHints = frameState.viewHints;\n      const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      const tiles = this.renderedTiles;\n      const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      const clips = [];\n      const zs = [];\n      for (let i = tiles.length - 1; i >= 0; --i) {\n        const tile = /** @type {import(\"../../VectorImageTile.js\").default} */ (tiles[i]);\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n        const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        let transform = undefined;\n        for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          const sourceTile = tile.getTile(tile.tileKeys[t]);\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n          const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer, tileCoord.toString()));\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n          const currentZ = sourceTile.tileCoord[0];\n          const currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity;\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (let j = 0, jj = clips.length; j < jj; ++j) {\n            const clip = clips[j];\n            if (currentZ < zs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n      if (rotation) {\n        rotateAtOffset(context, rotation,\n          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\n      }\n    }\n    super.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i], squaredTolerance,\n          this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles, squaredTolerance,\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  renderTileImage_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const replays = IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      const tileCoord = tile.wrappedTileCoord;\n      const z = tileCoord[0];\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const tileGrid = source.getTileGridForProjection(projection);\n      const resolution = tileGrid.getResolution(z);\n      const context = tile.getContext(layer);\n      const size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      for (let i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        const sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const pixelScale = pixelRatio / resolution;\n        const transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\nCanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer(/** @type {import(\"../../layer/VectorTile.js\").default} */ (layer));\n};\n\n\nexport default CanvasVectorTileLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}