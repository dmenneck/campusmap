{"ast":null,"code":"/**\n * @module ol/format/WFS\n */\nimport { inherits } from '../util.js';\nimport { assert } from '../asserts.js';\nimport GML2 from '../format/GML2.js';\nimport GML3 from '../format/GML3.js';\nimport GMLBase, { GMLNS } from '../format/GMLBase.js';\nimport { and as andFilter, bbox as bboxFilter } from '../format/filter.js';\nimport XMLFeature from '../format/XMLFeature.js';\nimport { readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode } from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { createElementNS, isDocument, isNode, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode, pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI } from '../xml.js';\n/**\n * @typedef {Object} Options\n * @property {Object.<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array.<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {module:ol/format/GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array.<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array.<string>} [propertyNames] Optional list of property names to serialize.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {module:ol/extent~Extent} [bbox] Extent to use for the BBOX filter.\n * @property {module:ol/format/filter/Filter} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array.<Object>} nativeElements Native elements. Currently not supported.\n * @property {module:ol/format/GMLBase~Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {module:ol/extent~Extent} bounds\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array.<string>} insertIds\n */\n\n/**\n * @type {string}\n */\n\nconst FEATURE_PREFIX = 'feature';\n/**\n * @type {string}\n */\n\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n/**\n * @type {string}\n */\n\nconst OGCNS = 'http://www.opengis.net/ogc';\n/**\n * @type {string}\n */\n\nconst WFSNS = 'http://www.opengis.net/wfs';\n/**\n * @type {string}\n */\n\nconst FESNS = 'http://www.opengis.net/fes';\n/**\n * @type {Object.<string, string>}\n */\n\nconst SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n/**\n * @const\n * @type {string}\n */\n\nconst DEFAULT_VERSION = '1.1.0';\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @constructor\n * @param {module:ol/format/WFS~Options=} opt_options Optional configuration object.\n * @extends {module:ol/format/XMLFeature}\n * @api\n */\n\nconst WFS = function (opt_options) {\n  const options = opt_options ? opt_options : {};\n  /**\n   * @private\n   * @type {Array.<string>|string|undefined}\n   */\n\n  this.featureType_ = options.featureType;\n  /**\n   * @private\n   * @type {Object.<string, string>|string|undefined}\n   */\n\n  this.featureNS_ = options.featureNS;\n  /**\n   * @private\n   * @type {module:ol/format/GMLBase}\n   */\n\n  this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML3();\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  XMLFeature.call(this);\n};\n\ninherits(WFS, XMLFeature);\n/**\n * @return {Array.<string>|string|undefined} featureType\n */\n\nWFS.prototype.getFeatureType = function () {\n  return this.featureType_;\n};\n/**\n * @param {Array.<string>|string|undefined} featureType Feature type(s) to parse.\n */\n\n\nWFS.prototype.setFeatureType = function (featureType) {\n  this.featureType_ = featureType;\n};\n/**\n * Read all features from a WFS FeatureCollection.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\n * @return {Array.<module:ol/Feature>} Features.\n * @api\n */\n\n\nWFS.prototype.readFeatures;\n/**\n * @inheritDoc\n */\n\nWFS.prototype.readFeaturesFromNode = function (node, opt_options) {\n  const context =\n  /** @type {module:ol/xml~NodeStackItem} */\n  {\n    'featureType': this.featureType_,\n    'featureNS': this.featureNS_\n  };\n  assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n  const objectStack = [context];\n  this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n  let features = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, objectStack, this.gmlFormat_);\n\n  if (!features) {\n    features = [];\n  }\n\n  return features;\n};\n/**\n * Read transaction response of the source.\n *\n * @param {Document|Node|Object|string} source Source.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n * @api\n */\n\n\nWFS.prototype.readTransactionResponse = function (source) {\n  if (isDocument(source)) {\n    return this.readTransactionResponseFromDocument(\n    /** @type {Document} */\n    source);\n  } else if (isNode(source)) {\n    return this.readTransactionResponseFromNode(\n    /** @type {Node} */\n    source);\n  } else if (typeof source === 'string') {\n    const doc = parse(source);\n    return this.readTransactionResponseFromDocument(doc);\n  } else {\n    return undefined;\n  }\n};\n/**\n * Read feature collection metadata of the source.\n *\n * @param {Document|Node|Object|string} source Source.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n * @api\n */\n\n\nWFS.prototype.readFeatureCollectionMetadata = function (source) {\n  if (isDocument(source)) {\n    return this.readFeatureCollectionMetadataFromDocument(\n    /** @type {Document} */\n    source);\n  } else if (isNode(source)) {\n    return this.readFeatureCollectionMetadataFromNode(\n    /** @type {Node} */\n    source);\n  } else if (typeof source === 'string') {\n    const doc = parse(source);\n    return this.readFeatureCollectionMetadataFromDocument(doc);\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Document} doc Document.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n */\n\n\nWFS.prototype.readFeatureCollectionMetadataFromDocument = function (doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readFeatureCollectionMetadataFromNode(n);\n    }\n  }\n\n  return undefined;\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\n\n\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n/**\n * @param {Node} node Node.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n */\n\nWFS.prototype.readFeatureCollectionMetadataFromNode = function (node) {\n  const result = {};\n  const value = readNonNegativeIntegerString(node.getAttribute('numberOfFeatures'));\n  result['numberOfFeatures'] = value;\n  return pushParseAndPop(\n  /** @type {module:ol/format/WFS~FeatureCollectionMetadata} */\n  result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\n\n\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\n\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\n\n\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n */\n\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\n\n\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Array.<string>|undefined} Insert results.\n */\n\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\n\n\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds')\n  }\n};\n/**\n * @param {Document} doc Document.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n */\n\nWFS.prototype.readTransactionResponseFromDocument = function (doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readTransactionResponseFromNode(n);\n    }\n  }\n\n  return undefined;\n};\n/**\n * @param {Node} node Node.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n */\n\n\nWFS.prototype.readTransactionResponseFromNode = function (node) {\n  return pushParseAndPop(\n  /** @type {module:ol/format/WFS~TransactionResponse} */\n  {}, TRANSACTION_RESPONSE_PARSERS, node, []);\n};\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\n\n\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\n\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', fid);\n  node.appendChild(filter);\n}\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\n\n\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':'; // The featureType already contains the prefix.\n\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\n\n\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\n\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n\n      if (value !== undefined) {\n        let name = keys[i];\n\n        if (value instanceof Geometry) {\n          name = geometryName;\n        }\n\n        values.push({\n          name: name,\n          value: value\n        });\n      }\n    }\n\n    pushSerializeAndPop(\n    /** @type {module:ol/xml~NodeStackItem} */\n    {\n      'gmlVersion': context['gmlVersion'],\n      node: node,\n      'hasZ': context['hasZ'],\n      'srsName': context['srsName']\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Property'), values, objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n\n    if (pair.value instanceof Geometry) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}}\n *     nativeElement The native element.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', nativeElement.safeToIgnore);\n  }\n\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\n\n\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {string} featureType Feature type.\n * @param {Array.<*>} objectStack Node stack.\n */\n\nfunction writeQuery(node, featureType, objectStack) {\n  const context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName; // If feature prefix is not defined, we must not use the default prefix.\n\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n\n  node.setAttribute('typeName', typeName);\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n\n  const item =\n  /** @type {module:ol/xml~NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory('PropertyName'), propertyNames, objectStack);\n  const filter = context['filter'];\n\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {\n    node: node\n  };\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Bbox} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Contains} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Intersects} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Within} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/During} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeDuringFilter(node, filter, objectStack) {\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n  node.appendChild(timePeriod);\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/LogicalNary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {\n    node: node\n  };\n  const conditions = filter.conditions;\n\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Not} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {\n    node: node\n  };\n  const condition = filter.condition;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/ComparisonBinary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsNull} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsBetween} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsLike} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\n\n\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\n\n\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @return {Node} Result.\n * @api\n */\n\n\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n/**\n * @param {Node} node Node.\n * @param {Array.<string>} featureTypes Feature types.\n * @param {Array.<*>} objectStack Node stack.\n */\n\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const item =\n  /** @type {module:ol/xml~NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory('Query'), featureTypes, objectStack);\n}\n/**\n * Encode format as WFS `GetFeature` and return the Node.\n *\n * @param {module:ol/format/WFS~WriteGetFeatureOptions} options Options.\n * @return {Node} Result.\n * @api\n */\n\n\nWFS.prototype.writeGetFeature = function (options) {\n  const node = createElementNS(WFSNS, 'GetFeature');\n  node.setAttribute('service', 'WFS');\n  node.setAttribute('version', '1.1.0');\n  let filter;\n\n  if (options) {\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', options.maxFeatures);\n    }\n\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', options.startIndex);\n    }\n\n    if (options.count !== undefined) {\n      node.setAttribute('count', options.count);\n    }\n\n    filter = options.filter;\n\n    if (options.bbox) {\n      assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n\n      const bbox = bboxFilter(\n      /** @type {string} */\n      options.geometryName, options.bbox, options.srsName);\n\n      if (filter) {\n        // if bbox and filter are both set, combine the two into a single filter\n        filter = andFilter(filter, bbox);\n      } else {\n        filter = bbox;\n      }\n    }\n  }\n\n  node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n  /** @type {module:ol/xml~NodeStackItem} */\n\n  const context = {\n    node: node,\n    'srsName': options.srsName,\n    'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n    'featurePrefix': options.featurePrefix,\n    'geometryName': options.geometryName,\n    'filter': filter,\n    'propertyNames': options.propertyNames ? options.propertyNames : []\n  };\n  assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` should be an Array\n\n  writeGetFeature(node,\n  /** @type {!Array.<string>} */\n  options.featureTypes, [context]);\n  return node;\n};\n/**\n * Encode format as WFS `Transaction` and return the Node.\n *\n * @param {Array.<module:ol/Feature>} inserts The features to insert.\n * @param {Array.<module:ol/Feature>} updates The features to update.\n * @param {Array.<module:ol/Feature>} deletes The features to delete.\n * @param {module:ol/format/WFS~WriteTransactionOptions} options Write options.\n * @return {Node} Result.\n * @api\n */\n\n\nWFS.prototype.writeTransaction = function (inserts, updates, deletes, options) {\n  const objectStack = [];\n  const node = createElementNS(WFSNS, 'Transaction');\n  const version = options.version ? options.version : DEFAULT_VERSION;\n  const gmlVersion = version === '1.0.0' ? 2 : 3;\n  node.setAttribute('service', 'WFS');\n  node.setAttribute('version', version);\n  let baseObj;\n  /** @type {module:ol/xml~NodeStackItem} */\n\n  let obj;\n\n  if (options) {\n    baseObj = options.gmlOptions ? options.gmlOptions : {};\n\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n  }\n\n  const schemaLocation = SCHEMA_LOCATIONS[version];\n  node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n  const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n\n  if (inserts) {\n    obj = {\n      node: node,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName\n    };\n    assign(obj, baseObj);\n    pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Insert'), inserts, objectStack);\n  }\n\n  if (updates) {\n    obj = {\n      node: node,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName\n    };\n    assign(obj, baseObj);\n    pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Update'), updates, objectStack);\n  }\n\n  if (deletes) {\n    pushSerializeAndPop({\n      node: node,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'srsName': options.srsName\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Delete'), deletes, objectStack);\n  }\n\n  if (options.nativeElements) {\n    pushSerializeAndPop({\n      node: node,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'srsName': options.srsName\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Native'), options.nativeElements, objectStack);\n  }\n\n  return node;\n};\n/**\n * Read the projection from a WFS source.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @return {?module:ol/proj/Projection} Projection.\n * @api\n */\n\n\nWFS.prototype.readProjection;\n/**\n * @inheritDoc\n */\n\nWFS.prototype.readProjectionFromDocument = function (doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readProjectionFromNode(n);\n    }\n  }\n\n  return null;\n};\n/**\n * @inheritDoc\n */\n\n\nWFS.prototype.readProjectionFromNode = function (node) {\n  if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n    node = node.firstElementChild.firstElementChild;\n\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {\n        const objectStack = [{}];\n        this.gmlFormat_.readGeometryElement(n, objectStack);\n        return getProjection(objectStack.pop().srsName);\n      }\n    }\n  }\n\n  return null;\n};\n\nexport default WFS;","map":null,"metadata":{},"sourceType":"module"}