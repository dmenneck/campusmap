{"ast":null,"code":"/**\n * @module ol/geom/MultiPoint\n */\nimport { inherits } from '../util.js';\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { deflateCoordinates } from '../geom/flat/deflate.js';\nimport { inflateCoordinates } from '../geom/flat/inflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @constructor\n * @extends {module:ol/geom/SimpleGeometry}\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @api\n */\n\nconst MultiPoint = function (coordinates, opt_layout) {\n  SimpleGeometry.call(this);\n  this.setCoordinates(coordinates, opt_layout);\n};\n\ninherits(MultiPoint, SimpleGeometry);\n/**\n * Append the passed point to this multipoint.\n * @param {module:ol/geom/Point} point Point.\n * @api\n */\n\nMultiPoint.prototype.appendPoint = function (point) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = point.getFlatCoordinates().slice();\n  } else {\n    extend(this.flatCoordinates, point.getFlatCoordinates());\n  }\n\n  this.changed();\n};\n/**\n * Make a complete copy of the geometry.\n * @return {!module:ol/geom/MultiPoint} Clone.\n * @override\n * @api\n */\n\n\nMultiPoint.prototype.clone = function () {\n  const multiPoint = new MultiPoint(null);\n  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return multiPoint;\n};\n/**\n * @inheritDoc\n */\n\n\nMultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n\n  const flatCoordinates = this.flatCoordinates;\n  const stride = this.stride;\n\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    const squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (let j = 0; j < stride; ++j) {\n        closestPoint[j] = flatCoordinates[i + j];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n};\n/**\n * Return the coordinates of the multipoint.\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\n * @override\n * @api\n */\n\n\nMultiPoint.prototype.getCoordinates = function () {\n  return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n/**\n * Return the point at the specified index.\n * @param {number} index Index.\n * @return {module:ol/geom/Point} Point.\n * @api\n */\n\n\nMultiPoint.prototype.getPoint = function (index) {\n  const n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n\n  if (index < 0 || n <= index) {\n    return null;\n  }\n\n  const point = new Point(null);\n  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride));\n  return point;\n};\n/**\n * Return the points of this multipoint.\n * @return {Array.<module:ol/geom/Point>} Points.\n * @api\n */\n\n\nMultiPoint.prototype.getPoints = function () {\n  const flatCoordinates = this.flatCoordinates;\n  const layout = this.layout;\n  const stride = this.stride;\n  /** @type {Array.<module:ol/geom/Point>} */\n\n  const points = [];\n\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    const point = new Point(null);\n    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));\n    points.push(point);\n  }\n\n  return points;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nMultiPoint.prototype.getType = function () {\n  return GeometryType.MULTI_POINT;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nMultiPoint.prototype.intersectsExtent = function (extent) {\n  const flatCoordinates = this.flatCoordinates;\n  const stride = this.stride;\n\n  for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n    const x = flatCoordinates[i];\n    const y = flatCoordinates[i + 1];\n\n    if (containsXY(extent, x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Set the coordinates of the multipoint.\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n\n\nMultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(GeometryLayout.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 1);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n/**\n * @param {module:ol/geom/GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n\n\nMultiPoint.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\n\nexport default MultiPoint;","map":null,"metadata":{},"sourceType":"module"}