{"ast":null,"code":"/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredSegmentDistance, squaredDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\n\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n\n\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n\n  var stack = [offset, end - stride];\n  var index = 0;\n\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n\n  for (var i$1 = 0; i$1 < n; ++i$1) {\n    if (markers[i$1]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride + 1];\n    }\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1]; // copy first point\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  } // snap the first coordinate (P1)\n\n\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride; // add the first coordinate to the output\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n\n  var x2, y2;\n\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride; // skip P3 if it is equal to P2\n\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    } // calculate the delta between P1 and P2\n\n\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n\n\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  } // add the last point (P2)\n\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}","map":{"version":3,"sources":["../../../../src/ol/geom/flat/simplify.js"],"names":["const","let","i"],"mappings":"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","sourcesContent":["/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredSegmentDistance, squaredDistance} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end,\n  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  const simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n    opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end,\n      stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates, offset, end, stride, squaredTolerance,\n    simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(\n        x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset,\n  ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n  simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates, offset, end, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates, offset, endss, stride, squaredTolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates, offset, ends, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride,\n  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if ((dx1 * dy2 == dy1 * dx2) &&\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates, offset, ends, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates, offset, end, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates, offset, endss, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates, offset, ends, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"]},"metadata":{},"sourceType":"module"}