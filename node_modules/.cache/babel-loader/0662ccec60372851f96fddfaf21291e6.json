{"ast":null,"code":"/**\n * @module ol/renderer/Layer\n */\nimport { getUid, inherits } from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport TileState from '../TileState.js';\nimport { listen } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { FALSE, UNDEFINED } from '../functions.js';\nimport SourceState from '../source/State.js';\n/**\n * @constructor\n * @extends {module:ol/Observable}\n * @param {module:ol/layer/Layer} layer Layer.\n * @struct\n */\n\nconst LayerRenderer = function (layer) {\n  Observable.call(this);\n  /**\n   * @private\n   * @type {module:ol/layer/Layer}\n   */\n\n  this.layer_ = layer;\n};\n\ninherits(LayerRenderer, Observable);\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}\n *     callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @return {T|undefined} Callback result.\n * @template S,T\n */\n\nLayerRenderer.prototype.forEachFeatureAtCoordinate = UNDEFINED;\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @return {boolean} Is there a feature at the given coordinate?\n */\n\nLayerRenderer.prototype.hasFeatureAtCoordinate = FALSE;\n/**\n * Create a function that adds loaded tiles to the tile lookup.\n * @param {module:ol/source/Tile} source Tile source.\n * @param {module:ol/proj/Projection} projection Projection of the tiles.\n * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.\n * @return {function(number, module:ol/TileRange):boolean} A function that can be\n *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n * @protected\n */\n\nLayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n  return (\n    /**\n     * @param {number} zoom Zoom level.\n     * @param {module:ol/TileRange} tileRange Tile range.\n     * @return {boolean} The tile range is fully loaded.\n     */\n    function (zoom, tileRange) {\n      function callback(tile) {\n        if (!tiles[zoom]) {\n          tiles[zoom] = {};\n        }\n\n        tiles[zoom][tile.tileCoord.toString()] = tile;\n      }\n\n      return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n    }\n  );\n};\n/**\n * @return {module:ol/layer/Layer} Layer.\n */\n\n\nLayerRenderer.prototype.getLayer = function () {\n  return this.layer_;\n};\n/**\n * Handle changes in image state.\n * @param {module:ol/events/Event} event Image change event.\n * @private\n */\n\n\nLayerRenderer.prototype.handleImageChange_ = function (event) {\n  const image =\n  /** @type {module:ol/Image} */\n  event.target;\n\n  if (image.getState() === ImageState.LOADED) {\n    this.renderIfReadyAndVisible();\n  }\n};\n/**\n * Load the image if not already loaded, and register the image change\n * listener if needed.\n * @param {module:ol/ImageBase} image Image.\n * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n * @protected\n */\n\n\nLayerRenderer.prototype.loadImage = function (image) {\n  let imageState = image.getState();\n\n  if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n    listen(image, EventType.CHANGE, this.handleImageChange_, this);\n  }\n\n  if (imageState == ImageState.IDLE) {\n    image.load();\n    imageState = image.getState();\n  }\n\n  return imageState == ImageState.LOADED;\n};\n/**\n * @protected\n */\n\n\nLayerRenderer.prototype.renderIfReadyAndVisible = function () {\n  const layer = this.getLayer();\n\n  if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n    this.changed();\n  }\n};\n/**\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @param {module:ol/source/Tile} tileSource Tile source.\n * @protected\n */\n\n\nLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n  if (tileSource.canExpireCache()) {\n    /**\n     * @param {module:ol/source/Tile} tileSource Tile source.\n     * @param {module:ol/PluggableMap} map Map.\n     * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (tileSource, map, frameState) {\n      const tileSourceKey = getUid(tileSource).toString();\n\n      if (tileSourceKey in frameState.usedTiles) {\n        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n      }\n    }.bind(null, tileSource);\n\n    frameState.postRenderFunctions.push(\n    /** @type {module:ol/PluggableMap~PostRenderFunction} */\n    postRenderFunction);\n  }\n};\n/**\n * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.\n * @param {module:ol/source/Tile} tileSource Tile source.\n * @param {number} z Z.\n * @param {module:ol/TileRange} tileRange Tile range.\n * @protected\n */\n\n\nLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {\n  // FIXME should we use tilesToDrawByZ instead?\n  const tileSourceKey = getUid(tileSource).toString();\n  const zKey = z.toString();\n\n  if (tileSourceKey in usedTiles) {\n    if (zKey in usedTiles[tileSourceKey]) {\n      usedTiles[tileSourceKey][zKey].extend(tileRange);\n    } else {\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  } else {\n    usedTiles[tileSourceKey] = {};\n    usedTiles[tileSourceKey][zKey] = tileRange;\n  }\n};\n/**\n * Manage tile pyramid.\n * This function performs a number of functions related to the tiles at the\n * current zoom and lower zoom levels:\n * - registers idle tiles in frameState.wantedTiles so that they are not\n *   discarded by the tile queue\n * - enqueues missing tiles\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @param {module:ol/source/Tile} tileSource Tile source.\n * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/proj/Projection} projection Projection.\n * @param {module:ol/extent~Extent} extent Extent.\n * @param {number} currentZ Current Z.\n * @param {number} preload Load low resolution tiles up to 'preload' levels.\n * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.\n * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n * @protected\n * @template T\n */\n\n\nLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n  const tileSourceKey = getUid(tileSource).toString();\n\n  if (!(tileSourceKey in frameState.wantedTiles)) {\n    frameState.wantedTiles[tileSourceKey] = {};\n  }\n\n  const wantedTiles = frameState.wantedTiles[tileSourceKey];\n  const tileQueue = frameState.tileQueue;\n  const minZoom = tileGrid.getMinZoom();\n  let tile, tileRange, tileResolution, x, y, z;\n\n  for (z = minZoom; z <= currentZ; ++z) {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n    tileResolution = tileGrid.getResolution(z);\n\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (currentZ - z <= preload) {\n          tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n          if (tile.getState() == TileState.IDLE) {\n            wantedTiles[tile.getKey()] = true;\n\n            if (!tileQueue.isKeyQueued(tile.getKey())) {\n              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n            }\n          }\n\n          if (opt_tileCallback !== undefined) {\n            opt_tileCallback.call(opt_this, tile);\n          }\n        } else {\n          tileSource.useTile(z, x, y, projection);\n        }\n      }\n    }\n  }\n};\n\nexport default LayerRenderer;","map":null,"metadata":{},"sourceType":"module"}