{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar beanStub_1 = require(\"../../context/beanStub\");\n\nvar rowNodeBlock_1 = require(\"./rowNodeBlock\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar RowNodeCache =\n/** @class */\nfunction (_super) {\n  __extends(RowNodeCache, _super);\n\n  function RowNodeCache(cacheParams) {\n    var _this = _super.call(this) || this;\n\n    _this.maxRowFound = false;\n    _this.blocks = {};\n    _this.blockCount = 0;\n    _this.virtualRowCount = cacheParams.initialRowCount;\n    _this.cacheParams = cacheParams;\n    return _this;\n  }\n\n  RowNodeCache.prototype.destroy = function () {\n    var _this = this;\n\n    _super.prototype.destroy.call(this);\n\n    this.forEachBlockInOrder(function (block) {\n      return _this.destroyBlock(block);\n    });\n  };\n\n  RowNodeCache.prototype.init = function () {\n    var _this = this;\n\n    this.active = true;\n    this.addDestroyFunc(function () {\n      return _this.active = false;\n    });\n  };\n\n  RowNodeCache.prototype.isActive = function () {\n    return this.active;\n  };\n\n  RowNodeCache.prototype.getVirtualRowCount = function () {\n    return this.virtualRowCount;\n  };\n\n  RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {\n    this.virtualRowCount = virtualRowCount;\n  };\n\n  RowNodeCache.prototype.isMaxRowFound = function () {\n    return this.maxRowFound;\n  }; // listener on EVENT_LOAD_COMPLETE\n\n\n  RowNodeCache.prototype.onPageLoaded = function (event) {\n    this.cacheParams.rowNodeBlockLoader.loadComplete();\n    this.checkBlockToLoad(); // if we are not active, then we ignore all events, otherwise we could end up getting the\n    // grid to refresh even though we are no longer the active cache\n\n    if (!this.isActive()) {\n      return;\n    }\n\n    this.logger.log(\"onPageLoaded: page = \" + event.page.getBlockNumber() + \", lastRow = \" + event.lastRow);\n\n    if (event.success) {\n      this.checkVirtualRowCount(event.page, event.lastRow);\n    }\n  };\n\n  RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n    var _this = this; // put all candidate blocks into a list for sorting\n\n\n    var blocksForPurging = [];\n    this.forEachBlockInOrder(function (block) {\n      // we exclude checking for the page just created, as this has yet to be accessed and hence\n      // the lastAccessed stamp will not be updated for the first time yet\n      if (block === blockToExclude) {\n        return;\n      }\n\n      blocksForPurging.push(block);\n    }); // note: need to verify that this sorts items in the right order\n\n    blocksForPurging.sort(function (a, b) {\n      return b.getLastAccessed() - a.getLastAccessed();\n    }); // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n    // in other words, after the splice operation below, we have taken out the blocks\n    // we want to keep, which means we are left with blocks that we can potentially purge\n\n    var maxBlocksProvided = this.cacheParams.maxBlocksInCache > 0;\n    var blocksToKeep = maxBlocksProvided ? this.cacheParams.maxBlocksInCache - 1 : null;\n    var emptyBlocksToKeep = RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n    blocksForPurging.forEach(function (block, index) {\n      var purgeBecauseBlockEmpty = block.getState() === rowNodeBlock_1.RowNodeBlock.STATE_DIRTY && index >= emptyBlocksToKeep;\n      var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n\n      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n        // we never purge blocks if they are open, as purging them would mess up with\n        // our indexes, it would be very messy to restore the purged block to it's\n        // previous state if it had open children (and what if open children of open\n        // children, jeeeesus, just thinking about it freaks me out) so best is have a\n        // rule, if block is open, we never purge.\n        if (block.isAnyNodeOpen(_this.virtualRowCount)) {\n          return;\n        } // at this point, block is not needed, and no open nodes, so burn baby burn\n\n\n        _this.removeBlockFromCache(block);\n      }\n    });\n  };\n\n  RowNodeCache.prototype.postCreateBlock = function (newBlock) {\n    newBlock.addEventListener(rowNodeBlock_1.RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\n    this.setBlock(newBlock.getBlockNumber(), newBlock);\n    this.purgeBlocksIfNeeded(newBlock);\n    this.checkBlockToLoad();\n  };\n\n  RowNodeCache.prototype.removeBlockFromCache = function (blockToRemove) {\n    if (!blockToRemove) {\n      return;\n    }\n\n    this.destroyBlock(blockToRemove); // we do not want to remove the 'loaded' event listener, as the\n    // concurrent loads count needs to be updated when the load is complete\n    // if the purged page is in loading state\n  }; // gets called after: 1) block loaded 2) block created 3) cache refresh\n\n\n  RowNodeCache.prototype.checkBlockToLoad = function () {\n    this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\n  };\n\n  RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {\n    // if client provided a last row, we always use it, as it could change between server calls\n    // if user deleted data and then called refresh on the grid.\n    if (typeof lastRow === 'number' && lastRow >= 0) {\n      this.virtualRowCount = lastRow;\n      this.maxRowFound = true;\n      this.onCacheUpdated();\n    } else if (!this.maxRowFound) {\n      // otherwise, see if we need to add some virtual rows\n      var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\n      var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\n\n      if (this.virtualRowCount < lastRowIndexPlusOverflow) {\n        this.virtualRowCount = lastRowIndexPlusOverflow;\n        this.onCacheUpdated();\n      } else if (this.cacheParams.dynamicRowHeight) {\n        // the only other time is if dynamic row height, as loading rows\n        // will change the height of the block, given the height of the rows\n        // is only known after the row is loaded.\n        this.onCacheUpdated();\n      }\n    }\n  };\n\n  RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\n    this.virtualRowCount = rowCount; // if undefined is passed, we do not set this value, if one of {true,false}\n    // is passed, we do set the value.\n\n    if (utils_1._.exists(maxRowFound)) {\n      this.maxRowFound = maxRowFound;\n    } // if we are still searching, then the row count must not end at the end\n    // of a particular page, otherwise the searching will not pop into the\n    // next page\n\n\n    if (!this.maxRowFound) {\n      if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\n        this.virtualRowCount++;\n      }\n    }\n\n    this.onCacheUpdated();\n  };\n\n  RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {\n    var _this = this;\n\n    if (sequence === void 0) {\n      sequence = new utils_1.NumberSequence();\n    }\n\n    this.forEachBlockInOrder(function (block) {\n      block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);\n    });\n  };\n\n  RowNodeCache.prototype.forEachBlockInOrder = function (callback) {\n    var ids = this.getBlockIdsSorted();\n    this.forEachBlockId(ids, callback);\n  };\n\n  RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {\n    var ids = this.getBlockIdsSorted().reverse();\n    this.forEachBlockId(ids, callback);\n  };\n\n  RowNodeCache.prototype.forEachBlockId = function (ids, callback) {\n    var _this = this;\n\n    ids.forEach(function (id) {\n      var block = _this.blocks[id];\n      callback(block, id);\n    });\n  };\n\n  RowNodeCache.prototype.getBlockIdsSorted = function () {\n    // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n    var numberComparator = function (a, b) {\n      return a - b;\n    }; // default comparator for array is string comparison\n\n\n    var blockIds = Object.keys(this.blocks).map(function (idStr) {\n      return parseInt(idStr, 10);\n    }).sort(numberComparator);\n    return blockIds;\n  };\n\n  RowNodeCache.prototype.getBlock = function (blockId) {\n    return this.blocks[blockId];\n  };\n\n  RowNodeCache.prototype.setBlock = function (id, block) {\n    this.blocks[id] = block;\n    this.blockCount++;\n    this.cacheParams.rowNodeBlockLoader.addBlock(block);\n  };\n\n  RowNodeCache.prototype.destroyBlock = function (block) {\n    delete this.blocks[block.getBlockNumber()];\n    block.destroy();\n    this.blockCount--;\n    this.cacheParams.rowNodeBlockLoader.removeBlock(block);\n  }; // gets called 1) row count changed 2) cache purged 3) items inserted\n\n\n  RowNodeCache.prototype.onCacheUpdated = function () {\n    if (this.isActive()) {\n      // this results in both row models (infinite and server side) firing ModelUpdated,\n      // however server side row model also updates the row indexes first\n      var event_1 = {\n        type: RowNodeCache.EVENT_CACHE_UPDATED\n      };\n      this.dispatchEvent(event_1);\n    }\n  };\n\n  RowNodeCache.prototype.purgeCache = function () {\n    var _this = this;\n\n    this.forEachBlockInOrder(function (block) {\n      return _this.removeBlockFromCache(block);\n    }); // re-initialise cache - this ensures a cache with no rows can reload when purged!\n\n    this.virtualRowCount = this.cacheParams.initialRowCount;\n    this.maxRowFound = false;\n    this.onCacheUpdated();\n  };\n\n  RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n    var _this = this;\n\n    var result = [];\n    var lastBlockId = -1;\n    var inActiveRange = false;\n    var numberSequence = new utils_1.NumberSequence(); // if only one node passed, we start the selection at the top\n\n    if (utils_1._.missing(firstInRange)) {\n      inActiveRange = true;\n    }\n\n    var foundGapInSelection = false;\n    this.forEachBlockInOrder(function (block, id) {\n      if (foundGapInSelection) {\n        return;\n      }\n\n      if (inActiveRange && lastBlockId + 1 !== id) {\n        foundGapInSelection = true;\n        return;\n      }\n\n      lastBlockId = id;\n      block.forEachNodeShallow(function (rowNode) {\n        var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n\n        if (inActiveRange || hitFirstOrLast) {\n          result.push(rowNode);\n        }\n\n        if (hitFirstOrLast) {\n          inActiveRange = !inActiveRange;\n        }\n      }, numberSequence, _this.virtualRowCount);\n    }); // inActiveRange will be still true if we never hit the second rowNode\n\n    var invalidRange = foundGapInSelection || inActiveRange;\n    return invalidRange ? [] : result;\n  };\n\n  RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated'; // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n  // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n  // scrolled over are not needed to be loaded.\n\n  RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n  return RowNodeCache;\n}(beanStub_1.BeanStub);\n\nexports.RowNodeCache = RowNodeCache;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/rowModels/cache/rowNodeCache.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","beanStub_1","require","rowNodeBlock_1","utils_1","RowNodeCache","_super","cacheParams","_this","call","maxRowFound","blocks","blockCount","virtualRowCount","initialRowCount","destroy","forEachBlockInOrder","block","destroyBlock","init","active","addDestroyFunc","isActive","getVirtualRowCount","hack_setVirtualRowCount","isMaxRowFound","onPageLoaded","event","rowNodeBlockLoader","loadComplete","checkBlockToLoad","logger","log","page","getBlockNumber","lastRow","success","checkVirtualRowCount","purgeBlocksIfNeeded","blockToExclude","blocksForPurging","push","sort","a","getLastAccessed","maxBlocksProvided","maxBlocksInCache","blocksToKeep","emptyBlocksToKeep","MAX_EMPTY_BLOCKS_TO_KEEP","forEach","index","purgeBecauseBlockEmpty","getState","RowNodeBlock","STATE_DIRTY","purgeBecauseCacheFull","isAnyNodeOpen","removeBlockFromCache","postCreateBlock","newBlock","addEventListener","EVENT_LOAD_COMPLETE","bind","setBlock","blockToRemove","onCacheUpdated","lastRowIndex","blockSize","lastRowIndexPlusOverflow","overflowSize","dynamicRowHeight","setVirtualRowCount","rowCount","_","exists","forEachNodeDeep","callback","sequence","NumberSequence","ids","getBlockIdsSorted","forEachBlockId","forEachBlockInReverseOrder","reverse","id","numberComparator","blockIds","keys","map","idStr","parseInt","getBlock","blockId","addBlock","removeBlock","event_1","type","EVENT_CACHE_UPDATED","dispatchEvent","purgeCache","getRowNodesInRange","firstInRange","lastInRange","result","lastBlockId","inActiveRange","numberSequence","missing","foundGapInSelection","forEachNodeShallow","rowNode","hitFirstOrLast","invalidRange","BeanStub"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar beanStub_1 = require(\"../../context/beanStub\");\nvar rowNodeBlock_1 = require(\"./rowNodeBlock\");\nvar utils_1 = require(\"../../utils\");\nvar RowNodeCache = /** @class */ (function (_super) {\n    __extends(RowNodeCache, _super);\n    function RowNodeCache(cacheParams) {\n        var _this = _super.call(this) || this;\n        _this.maxRowFound = false;\n        _this.blocks = {};\n        _this.blockCount = 0;\n        _this.virtualRowCount = cacheParams.initialRowCount;\n        _this.cacheParams = cacheParams;\n        return _this;\n    }\n    RowNodeCache.prototype.destroy = function () {\n        var _this = this;\n        _super.prototype.destroy.call(this);\n        this.forEachBlockInOrder(function (block) { return _this.destroyBlock(block); });\n    };\n    RowNodeCache.prototype.init = function () {\n        var _this = this;\n        this.active = true;\n        this.addDestroyFunc(function () { return _this.active = false; });\n    };\n    RowNodeCache.prototype.isActive = function () {\n        return this.active;\n    };\n    RowNodeCache.prototype.getVirtualRowCount = function () {\n        return this.virtualRowCount;\n    };\n    RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {\n        this.virtualRowCount = virtualRowCount;\n    };\n    RowNodeCache.prototype.isMaxRowFound = function () {\n        return this.maxRowFound;\n    };\n    // listener on EVENT_LOAD_COMPLETE\n    RowNodeCache.prototype.onPageLoaded = function (event) {\n        this.cacheParams.rowNodeBlockLoader.loadComplete();\n        this.checkBlockToLoad();\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isActive()) {\n            return;\n        }\n        this.logger.log(\"onPageLoaded: page = \" + event.page.getBlockNumber() + \", lastRow = \" + event.lastRow);\n        if (event.success) {\n            this.checkVirtualRowCount(event.page, event.lastRow);\n        }\n    };\n    RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n        var _this = this;\n        // put all candidate blocks into a list for sorting\n        var blocksForPurging = [];\n        this.forEachBlockInOrder(function (block) {\n            // we exclude checking for the page just created, as this has yet to be accessed and hence\n            // the lastAccessed stamp will not be updated for the first time yet\n            if (block === blockToExclude) {\n                return;\n            }\n            blocksForPurging.push(block);\n        });\n        // note: need to verify that this sorts items in the right order\n        blocksForPurging.sort(function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); });\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        var maxBlocksProvided = this.cacheParams.maxBlocksInCache > 0;\n        var blocksToKeep = maxBlocksProvided ? this.cacheParams.maxBlocksInCache - 1 : null;\n        var emptyBlocksToKeep = RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n        blocksForPurging.forEach(function (block, index) {\n            var purgeBecauseBlockEmpty = block.getState() === rowNodeBlock_1.RowNodeBlock.STATE_DIRTY && index >= emptyBlocksToKeep;\n            var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n                // we never purge blocks if they are open, as purging them would mess up with\n                // our indexes, it would be very messy to restore the purged block to it's\n                // previous state if it had open children (and what if open children of open\n                // children, jeeeesus, just thinking about it freaks me out) so best is have a\n                // rule, if block is open, we never purge.\n                if (block.isAnyNodeOpen(_this.virtualRowCount)) {\n                    return;\n                }\n                // at this point, block is not needed, and no open nodes, so burn baby burn\n                _this.removeBlockFromCache(block);\n            }\n        });\n    };\n    RowNodeCache.prototype.postCreateBlock = function (newBlock) {\n        newBlock.addEventListener(rowNodeBlock_1.RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\n        this.setBlock(newBlock.getBlockNumber(), newBlock);\n        this.purgeBlocksIfNeeded(newBlock);\n        this.checkBlockToLoad();\n    };\n    RowNodeCache.prototype.removeBlockFromCache = function (blockToRemove) {\n        if (!blockToRemove) {\n            return;\n        }\n        this.destroyBlock(blockToRemove);\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    };\n    // gets called after: 1) block loaded 2) block created 3) cache refresh\n    RowNodeCache.prototype.checkBlockToLoad = function () {\n        this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\n    };\n    RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.virtualRowCount = lastRow;\n            this.maxRowFound = true;\n            this.onCacheUpdated();\n        }\n        else if (!this.maxRowFound) {\n            // otherwise, see if we need to add some virtual rows\n            var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\n            var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\n            if (this.virtualRowCount < lastRowIndexPlusOverflow) {\n                this.virtualRowCount = lastRowIndexPlusOverflow;\n                this.onCacheUpdated();\n            }\n            else if (this.cacheParams.dynamicRowHeight) {\n                // the only other time is if dynamic row height, as loading rows\n                // will change the height of the block, given the height of the rows\n                // is only known after the row is loaded.\n                this.onCacheUpdated();\n            }\n        }\n    };\n    RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\n        this.virtualRowCount = rowCount;\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (utils_1._.exists(maxRowFound)) {\n            this.maxRowFound = maxRowFound;\n        }\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.maxRowFound) {\n            if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\n                this.virtualRowCount++;\n            }\n        }\n        this.onCacheUpdated();\n    };\n    RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {\n        var _this = this;\n        if (sequence === void 0) { sequence = new utils_1.NumberSequence(); }\n        this.forEachBlockInOrder(function (block) {\n            block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);\n        });\n    };\n    RowNodeCache.prototype.forEachBlockInOrder = function (callback) {\n        var ids = this.getBlockIdsSorted();\n        this.forEachBlockId(ids, callback);\n    };\n    RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {\n        var ids = this.getBlockIdsSorted().reverse();\n        this.forEachBlockId(ids, callback);\n    };\n    RowNodeCache.prototype.forEachBlockId = function (ids, callback) {\n        var _this = this;\n        ids.forEach(function (id) {\n            var block = _this.blocks[id];\n            callback(block, id);\n        });\n    };\n    RowNodeCache.prototype.getBlockIdsSorted = function () {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        var numberComparator = function (a, b) { return a - b; }; // default comparator for array is string comparison\n        var blockIds = Object.keys(this.blocks).map(function (idStr) { return parseInt(idStr, 10); }).sort(numberComparator);\n        return blockIds;\n    };\n    RowNodeCache.prototype.getBlock = function (blockId) {\n        return this.blocks[blockId];\n    };\n    RowNodeCache.prototype.setBlock = function (id, block) {\n        this.blocks[id] = block;\n        this.blockCount++;\n        this.cacheParams.rowNodeBlockLoader.addBlock(block);\n    };\n    RowNodeCache.prototype.destroyBlock = function (block) {\n        delete this.blocks[block.getBlockNumber()];\n        block.destroy();\n        this.blockCount--;\n        this.cacheParams.rowNodeBlockLoader.removeBlock(block);\n    };\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    RowNodeCache.prototype.onCacheUpdated = function () {\n        if (this.isActive()) {\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            var event_1 = {\n                type: RowNodeCache.EVENT_CACHE_UPDATED\n            };\n            this.dispatchEvent(event_1);\n        }\n    };\n    RowNodeCache.prototype.purgeCache = function () {\n        var _this = this;\n        this.forEachBlockInOrder(function (block) { return _this.removeBlockFromCache(block); });\n        // re-initialise cache - this ensures a cache with no rows can reload when purged!\n        this.virtualRowCount = this.cacheParams.initialRowCount;\n        this.maxRowFound = false;\n        this.onCacheUpdated();\n    };\n    RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n        var _this = this;\n        var result = [];\n        var lastBlockId = -1;\n        var inActiveRange = false;\n        var numberSequence = new utils_1.NumberSequence();\n        // if only one node passed, we start the selection at the top\n        if (utils_1._.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n        var foundGapInSelection = false;\n        this.forEachBlockInOrder(function (block, id) {\n            if (foundGapInSelection) {\n                return;\n            }\n            if (inActiveRange && (lastBlockId + 1 !== id)) {\n                foundGapInSelection = true;\n                return;\n            }\n            lastBlockId = id;\n            block.forEachNodeShallow(function (rowNode) {\n                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n            }, numberSequence, _this.virtualRowCount);\n        });\n        // inActiveRange will be still true if we never hit the second rowNode\n        var invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    };\n    RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated';\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n    return RowNodeCache;\n}(beanStub_1.BeanStub));\nexports.RowNodeCache = RowNodeCache;\n"]},"metadata":{},"sourceType":"script"}