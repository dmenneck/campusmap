{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar column_1 = require(\"../entities/column\");\n\nvar constants_1 = require(\"../constants\");\n\nvar events_1 = require(\"../events\");\n\nvar component_1 = require(\"../widgets/component\");\n\nvar checkboxSelectionComponent_1 = require(\"./checkboxSelectionComponent\");\n\nvar iRangeController_1 = require(\"../interfaces/iRangeController\");\n\nvar rowDragComp_1 = require(\"./rowDragComp\");\n\nvar popupEditorWrapper_1 = require(\"./cellEditors/popupEditorWrapper\");\n\nvar utils_1 = require(\"../utils\");\n\nvar dndSourceComp_1 = require(\"./dndSourceComp\");\n\nvar CellComp =\n/** @class */\nfunction (_super) {\n  __extends(CellComp, _super);\n\n  function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell, printLayout) {\n    var _this = _super.call(this) || this;\n\n    _this.editingCell = false;\n    _this.suppressRefreshCell = false;\n    _this.scope = null; // every time we go into edit mode, or back again, this gets incremented.\n    // it's the components way of dealing with the async nature of framework components,\n    // so if a framework component takes a while to be created, we know if the object\n    // is still relevant when creating is finished. eg we could click edit / un-edit 20\n    // times before the first React edit component comes back - we should discard\n    // the first 19.\n\n    _this.cellEditorVersion = 0;\n    _this.cellRendererVersion = 0;\n    _this.scope = scope;\n    _this.beans = beans;\n    _this.column = column;\n    _this.rowNode = rowNode;\n    _this.rowComp = rowComp;\n    _this.autoHeightCell = autoHeightCell;\n    _this.printLayout = printLayout;\n\n    _this.createGridCellVo();\n\n    _this.rangeSelectionEnabled = beans.gridOptionsWrapper.isEnableRangeSelection();\n    _this.cellFocused = _this.beans.focusedCellController.isCellFocused(_this.cellPosition);\n    _this.firstRightPinned = _this.column.isFirstRightPinned();\n    _this.lastLeftPinned = _this.column.isLastLeftPinned();\n\n    if (_this.rangeSelectionEnabled) {\n      var rangeController = _this.beans.rangeController;\n      _this.rangeCount = rangeController.getCellRangeCount(_this.cellPosition);\n\n      if (_this.rangeCount) {\n        _this.hasChartRange = rangeController.getCellRanges().every(function (range) {\n          return utils_1._.exists(range.type);\n        });\n      }\n    }\n\n    _this.getValueAndFormat();\n\n    _this.setUsingWrapper();\n\n    _this.chooseCellRenderer();\n\n    _this.setupColSpan();\n\n    _this.rowSpan = _this.column.getRowSpan(_this.rowNode);\n    return _this;\n  }\n\n  CellComp.prototype.getCreateTemplate = function () {\n    var unselectable = !this.beans.gridOptionsWrapper.isEnableCellTextSelection() ? 'unselectable=\"on\"' : '';\n    var templateParts = [];\n    var col = this.column;\n    var width = this.getCellWidth();\n    var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n    var valueToRender = this.getInitialValueToRender();\n    var valueSanitised = utils_1._.get(this.column, 'colDef.template', null) ? valueToRender : utils_1._.escape(valueToRender);\n    this.tooltip = this.getToolTip();\n\n    var tooltipSanitised = utils_1._.escape(this.tooltip);\n\n    var colIdSanitised = utils_1._.escape(col.getId());\n\n    var wrapperStartTemplate = '';\n    var wrapperEndTemplate = '';\n    var stylesFromColDef = this.preProcessStylesFromColDef();\n    var cssClasses = this.getInitialCssClasses();\n    var stylesForRowSpanning = this.getStylesForRowSpanning();\n\n    if (this.usingWrapper) {\n      wrapperStartTemplate = \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\"><span ref=\\\"eCellValue\\\" class=\\\"ag-cell-value\\\" \" + unselectable + \">\";\n      wrapperEndTemplate = '</span></div>';\n    }\n\n    templateParts.push(\"<div\");\n    templateParts.push(\" tabindex=\\\"-1\\\"\");\n    templateParts.push(\" \" + unselectable); // THIS IS FOR IE ONLY so text selection doesn't bubble outside of the grid\n\n    templateParts.push(\" role=\\\"gridcell\\\"\");\n    templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\n    templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\n    templateParts.push(\" class=\\\"\" + cssClasses.join(' ') + \"\\\"\");\n\n    if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips() && utils_1._.exists(tooltipSanitised)) {\n      templateParts.push(\"title=\\\"\" + tooltipSanitised + \"\\\"\");\n    }\n\n    templateParts.push(\" style=\\\"width: \" + width + \"px; left: \" + left + \"px; \" + stylesFromColDef + \" \" + stylesForRowSpanning + \"\\\" >\");\n    templateParts.push(wrapperStartTemplate);\n\n    if (utils_1._.exists(valueSanitised, true)) {\n      templateParts.push(valueSanitised);\n    }\n\n    templateParts.push(wrapperEndTemplate);\n    templateParts.push(\"</div>\");\n    return templateParts.join('');\n  };\n\n  CellComp.prototype.getStylesForRowSpanning = function () {\n    if (this.rowSpan === 1) {\n      return '';\n    }\n\n    var singleRowHeight = this.beans.gridOptionsWrapper.getRowHeightAsNumber();\n    var totalRowHeight = singleRowHeight * this.rowSpan;\n    return \"height: \" + totalRowHeight + \"px; z-index: 1;\";\n  };\n\n  CellComp.prototype.afterAttached = function () {\n    var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\n    var eGui = this.eParentRow.querySelector(querySelector);\n    this.setGui(eGui); // all of these have dependencies on the eGui, so only do them after eGui is set\n\n    this.addDomData();\n    this.populateTemplate();\n    this.createCellRendererInstance(true);\n    this.angular1Compile(); // if not doing enterprise, then range selection service would be missing\n    // so need to check before trying to use it\n\n    if (this.rangeSelectionEnabled) {\n      if (this.shouldHaveSelectionHandle()) {\n        this.addSelectionHandle();\n      }\n    }\n\n    if (utils_1._.exists(this.tooltip) && !this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n      this.beans.tooltipManager.registerTooltip(this);\n    }\n  };\n\n  CellComp.prototype.onColumnHover = function () {\n    var isHovered = this.beans.columnHoverService.isHovered(this.column);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\n  };\n\n  CellComp.prototype.onCellChanged = function (event) {\n    var eventImpactsThisCell = event.column === this.column;\n\n    if (eventImpactsThisCell) {\n      this.refreshCell({});\n    }\n  };\n\n  CellComp.prototype.getCellLeft = function () {\n    var mostLeftCol;\n\n    if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n      mostLeftCol = utils_1._.last(this.colsSpanning);\n    } else {\n      mostLeftCol = this.column;\n    }\n\n    return mostLeftCol.getLeft();\n  };\n\n  CellComp.prototype.getCellWidth = function () {\n    if (!this.colsSpanning) {\n      return this.column.getActualWidth();\n    }\n\n    var result = 0;\n    this.colsSpanning.forEach(function (col) {\n      return result += col.getActualWidth();\n    });\n    return result;\n  };\n\n  CellComp.prototype.onFlashCells = function (event) {\n    var cellId = this.beans.cellPositionUtils.createId(this.cellPosition);\n    var shouldFlash = event.cells[cellId];\n\n    if (shouldFlash) {\n      this.animateCell('highlight');\n    }\n  };\n\n  CellComp.prototype.setupColSpan = function () {\n    // if no col span is active, then we don't set it up, as it would be wasteful of CPU\n    if (utils_1._.missing(this.getComponentHolder().colSpan)) {\n      return;\n    } // because we are col spanning, a reorder of the cols can change what cols we are spanning over\n\n\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)); // because we are spanning over multiple cols, we check for width any time any cols width changes.\n    // this is expensive - really we should be explicitly checking only the cols we are spanning over\n    // instead of every col, however it would be tricky code to track the cols we are spanning over, so\n    // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.\n\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n    this.colsSpanning = this.getColSpanningList();\n  };\n\n  CellComp.prototype.getColSpanningList = function () {\n    var colSpan = this.column.getColSpan(this.rowNode);\n    var colsSpanning = []; // if just one col, the col span is just the column we are in\n\n    if (colSpan === 1) {\n      colsSpanning.push(this.column);\n    } else {\n      var pointer = this.column;\n      var pinned = this.column.getPinned();\n\n      for (var i = 0; pointer && i < colSpan; i++) {\n        colsSpanning.push(pointer);\n        pointer = this.beans.columnController.getDisplayedColAfter(pointer);\n\n        if (!pointer || utils_1._.missing(pointer)) {\n          break;\n        } // we do not allow col spanning to span outside of pinned areas\n\n\n        if (pinned !== pointer.getPinned()) {\n          break;\n        }\n      }\n    }\n\n    return colsSpanning;\n  };\n\n  CellComp.prototype.onDisplayColumnsChanged = function () {\n    var colsSpanning = this.getColSpanningList();\n\n    if (!utils_1._.compareArrays(this.colsSpanning, colsSpanning)) {\n      this.colsSpanning = colsSpanning;\n      this.onWidthChanged();\n      this.onLeftChanged(); // left changes when doing RTL\n    }\n  };\n\n  CellComp.prototype.getInitialCssClasses = function () {\n    var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"]; // if we are putting the cell into a dummy container, to work out it's height,\n    // then we don't put the height css in, as we want cell to fit height in that case.\n\n    if (!this.autoHeightCell) {\n      cssClasses.push('ag-cell-with-height');\n    }\n\n    var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n    if (doingFocusCss && this.cellFocused) {\n      // otherwise the class depends on the focus state\n      cssClasses.push('ag-cell-focus');\n    }\n\n    if (this.firstRightPinned) {\n      cssClasses.push('ag-cell-first-right-pinned');\n    }\n\n    if (this.lastLeftPinned) {\n      cssClasses.push('ag-cell-last-left-pinned');\n    }\n\n    if (this.beans.columnHoverService.isHovered(this.column)) {\n      cssClasses.push('ag-column-hover');\n    }\n\n    utils_1._.pushAll(cssClasses, this.preProcessClassesFromColDef());\n\n    utils_1._.pushAll(cssClasses, this.preProcessCellClassRules());\n\n    utils_1._.pushAll(cssClasses, this.getInitialRangeClasses()); // if using the wrapper, this class goes on the wrapper instead\n\n\n    if (!this.usingWrapper) {\n      cssClasses.push('ag-cell-value');\n    }\n\n    return cssClasses;\n  };\n\n  CellComp.prototype.getInitialValueToRender = function () {\n    // if using a cellRenderer, then render the html from the cell renderer if it exists\n    if (this.usingCellRenderer) {\n      if (typeof this.cellRendererGui === 'string') {\n        return this.cellRendererGui;\n      } else {\n        return '';\n      }\n    }\n\n    var colDef = this.getComponentHolder();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      return colDef.template;\n    } else if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n\n      if (template) {\n        return template;\n      } else {\n        return '';\n      }\n    } else {\n      return this.getValueToUse();\n    }\n  };\n\n  CellComp.prototype.getRenderedRow = function () {\n    return this.rowComp;\n  };\n\n  CellComp.prototype.isSuppressNavigable = function () {\n    return this.column.isSuppressNavigable(this.rowNode);\n  };\n\n  CellComp.prototype.getCellRenderer = function () {\n    return this.cellRenderer;\n  };\n\n  CellComp.prototype.getCellEditor = function () {\n    return this.cellEditor;\n  }; // + stop editing {forceRefresh: true, suppressFlash: true}\n  // + event cellChanged {}\n  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\n  // + rowComp: event dataChanged {animate: update, newData: !update}\n  // + rowComp: api refreshCells() {animate: true/false}\n  // + rowRenderer: api softRefreshView() {}\n\n\n  CellComp.prototype.refreshCell = function (params) {\n    // if we are in the middle of 'stopEditing', then we don't refresh here, as refresh gets called explicitly\n    if (this.suppressRefreshCell || this.editingCell) {\n      return;\n    }\n\n    var colDef = this.getComponentHolder();\n    var newData = params && params.newData;\n    var suppressFlash = params && params.suppressFlash || colDef.suppressCellFlash;\n    var forceRefresh = params && params.forceRefresh;\n    var oldValue = this.value;\n    this.getValueAndFormat(); // for simple values only (not pojo's), see if the value is the same, and if it is, skip the refresh.\n    // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\n    // if was before the edit.\n\n    var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\n    var dataNeedsUpdating = forceRefresh || valuesDifferent;\n\n    if (dataNeedsUpdating) {\n      // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\n      // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\n      // then we are not showing a movement in the stock price, rather we are showing different stock.\n      var cellRendererRefreshed = newData ? false : this.attemptCellRendererRefresh(); // we do the replace if not doing refresh, or if refresh was unsuccessful.\n      // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\n      // wrapper has the refresh method, but the underlying component doesn't\n\n      if (!cellRendererRefreshed) {\n        this.replaceContentsAfterRefresh();\n      } // we don't want to flash the cells when processing a filter change, as otherwise the UI would\n      // be to busy. see comment in FilterManager with regards processingFilterChange\n\n\n      var processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();\n      var flashCell = !suppressFlash && !processingFilterChange && (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || colDef.enableCellChangeFlash);\n\n      if (flashCell) {\n        this.flashCell();\n      } // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\n\n\n      this.postProcessStylesFromColDef();\n      this.postProcessClassesFromColDef();\n    } // we can't readily determine if the data in an angularjs template has changed, so here we just update\n    // and recompile (if applicable)\n\n\n    this.updateAngular1ScopeAndCompile();\n    this.refreshToolTip(); // we do cellClassRules even if the value has not changed, so that users who have rules that\n    // look at other parts of the row (where the other part of the row might of changed) will work.\n\n    this.postProcessCellClassRules();\n  }; // user can also call this via API\n\n\n  CellComp.prototype.flashCell = function () {\n    this.animateCell('data-changed');\n  };\n\n  CellComp.prototype.animateCell = function (cssName) {\n    var fullName = 'ag-cell-' + cssName;\n    var animationFullName = 'ag-cell-' + cssName + '-animation';\n    var element = this.getGui(); // we want to highlight the cells, without any animation\n\n    utils_1._.addCssClass(element, fullName);\n\n    utils_1._.removeCssClass(element, animationFullName); // then once that is applied, we remove the highlight with animation\n\n\n    window.setTimeout(function () {\n      utils_1._.removeCssClass(element, fullName);\n\n      utils_1._.addCssClass(element, animationFullName);\n\n      window.setTimeout(function () {\n        // and then to leave things as we got them, we remove the animation\n        utils_1._.removeCssClass(element, animationFullName);\n      }, 1000);\n    }, 500);\n  };\n\n  CellComp.prototype.replaceContentsAfterRefresh = function () {\n    // otherwise we rip out the cell and replace it\n    utils_1._.clearElement(this.eParentOfValue); // remove old renderer component if it exists\n\n\n    if (this.cellRenderer && this.cellRenderer.destroy) {\n      this.cellRenderer.destroy();\n    }\n\n    this.cellRenderer = null;\n    this.cellRendererGui = null; // populate\n\n    this.putDataIntoCellAfterRefresh();\n    this.updateAngular1ScopeAndCompile();\n  };\n\n  CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n      this.scope.data = __assign({}, this.rowNode.data);\n      this.angular1Compile();\n    }\n  };\n\n  CellComp.prototype.angular1Compile = function () {\n    // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\n      var eGui = this.getGui(); // only compile the node if it hasn't already been done\n      // this prevents \"orphaned\" node leaks\n\n      if (!eGui.classList.contains('ng-scope') || eGui.childElementCount === 0) {\n        var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\n        this.addDestroyFunc(function () {\n          compiledElement_1.remove();\n        });\n      }\n    }\n  };\n\n  CellComp.prototype.postProcessStylesFromColDef = function () {\n    var stylesToUse = this.processStylesFromColDef();\n\n    if (stylesToUse) {\n      utils_1._.addStylesToElement(this.getGui(), stylesToUse);\n    }\n  };\n\n  CellComp.prototype.preProcessStylesFromColDef = function () {\n    var stylesToUse = this.processStylesFromColDef();\n    return utils_1._.cssStyleObjectToMarkup(stylesToUse);\n  };\n\n  CellComp.prototype.processStylesFromColDef = function () {\n    var colDef = this.getComponentHolder();\n\n    if (colDef.cellStyle) {\n      var cssToUse = void 0;\n\n      if (typeof colDef.cellStyle === 'function') {\n        var cellStyleParams = {\n          value: this.value,\n          data: this.rowNode.data,\n          node: this.rowNode,\n          colDef: colDef,\n          column: this.column,\n          $scope: this.scope,\n          context: this.beans.gridOptionsWrapper.getContext(),\n          api: this.beans.gridOptionsWrapper.getApi()\n        };\n        var cellStyleFunc = colDef.cellStyle;\n        cssToUse = cellStyleFunc(cellStyleParams);\n      } else {\n        cssToUse = colDef.cellStyle;\n      }\n\n      return cssToUse;\n    }\n  };\n\n  CellComp.prototype.postProcessClassesFromColDef = function () {\n    var _this = this;\n\n    this.processClassesFromColDef(function (className) {\n      return utils_1._.addCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessClassesFromColDef = function () {\n    var res = [];\n    this.processClassesFromColDef(function (className) {\n      return res.push(className);\n    });\n    return res;\n  };\n\n  CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\n    var colDef = this.getComponentHolder();\n    this.beans.stylingService.processStaticCellClasses(colDef, {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: colDef,\n      rowIndex: this.rowNode.rowIndex,\n      $scope: this.scope,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass);\n  };\n\n  CellComp.prototype.putDataIntoCellAfterRefresh = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.getComponentHolder();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      this.eParentOfValue.innerHTML = colDef.template;\n    } else if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n\n      if (template) {\n        this.eParentOfValue.innerHTML = template;\n      }\n    } else {\n      // we can switch from using a cell renderer back to the default if a user\n      // is using cellRendererSelect\n      this.chooseCellRenderer();\n\n      if (this.usingCellRenderer) {\n        this.createCellRendererInstance();\n      } else {\n        var valueToUse = this.getValueToUse();\n\n        if (valueToUse !== null && valueToUse !== undefined) {\n          this.eParentOfValue.innerHTML = utils_1._.escape(valueToUse);\n        }\n      }\n    }\n  };\n\n  CellComp.prototype.attemptCellRendererRefresh = function () {\n    if (utils_1._.missing(this.cellRenderer) || !this.cellRenderer || utils_1._.missing(this.cellRenderer.refresh)) {\n      return false;\n    } // if the cell renderer has a refresh method, we call this instead of doing a refresh\n\n\n    var params = this.createCellRendererParams(); // take any custom params off of the user\n\n    var finalParams = this.beans.userComponentFactory.createFinalParams(this.getComponentHolder(), this.cellRendererType, params);\n    var result = this.cellRenderer.refresh(finalParams); // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n    // returned nothing, if the method existed, we assumed it refreshed. so for\n    // backwards compatibility, we assume if method exists and returns nothing,\n    // that it was successful.\n\n    return result === true || result === undefined;\n  };\n\n  CellComp.prototype.refreshToolTip = function () {\n    var newTooltip = this.getToolTip();\n\n    if (this.tooltip === newTooltip) {\n      return;\n    }\n\n    var hasNewTooltip = utils_1._.exists(newTooltip);\n\n    var hadTooltip = utils_1._.exists(this.tooltip);\n\n    if (hasNewTooltip && this.tooltip === newTooltip.toString()) {\n      return;\n    }\n\n    this.tooltip = newTooltip;\n\n    if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n      if (hasNewTooltip) {\n        var tooltipSanitised = utils_1._.escape(this.tooltip);\n\n        this.eParentOfValue.setAttribute('title', tooltipSanitised);\n      } else {\n        this.eParentOfValue.removeAttribute('title');\n      }\n    } else {\n      if (hadTooltip) {\n        if (!hasNewTooltip) {\n          this.beans.tooltipManager.unregisterTooltip(this);\n        }\n      } else if (hasNewTooltip) {\n        this.beans.tooltipManager.registerTooltip(this);\n      }\n    }\n  };\n\n  CellComp.prototype.valuesAreEqual = function (val1, val2) {\n    // if the user provided an equals method, use that, otherwise do simple comparison\n    var colDef = this.getComponentHolder();\n    var equalsMethod = colDef ? colDef.equals : null;\n\n    if (equalsMethod) {\n      return equalsMethod(val1, val2);\n    }\n\n    return val1 === val2;\n  };\n\n  CellComp.prototype.getToolTip = function () {\n    var colDef = this.getComponentHolder();\n    var data = this.rowNode.data;\n\n    if (colDef.tooltipField && utils_1._.exists(data)) {\n      return utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\n    }\n\n    var valueGetter = colDef.tooltipValueGetter || colDef.tooltip;\n\n    if (valueGetter) {\n      return valueGetter({\n        api: this.beans.gridOptionsWrapper.getApi(),\n        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n        colDef: colDef,\n        column: this.getColumn(),\n        context: this.beans.gridOptionsWrapper.getContext(),\n        value: this.value,\n        valueFormatted: this.valueFormatted,\n        rowIndex: this.cellPosition.rowIndex,\n        node: this.rowNode,\n        data: this.rowNode.data,\n        $scope: this.scope\n      });\n    }\n\n    return null;\n  };\n\n  CellComp.prototype.getTooltipText = function (escape) {\n    if (escape === void 0) {\n      escape = true;\n    }\n\n    return escape ? utils_1._.escape(this.tooltip) : this.tooltip;\n  };\n\n  CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\n    var colDef = this.getComponentHolder();\n    this.beans.stylingService.processClassRules(colDef.cellClassRules, {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: colDef,\n      rowIndex: this.cellPosition.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      $scope: this.scope,\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass, onNotApplicableClass);\n  };\n\n  CellComp.prototype.postProcessCellClassRules = function () {\n    var _this = this;\n\n    this.processCellClassRules(function (className) {\n      utils_1._.addCssClass(_this.getGui(), className);\n    }, function (className) {\n      utils_1._.removeCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessCellClassRules = function () {\n    var res = [];\n    this.processCellClassRules(function (className) {\n      res.push(className);\n    }, function (className) {// not catered for, if creating, no need\n      // to remove class as it was never there\n    });\n    return res;\n  }; // a wrapper is used when we are putting a selection checkbox in the cell with the value\n\n\n  CellComp.prototype.setUsingWrapper = function () {\n    var colDef = this.getComponentHolder(); // never allow selection or dragging on pinned rows\n\n    if (this.rowNode.rowPinned) {\n      this.usingWrapper = false;\n      this.includeSelectionComponent = false;\n      this.includeRowDraggingComponent = false;\n      this.includeDndSourceComponent = false;\n      return;\n    }\n\n    var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\n    var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\n    var dndSourceIsFunc = typeof colDef.dndSource === 'function';\n    this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\n    this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\n    this.includeDndSourceComponent = dndSourceIsFunc || colDef.dndSource === true;\n    this.usingWrapper = this.includeRowDraggingComponent || this.includeSelectionComponent || this.includeDndSourceComponent;\n  };\n\n  CellComp.prototype.chooseCellRenderer = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.getComponentHolder(); // templates are for ng1, ideally we wouldn't have these, they are ng1 support\n    // inside the core which is bad\n\n    if (colDef.template || colDef.templateUrl) {\n      this.usingCellRenderer = false;\n      return;\n    }\n\n    var params = this.createCellRendererParams();\n    var cellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'cellRenderer', params);\n    var pinnedRowCellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'pinnedRowCellRenderer', params);\n\n    if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\n      this.cellRendererType = CellComp.CELL_RENDERER_TYPE_PINNED;\n      this.usingCellRenderer = true;\n    } else if (cellRenderer) {\n      this.cellRendererType = CellComp.CELL_RENDERER_TYPE_NORMAL;\n      this.usingCellRenderer = true;\n    } else {\n      this.usingCellRenderer = false;\n    }\n  };\n\n  CellComp.prototype.createCellRendererInstance = function (useTaskService) {\n    var _this = this;\n\n    if (useTaskService === void 0) {\n      useTaskService = false;\n    }\n\n    if (!this.usingCellRenderer) {\n      return;\n    } // never use task service if angularCompileRows=true, as that assume the cell renderers\n    // are finished when the row is created. also we never use it if animation frame service\n    // is turned off.\n    // and lastly we never use it if doing auto-height, as the auto-height service checks the\n    // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n\n\n    var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n    var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n\n    if (angularCompileRows || suppressAnimationFrame || this.autoHeightCell) {\n      useTaskService = false;\n    }\n\n    var params = this.createCellRendererParams();\n    this.cellRendererVersion++;\n    var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\n    var cellRendererTypeNormal = this.cellRendererType === CellComp.CELL_RENDERER_TYPE_NORMAL;\n\n    var task = function () {\n      // this can return null in the event that the user has switched from a renderer component to nothing, for example\n      // when using a cellRendererSelect to return a component or null depending on row data etc\n      var componentPromise;\n\n      if (cellRendererTypeNormal) {\n        componentPromise = _this.beans.userComponentFactory.newCellRenderer(_this.getComponentHolder(), params);\n      } else {\n        componentPromise = _this.beans.userComponentFactory.newPinnedRowCellRenderer(_this.getComponentHolder(), params);\n      }\n\n      if (componentPromise) {\n        componentPromise.then(callback);\n      }\n    };\n\n    if (useTaskService) {\n      this.beans.taskQueue.addP2Task(task);\n    } else {\n      task();\n    }\n  };\n\n  CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\n    // see if daemon\n    if (!this.isAlive() || cellRendererVersion !== this.cellRendererVersion) {\n      if (cellRenderer.destroy) {\n        cellRenderer.destroy();\n      }\n\n      return;\n    }\n\n    this.cellRenderer = cellRenderer;\n    this.cellRendererGui = this.cellRenderer.getGui();\n\n    if (utils_1._.missing(this.cellRendererGui)) {\n      return;\n    } // if async components, then it's possible the user started editing since\n    // this call was made\n\n\n    if (!this.editingCell) {\n      this.eParentOfValue.appendChild(this.cellRendererGui);\n    }\n  };\n\n  CellComp.prototype.createCellRendererParams = function () {\n    var _this = this;\n\n    var params = {\n      value: this.value,\n      valueFormatted: this.valueFormatted,\n      getValue: this.getValue.bind(this),\n      setValue: function (value) {\n        _this.beans.valueService.setValue(_this.rowNode, _this.column, value);\n      },\n      formatValue: this.formatValue.bind(this),\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: this.getComponentHolder(),\n      column: this.column,\n      $scope: this.scope,\n      rowIndex: this.cellPosition.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      refreshCell: this.refreshCell.bind(this),\n      eGridCell: this.getGui(),\n      eParentOfValue: this.eParentOfValue,\n      // these bits are not documented anywhere, so we could drop them?\n      // it was in the olden days to allow user to register for when rendered\n      // row was removed (the row comp was removed), however now that the user\n      // can provide components for cells, the destroy method gets call when this\n      // happens so no longer need to fire event.\n      addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\n      addRenderedRowListener: function (eventType, listener) {\n        console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\n\n        if (_this.rowComp) {\n          _this.rowComp.addEventListener(eventType, listener);\n        }\n      }\n    };\n    return params;\n  };\n\n  CellComp.prototype.formatValue = function (value) {\n    var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\n    var valueFormattedExists = valueFormatted !== null && valueFormatted !== undefined;\n    return valueFormattedExists ? valueFormatted : value;\n  };\n\n  CellComp.prototype.getValueToUse = function () {\n    var valueFormattedExists = this.valueFormatted !== null && this.valueFormatted !== undefined;\n    return valueFormattedExists ? this.valueFormatted : this.value;\n  };\n\n  CellComp.prototype.getValueAndFormat = function () {\n    this.value = this.getValue();\n    this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n  };\n\n  CellComp.prototype.getValue = function () {\n    // if we don't check this, then the grid will render leaf groups as open even if we are not\n    // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\n    // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\n    // them via the API, or user user expanded them in the UI before turning on pivot mode\n    var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\n    var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup; // are we showing group footers\n\n    var groupFootersEnabled = this.beans.gridOptionsWrapper.isGroupIncludeFooter(); // if doing footers, we normally don't show agg data at group level when group is open\n\n    var groupAlwaysShowAggData = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader(); // if doing grouping and footers, we don't want to include the agg value\n    // in the header when the group is open\n\n    var ignoreAggData = isOpenGroup && groupFootersEnabled && !groupAlwaysShowAggData;\n    return this.beans.valueService.getValue(this.column, this.rowNode, false, ignoreAggData);\n  };\n\n  CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\n    if (utils_1._.isStopPropagationForAgGrid(mouseEvent)) {\n      return;\n    }\n\n    switch (eventName) {\n      case 'click':\n        this.onCellClicked(mouseEvent);\n        break;\n\n      case 'mousedown':\n        this.onMouseDown(mouseEvent);\n        break;\n\n      case 'dblclick':\n        this.onCellDoubleClicked(mouseEvent);\n        break;\n\n      case 'mouseout':\n        this.onMouseOut(mouseEvent);\n        break;\n\n      case 'mouseover':\n        this.onMouseOver(mouseEvent);\n        break;\n    }\n  };\n\n  CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\n    var colDef = this.getComponentHolder();\n    var cellContextMenuEvent = this.createEvent(event, events_1.Events.EVENT_CELL_CONTEXT_MENU);\n    this.beans.eventService.dispatchEvent(cellContextMenuEvent);\n\n    if (colDef.onCellContextMenu) {\n      // to make the callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellContextMenu(cellContextMenuEvent);\n      }, 0);\n    }\n  };\n\n  CellComp.prototype.createEvent = function (domEvent, eventType) {\n    var event = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      value: this.value,\n      column: this.column,\n      colDef: this.getComponentHolder(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      api: this.beans.gridApi,\n      columnApi: this.beans.columnApi,\n      rowPinned: this.rowNode.rowPinned,\n      event: domEvent,\n      type: eventType,\n      rowIndex: this.rowNode.rowIndex\n    }; // because we are hacking in $scope for angular 1, we have to de-reference\n\n    if (this.scope) {\n      event.$scope = this.scope;\n    }\n\n    return event;\n  };\n\n  CellComp.prototype.onMouseOut = function (mouseEvent) {\n    var cellMouseOutEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OUT);\n    this.beans.eventService.dispatchEvent(cellMouseOutEvent);\n    this.beans.columnHoverService.clearMouseOver();\n  };\n\n  CellComp.prototype.onMouseOver = function (mouseEvent) {\n    var cellMouseOverEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OVER);\n    this.beans.eventService.dispatchEvent(cellMouseOverEvent);\n    this.beans.columnHoverService.setMouseOver([this.column]);\n  };\n\n  CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\n    var colDef = this.getComponentHolder(); // always dispatch event to eventService\n\n    var cellDoubleClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_DOUBLE_CLICKED);\n    this.beans.eventService.dispatchEvent(cellDoubleClickedEvent); // check if colDef also wants to handle event\n\n    if (typeof colDef.onCellDoubleClicked === 'function') {\n      // to make the callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellDoubleClicked(cellDoubleClickedEvent);\n      }, 0);\n    }\n\n    var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit() && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnDoubleClick) {\n      this.startRowOrCellEdit();\n    }\n  }; // called by rowRenderer when user navigates via tab key\n\n\n  CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.startRowEditing(keyPress, charPress, this);\n    } else {\n      this.startEditingIfEnabled(keyPress, charPress, true);\n    }\n  };\n\n  CellComp.prototype.isCellEditable = function () {\n    return this.column.isCellEditable(this.rowNode);\n  }; // either called internally if single cell editing, or called by rowRenderer if row editing\n\n\n  CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\n    if (keyPress === void 0) {\n      keyPress = null;\n    }\n\n    if (charPress === void 0) {\n      charPress = null;\n    }\n\n    if (cellStartedEdit === void 0) {\n      cellStartedEdit = false;\n    } // don't do it if not editable\n\n\n    if (!this.isCellEditable()) {\n      return;\n    } // don't do it if already editing\n\n\n    if (this.editingCell) {\n      return;\n    }\n\n    this.editingCell = true;\n    this.cellEditorVersion++;\n    var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\n    var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\n    this.createCellEditor(params).then(callback); // if we don't do this, and editor component is async, then there will be a period\n    // when the component isn't present and keyboard navigation won't work - so example\n    // of user hitting tab quickly (more quickly than renderers getting created) won't work\n\n    var cellEditorAsync = utils_1._.missing(this.cellEditor);\n\n    if (cellEditorAsync && cellStartedEdit) {\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.createCellEditor = function (params) {\n    var _this = this;\n\n    var cellEditorPromise = this.beans.userComponentFactory.newCellEditor(this.column.getColDef(), params);\n    return cellEditorPromise.map(function (cellEditor) {\n      var isPopup = cellEditor.isPopup && cellEditor.isPopup();\n\n      if (!isPopup) {\n        return cellEditor;\n      }\n\n      if (_this.beans.gridOptionsWrapper.isFullRowEdit()) {\n        console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' + '- either turn off fullRowEdit, or stop using popup editors.');\n      } // if a popup, then we wrap in a popup editor and return the popup\n\n\n      var popupEditorWrapper = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);\n\n      _this.beans.context.wireBean(popupEditorWrapper);\n\n      popupEditorWrapper.init(params);\n      return popupEditorWrapper;\n    });\n  };\n\n  CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\n    // if editingCell=false, means user cancelled the editor before component was ready.\n    // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n    //   is the first editor which is now stale.\n    var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\n\n    if (versionMismatch || !this.editingCell) {\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      return;\n    }\n\n    if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      this.editingCell = false;\n      return;\n    }\n\n    if (!cellEditor.getGui) {\n      console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\"); // no getGui, for React guys, see if they attached a react component directly\n\n      if (cellEditor.render) {\n        console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\n      }\n\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      this.editingCell = false;\n      return;\n    }\n\n    this.cellEditor = cellEditor;\n    this.cellEditorInPopup = cellEditor.isPopup !== undefined && cellEditor.isPopup();\n    this.setInlineEditingClass();\n\n    if (this.cellEditorInPopup) {\n      this.addPopupCellEditor();\n    } else {\n      this.addInCellEditor();\n    }\n\n    if (cellEditor.afterGuiAttached) {\n      cellEditor.afterGuiAttached();\n    }\n\n    var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STARTED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.prototype.addInCellEditor = function () {\n    utils_1._.clearElement(this.getGui());\n\n    if (this.cellEditor) {\n      this.getGui().appendChild(this.cellEditor.getGui());\n    }\n\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.addPopupCellEditor = function () {\n    var _this = this;\n\n    var ePopupGui = this.cellEditor ? this.cellEditor.getGui() : null;\n    this.hideEditorPopup = this.beans.popupService.addAsModalPopup(ePopupGui, true, // callback for when popup disappears\n    function () {\n      _this.onPopupEditorClosed();\n    });\n    this.beans.popupService.positionPopupOverComponent({\n      column: this.column,\n      rowNode: this.rowNode,\n      type: 'popupCellEditor',\n      eventSource: this.getGui(),\n      ePopup: ePopupGui,\n      keepWithinBounds: true\n    });\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.onPopupEditorClosed = function () {\n    // we only call stopEditing if we are editing, as\n    // it's possible the popup called 'stop editing'\n    // before this, eg if 'enter key' was pressed on\n    // the editor.\n    if (this.editingCell) {\n      // note: this only happens when use clicks outside of the grid. if use clicks on another\n      // cell, then the editing will have already stopped on this cell\n      this.stopRowOrCellEdit(); // we only focus cell again if this cell is still focused. it is possible\n      // it is not focused if the user cancelled the edit by clicking on another\n      // cell outside of this one\n\n      if (this.beans.focusedCellController.isCellFocused(this.cellPosition)) {\n        this.focusCell(true);\n      }\n    }\n  }; // if we are editing inline, then we don't have the padding in the cell (set in the themes)\n  // to allow the text editor full access to the entire cell\n\n\n  CellComp.prototype.setInlineEditingClass = function () {\n    // ag-cell-inline-editing - appears when user is inline editing\n    // ag-cell-not-inline-editing - appears when user is no inline editing\n    // ag-cell-popup-editing - appears when user is editing cell in popup (appears on the cell, not on the popup)\n    // note: one of {ag-cell-inline-editing, ag-cell-not-inline-editing} is always present, they toggle.\n    //       however {ag-cell-popup-editing} shows when popup, so you have both {ag-cell-popup-editing}\n    //       and {ag-cell-not-inline-editing} showing at the same time.\n    var editingInline = this.editingCell && !this.cellEditorInPopup;\n    var popupEditorShowing = this.editingCell && this.cellEditorInPopup;\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-inline-editing\", editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-not-inline-editing\", !editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-popup-editing\", popupEditorShowing);\n\n    utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-inline-editing\", editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-not-inline-editing\", !editingInline);\n  };\n\n  CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\n    var params = {\n      value: this.getValue(),\n      keyPress: keyPress,\n      charPress: charPress,\n      column: this.column,\n      colDef: this.column.getColDef(),\n      rowIndex: this.cellPosition.rowIndex,\n      node: this.rowNode,\n      data: this.rowNode.data,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      cellStartedEdit: cellStartedEdit,\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      $scope: this.scope,\n      onKeyDown: this.onKeyDown.bind(this),\n      stopEditing: this.stopEditingAndFocus.bind(this),\n      eGridCell: this.getGui(),\n      parseValue: this.parseValue.bind(this),\n      formatValue: this.formatValue.bind(this)\n    };\n    return params;\n  }; // cell editors call this, when they want to stop for reasons other\n  // than what we pick up on. eg selecting from a dropdown ends editing.\n\n\n  CellComp.prototype.stopEditingAndFocus = function (suppressNavigateAfterEdit) {\n    if (suppressNavigateAfterEdit === void 0) {\n      suppressNavigateAfterEdit = false;\n    }\n\n    this.stopRowOrCellEdit();\n    this.focusCell(true);\n\n    if (!suppressNavigateAfterEdit) {\n      this.navigateAfterEdit();\n    }\n  };\n\n  CellComp.prototype.parseValue = function (newValue) {\n    var colDef = this.getComponentHolder();\n    var params = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      oldValue: this.value,\n      newValue: newValue,\n      colDef: colDef,\n      column: this.column,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    };\n    var valueParser = colDef.valueParser;\n    return utils_1._.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\n  };\n\n  CellComp.prototype.focusCell = function (forceBrowserFocus) {\n    if (forceBrowserFocus === void 0) {\n      forceBrowserFocus = false;\n    }\n\n    this.beans.focusedCellController.setFocusedCell(this.cellPosition.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\n  };\n\n  CellComp.prototype.setFocusInOnEditor = function () {\n    if (this.editingCell) {\n      if (this.cellEditor && this.cellEditor.focusIn) {\n        // if the editor is present, then we just focus it\n        this.cellEditor.focusIn();\n      } else {\n        // if the editor is not present, it means async cell editor (eg React fibre)\n        // and we are trying to set focus before the cell editor is present, so we\n        // focus the cell instead\n        this.focusCell(true);\n      }\n    }\n  };\n\n  CellComp.prototype.isEditing = function () {\n    return this.editingCell;\n  };\n\n  CellComp.prototype.onKeyDown = function (event) {\n    var key = event.which || event.keyCode;\n\n    switch (key) {\n      case constants_1.Constants.KEY_ENTER:\n        this.onEnterKeyDown();\n        break;\n\n      case constants_1.Constants.KEY_F2:\n        this.onF2KeyDown();\n        break;\n\n      case constants_1.Constants.KEY_ESCAPE:\n        this.onEscapeKeyDown();\n        break;\n\n      case constants_1.Constants.KEY_TAB:\n        this.onTabKeyDown(event);\n        break;\n\n      case constants_1.Constants.KEY_BACKSPACE:\n      case constants_1.Constants.KEY_DELETE:\n        this.onBackspaceOrDeleteKeyPressed(key);\n        break;\n\n      case constants_1.Constants.KEY_DOWN:\n      case constants_1.Constants.KEY_UP:\n      case constants_1.Constants.KEY_RIGHT:\n      case constants_1.Constants.KEY_LEFT:\n        this.onNavigationKeyPressed(event, key);\n        break;\n    }\n  };\n\n  CellComp.prototype.setFocusOutOnEditor = function () {\n    if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\n      this.cellEditor.focusOut();\n    }\n  };\n\n  CellComp.prototype.onNavigationKeyPressed = function (event, key) {\n    if (this.editingCell) {\n      return;\n    }\n\n    if (event.shiftKey && this.rangeSelectionEnabled) {\n      this.onShiftRangeSelect(key);\n    } else {\n      this.beans.rowRenderer.navigateToNextCell(event, key, this.cellPosition, true);\n    } // if we don't prevent default, the grid will scroll with the navigation keys\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onShiftRangeSelect = function (key) {\n    var endCell = this.beans.rangeController.extendLatestRangeInDirection(key);\n\n    if (endCell) {\n      this.beans.rowRenderer.ensureCellVisible(endCell);\n    }\n  };\n\n  CellComp.prototype.onTabKeyDown = function (event) {\n    this.beans.rowRenderer.onTabKeyDown(this, event);\n  };\n\n  CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(key);\n    }\n  };\n\n  CellComp.prototype.onEnterKeyDown = function () {\n    if (this.editingCell || this.rowComp.isEditing()) {\n      this.stopEditingAndFocus();\n    } else {\n      if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\n        this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.cellPosition, false);\n      } else {\n        this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);\n      }\n    }\n  };\n\n  CellComp.prototype.navigateAfterEdit = function () {\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (fullRowEdit) {\n      return;\n    }\n\n    var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\n\n    if (enterMovesDownAfterEdit) {\n      this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.cellPosition, false);\n    }\n  };\n\n  CellComp.prototype.onF2KeyDown = function () {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(constants_1.Constants.KEY_F2);\n    }\n  };\n\n  CellComp.prototype.onEscapeKeyDown = function () {\n    if (this.editingCell) {\n      this.stopRowOrCellEdit(true);\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.onKeyPress = function (event) {\n    // check this, in case focus is on a (for example) a text field inside the cell,\n    // in which cse we should not be listening for these key pressed\n    var eventTarget = utils_1._.getTarget(event);\n\n    var eventOnChildComponent = eventTarget !== this.getGui();\n\n    if (eventOnChildComponent || this.editingCell) {\n      return;\n    }\n\n    var pressedChar = String.fromCharCode(event.charCode);\n\n    if (pressedChar === ' ') {\n      this.onSpaceKeyPressed(event);\n    } else {\n      if (utils_1._.isEventFromPrintableCharacter(event)) {\n        this.startRowOrCellEdit(null, pressedChar); // if we don't prevent default, then the keypress also gets applied to the text field\n        // (at least when doing the default editor), but we need to allow the editor to decide\n        // what it wants to do. we only do this IF editing was started - otherwise it messes\n        // up when the use is not doing editing, but using rendering with text fields in cellRenderer\n        // (as it would block the the user from typing into text fields).\n\n        event.preventDefault();\n      }\n    }\n  };\n\n  CellComp.prototype.onSpaceKeyPressed = function (event) {\n    if (!this.editingCell && this.beans.gridOptionsWrapper.isRowSelection()) {\n      var selected = this.rowNode.isSelected();\n      this.rowNode.setSelected(!selected);\n    } // prevent default as space key, by default, moves browser scroll down\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onMouseDown = function (mouseEvent) {\n    // we only need to pass true to focusCell in when the browser is IE\n    // and we are trying to focus a cell (has ag-cell class), otherwise\n    // we pass false, as we don't want the cell to focus also get the browser\n    // focus. if we did, then the cellRenderer could have a text field in it,\n    // for example, and as the user clicks on the text field, the text field,\n    // the focus doesn't get to the text field, instead to goes to the div\n    // behind, making it impossible to select the text field.\n    var forceBrowserFocus = false;\n    var button = mouseEvent.button,\n        ctrlKey = mouseEvent.ctrlKey,\n        metaKey = mouseEvent.metaKey,\n        shiftKey = mouseEvent.shiftKey,\n        target = mouseEvent.target;\n    var _a = this.beans,\n        eventService = _a.eventService,\n        rangeController = _a.rangeController;\n\n    if (rangeController) {\n      var cellInRange = rangeController.isCellInAnyRange(this.getCellPosition());\n\n      if (cellInRange && button === 2) {\n        return;\n      }\n    }\n\n    if (utils_1._.isBrowserIE()) {\n      if (target.classList.contains('ag-cell')) {\n        forceBrowserFocus = true;\n      }\n    }\n\n    if (!shiftKey || rangeController && !rangeController.getCellRanges().length) {\n      this.focusCell(forceBrowserFocus);\n    } else {\n      // if a range is being changed, we need to make sure the focused cell does not change.\n      mouseEvent.preventDefault();\n    } // if we are clicking on a checkbox, we need to make sure the cell wrapping that checkbox\n    // is focused but we don't want to change the range selection, so return here.\n\n\n    if (utils_1._.isElementChildOfClass(target, 'ag-selection-checkbox', 3)) {\n      return;\n    } // if it's a right click, then if the cell is already in range,\n    // don't change the range, however if the cell is not in a range,\n    // we set a new range\n\n\n    var leftMouseButtonClick = utils_1._.isLeftClick(mouseEvent);\n\n    if (leftMouseButtonClick && rangeController) {\n      var thisCell = this.cellPosition;\n\n      if (shiftKey) {\n        rangeController.extendLatestRangeToCell(thisCell);\n      } else {\n        var ctrlKeyPressed = ctrlKey || metaKey;\n        rangeController.setRangeToCell(thisCell, ctrlKeyPressed);\n      }\n    }\n\n    var cellMouseDownEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_DOWN);\n    eventService.dispatchEvent(cellMouseDownEvent);\n  }; // returns true if on iPad and this is second 'click' event in 200ms\n\n\n  CellComp.prototype.isDoubleClickOnIPad = function () {\n    if (!utils_1._.isUserAgentIPad()) {\n      return false;\n    }\n\n    var nowMillis = new Date().getTime();\n    var res = nowMillis - this.lastIPadMouseClickEvent < 200;\n    this.lastIPadMouseClickEvent = nowMillis;\n    return res;\n  };\n\n  CellComp.prototype.onCellClicked = function (mouseEvent) {\n    // iPad doesn't have double click - so we need to mimic it do enable editing for\n    // iPad.\n    if (this.isDoubleClickOnIPad()) {\n      this.onCellDoubleClicked(mouseEvent);\n      mouseEvent.preventDefault(); // if we don't do this, then iPad zooms in\n\n      return;\n    }\n\n    var cellClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CLICKED);\n    this.beans.eventService.dispatchEvent(cellClickedEvent);\n    var colDef = this.getComponentHolder();\n\n    if (colDef.onCellClicked) {\n      // to make callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellClicked(cellClickedEvent);\n      }, 0);\n    }\n\n    var editOnSingleClick = (this.beans.gridOptionsWrapper.isSingleClickEdit() || colDef.singleClickEdit) && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnSingleClick) {\n      this.startRowOrCellEdit();\n    }\n\n    utils_1._.doIeFocusHack(this.getGui());\n  };\n\n  CellComp.prototype.createGridCellVo = function () {\n    this.cellPosition = {\n      rowIndex: this.rowNode.rowIndex,\n      rowPinned: this.rowNode.rowPinned,\n      column: this.column\n    };\n  };\n\n  CellComp.prototype.getCellPosition = function () {\n    return this.cellPosition;\n  };\n\n  CellComp.prototype.getParentRow = function () {\n    return this.eParentRow;\n  };\n\n  CellComp.prototype.setParentRow = function (eParentRow) {\n    this.eParentRow = eParentRow;\n  };\n\n  CellComp.prototype.getColumn = function () {\n    return this.column;\n  };\n\n  CellComp.prototype.getComponentHolder = function () {\n    return this.column.getColDef();\n  };\n\n  CellComp.prototype.detach = function () {\n    this.eParentRow.removeChild(this.getGui());\n  }; // if the row is also getting destroyed, then we don't need to remove from dom,\n  // as the row will also get removed, so no need to take out the cells from the row\n  // if the row is going (removing is an expensive operation, so only need to remove\n  // the top part)\n\n\n  CellComp.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    if (this.cellEditor && this.cellEditor.destroy) {\n      this.cellEditor.destroy();\n      this.cellEditor = null;\n    }\n\n    if (this.cellRenderer && this.cellRenderer.destroy) {\n      this.cellRenderer.destroy();\n      this.cellRenderer = null;\n    }\n\n    if (this.selectionHandle) {\n      this.selectionHandle.destroy();\n    }\n  };\n\n  CellComp.prototype.onLeftChanged = function () {\n    var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n    this.getGui().style.left = left + 'px';\n  };\n\n  CellComp.prototype.modifyLeftForPrintLayout = function (leftPosition) {\n    if (!this.printLayout) {\n      return leftPosition;\n    }\n\n    if (this.column.getPinned() === column_1.Column.PINNED_LEFT) {\n      return leftPosition;\n    }\n\n    if (this.column.getPinned() === column_1.Column.PINNED_RIGHT) {\n      var leftWidth_1 = this.beans.columnController.getPinnedLeftContainerWidth();\n      var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n      return leftWidth_1 + bodyWidth + leftPosition;\n    } // is in body\n\n\n    var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n    return leftWidth + leftPosition;\n  };\n\n  CellComp.prototype.onWidthChanged = function () {\n    var width = this.getCellWidth();\n    this.getGui().style.width = width + 'px';\n  };\n\n  CellComp.prototype.getRangeBorders = function () {\n    var _this = this;\n\n    var isRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n    var top = false;\n    var right = false;\n    var bottom = false;\n    var left = false;\n    var thisCol = this.cellPosition.column;\n    var rangeController = this.beans.rangeController;\n    var leftCol;\n    var rightCol;\n\n    if (isRtl) {\n      leftCol = this.beans.columnController.getDisplayedColAfter(thisCol);\n      rightCol = this.beans.columnController.getDisplayedColBefore(thisCol);\n    } else {\n      leftCol = this.beans.columnController.getDisplayedColBefore(thisCol);\n      rightCol = this.beans.columnController.getDisplayedColAfter(thisCol);\n    }\n\n    var ranges = rangeController.getCellRanges().filter(function (range) {\n      return rangeController.isCellInSpecificRange(_this.cellPosition, range);\n    }); // this means we are the first column in the grid\n\n    if (!leftCol) {\n      left = true;\n    } // this means we are the last column in the grid\n\n\n    if (!rightCol) {\n      right = true;\n    }\n\n    for (var i = 0; i < ranges.length; i++) {\n      if (top && right && bottom && left) {\n        break;\n      }\n\n      var range = ranges[i];\n      var startRow = rangeController.getRangeStartRow(range);\n      var endRow = rangeController.getRangeEndRow(range);\n\n      if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellPosition)) {\n        top = true;\n      }\n\n      if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellPosition)) {\n        bottom = true;\n      }\n\n      if (!left && range.columns.indexOf(leftCol) < 0) {\n        left = true;\n      }\n\n      if (!right && range.columns.indexOf(rightCol) < 0) {\n        right = true;\n      }\n    }\n\n    return {\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n\n  CellComp.prototype.getInitialRangeClasses = function () {\n    var res = [];\n\n    if (!this.rangeSelectionEnabled || !this.rangeCount) {\n      return res;\n    }\n\n    var beans = this.beans;\n    var rangeController = beans.rangeController;\n    res.push('ag-cell-range-selected');\n\n    if (this.hasChartRange) {\n      res.push('ag-cell-range-chart');\n    }\n\n    var count = Math.min(this.rangeCount, 4);\n    res.push(\"ag-cell-range-selected-\" + count);\n\n    if (this.rangeCount === 1 && !rangeController.isMoreThanOneCell()) {\n      res.push('ag-cell-range-single-cell');\n    }\n\n    if (this.rangeCount > 0) {\n      var borders = this.getRangeBorders();\n\n      if (borders.top) {\n        res.push('ag-cell-range-top');\n      }\n\n      if (borders.right) {\n        res.push('ag-cell-range-right');\n      }\n\n      if (borders.bottom) {\n        res.push('ag-cell-range-bottom');\n      }\n\n      if (borders.left) {\n        res.push('ag-cell-range-left');\n      }\n    }\n\n    if (!!this.selectionHandle) {\n      res.push('ag-cell-range-handle');\n    }\n\n    return res;\n  };\n\n  CellComp.prototype.onRowIndexChanged = function () {\n    // when index changes, this influences items that need the index, so we update the\n    // grid cell so they are working off the new index.\n    this.createGridCellVo(); // when the index of the row changes, ie means the cell may have lost or gained focus\n\n    this.onCellFocused(); // check range selection\n\n    this.onRangeSelectionChanged();\n  };\n\n  CellComp.prototype.onRangeSelectionChanged = function () {\n    if (!this.beans.enterprise) {\n      return;\n    }\n\n    var _a = this,\n        beans = _a.beans,\n        cellPosition = _a.cellPosition,\n        rangeCount = _a.rangeCount;\n\n    var rangeController = beans.rangeController;\n    var newRangeCount = rangeController.getCellRangeCount(cellPosition);\n    var element = this.getGui();\n\n    if (rangeCount !== newRangeCount) {\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\n\n      this.rangeCount = newRangeCount;\n    }\n\n    var hasChartRange = this.rangeCount && rangeController.getCellRanges().every(function (range) {\n      return utils_1._.exists(range.type);\n    });\n\n    if (this.hasChartRange !== hasChartRange) {\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-chart', hasChartRange);\n\n      this.hasChartRange = hasChartRange;\n    }\n\n    this.updateRangeBorders();\n    var isSingleCell = this.rangeCount === 1 && !rangeController.isMoreThanOneCell();\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-single-cell', isSingleCell);\n\n    this.refreshHandle();\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-handle', !!this.selectionHandle);\n  };\n\n  CellComp.prototype.shouldHaveSelectionHandle = function () {\n    var _a = this.beans,\n        gridOptionsWrapper = _a.gridOptionsWrapper,\n        rangeController = _a.rangeController;\n    var el = this.getGui();\n    var cellRanges = rangeController.getCellRanges();\n    var rangesLen = cellRanges.length;\n\n    if (!rangesLen) {\n      return false;\n    }\n\n    var lastRange = utils_1._.last(cellRanges);\n\n    var isFirstRangeCategory = cellRanges[0].type === iRangeController_1.CellRangeType.DIMENSION;\n    var handlesAllowed = (gridOptionsWrapper.isEnableFillHandle() || gridOptionsWrapper.isEnableRangeHandle() || this.hasChartRange && !isFirstRangeCategory) && rangesLen === 1;\n\n    if (!handlesAllowed && this.hasChartRange) {\n      var cellPosition = this.getCellPosition();\n      handlesAllowed = isFirstRangeCategory && rangesLen === 2 && rangeController.isCellInSpecificRange(this.getCellPosition(), lastRange);\n      var isCategory = isFirstRangeCategory && rangeController.isCellInSpecificRange(cellPosition, cellRanges[0]);\n\n      utils_1._.addOrRemoveCssClass(el, 'ag-cell-range-chart-category', isCategory);\n    }\n\n    return this.rangeCount && handlesAllowed && lastRange.endRow != null && this.beans.rangeController.isContiguousRange(lastRange) && (utils_1._.containsClass(el, 'ag-cell-range-single-cell') || utils_1._.containsClass(el, 'ag-cell-range-bottom') && utils_1._.containsClass(el, 'ag-cell-range-right'));\n  };\n\n  CellComp.prototype.addSelectionHandle = function () {\n    var _a = this.beans,\n        gridOptionsWrapper = _a.gridOptionsWrapper,\n        context = _a.context,\n        rangeController = _a.rangeController;\n\n    var cellRangeType = utils_1._.last(rangeController.getCellRanges()).type;\n\n    var type = gridOptionsWrapper.isEnableFillHandle() && utils_1._.missing(cellRangeType) ? 'fill' : 'range';\n\n    if (this.selectionHandle && this.selectionHandle.getType() !== type) {\n      this.selectionHandle.destroy();\n      this.selectionHandle = undefined;\n    }\n\n    if (!this.selectionHandle) {\n      this.selectionHandle = context.createComponentFromElement(document.createElement(\"ag-\" + type + \"-handle\"));\n    }\n\n    this.selectionHandle.refresh(this);\n  };\n\n  CellComp.prototype.updateRangeBordersIfRangeCount = function () {\n    // we only need to update range borders if we are in a range\n    if (this.rangeCount > 0) {\n      this.updateRangeBorders();\n      this.refreshHandle();\n    }\n  };\n\n  CellComp.prototype.refreshHandle = function () {\n    var shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();\n\n    if (this.selectionHandle && !shouldHaveSelectionHandle) {\n      this.selectionHandle.destroy();\n      this.selectionHandle = null;\n    }\n\n    if (shouldHaveSelectionHandle) {\n      this.addSelectionHandle();\n    }\n  };\n\n  CellComp.prototype.updateRangeBorders = function () {\n    var rangeBorders = this.getRangeBorders();\n    var isSingleCell = this.rangeCount === 1 && !this.beans.rangeController.isMoreThanOneCell();\n    var isTop = !isSingleCell && rangeBorders.top;\n    var isRight = !isSingleCell && rangeBorders.right;\n    var isBottom = !isSingleCell && rangeBorders.bottom;\n    var isLeft = !isSingleCell && rangeBorders.left;\n    var element = this.getGui();\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-top', isTop);\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-right', isRight);\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-bottom', isBottom);\n\n    utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-left', isLeft);\n  };\n\n  CellComp.prototype.onFirstRightPinnedChanged = function () {\n    var firstRightPinned = this.column.isFirstRightPinned();\n\n    if (this.firstRightPinned !== firstRightPinned) {\n      this.firstRightPinned = firstRightPinned;\n\n      utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\n    }\n  };\n\n  CellComp.prototype.onLastLeftPinnedChanged = function () {\n    var lastLeftPinned = this.column.isLastLeftPinned();\n\n    if (this.lastLeftPinned !== lastLeftPinned) {\n      this.lastLeftPinned = lastLeftPinned;\n\n      utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\n    }\n  };\n\n  CellComp.prototype.populateTemplate = function () {\n    if (this.usingWrapper) {\n      this.eParentOfValue = this.getRefElement('eCellValue');\n      this.eCellWrapper = this.getRefElement('eCellWrapper');\n\n      if (this.includeRowDraggingComponent) {\n        this.addRowDragging();\n      }\n\n      if (this.includeDndSourceComponent) {\n        this.addDndSource();\n      }\n\n      if (this.includeSelectionComponent) {\n        this.addSelectionCheckbox();\n      }\n    } else {\n      this.eParentOfValue = this.getGui();\n    }\n  };\n\n  CellComp.prototype.getFrameworkOverrides = function () {\n    return this.beans.frameworkOverrides;\n  };\n\n  CellComp.prototype.addRowDragging = function () {\n    var pagination = this.beans.gridOptionsWrapper.isPagination();\n    var rowDragManaged = this.beans.gridOptionsWrapper.isRowDragManaged();\n    var clientSideRowModelActive = this.beans.gridOptionsWrapper.isRowModelDefault();\n\n    if (rowDragManaged) {\n      // row dragging only available in default row model\n      if (!clientSideRowModelActive) {\n        utils_1._.doOnce(function () {\n          return console.warn('ag-Grid: managed row dragging is only allowed in the Client Side Row Model');\n        }, 'CellComp.addRowDragging');\n\n        return;\n      }\n\n      if (pagination) {\n        utils_1._.doOnce(function () {\n          return console.warn('ag-Grid: managed row dragging is not possible when doing pagination');\n        }, 'CellComp.addRowDragging');\n\n        return;\n      }\n    }\n\n    var rowDraggingComp = new rowDragComp_1.RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\n    this.addFeature(this.beans.context, rowDraggingComp); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addDndSource = function () {\n    var dndSourceComp = new dndSourceComp_1.DndSourceComp(this.rowNode, this.column, this.getValueToUse(), this.beans, this.getGui());\n    this.addFeature(this.beans.context, dndSourceComp); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(dndSourceComp.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addSelectionCheckbox = function () {\n    var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();\n    this.beans.context.wireBean(cbSelectionComponent);\n    var visibleFunc = this.getComponentHolder().checkboxSelection;\n    visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n    cbSelectionComponent.init({\n      rowNode: this.rowNode,\n      column: this.column,\n      visibleFunc: visibleFunc\n    });\n    this.addDestroyFunc(function () {\n      return cbSelectionComponent.destroy();\n    }); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addDomData = function () {\n    var _this = this;\n\n    var element = this.getGui();\n    this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\n    this.addDestroyFunc(function () {\n      return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);\n    });\n  };\n\n  CellComp.prototype.onCellFocused = function (event) {\n    var cellFocused = this.beans.focusedCellController.isCellFocused(this.cellPosition); // see if we need to change the classes on this cell\n\n    if (cellFocused !== this.cellFocused) {\n      // if we are not doing cell selection, then the focus class does not change\n      var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n      if (doingFocusCss) {\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\n      }\n\n      this.cellFocused = cellFocused;\n    } // if this cell was just focused, see if we need to force browser focus, his can\n    // happen if focus is programmatically set.\n\n\n    if (cellFocused && event && event.forceBrowserFocus) {\n      var eGui = this.getGui();\n      eGui.focus();\n\n      utils_1._.doIeFocusHack(eGui);\n    } // if another cell was focused, and we are editing, then stop editing\n\n\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (!cellFocused && !fullRowEdit && this.editingCell) {\n      this.stopRowOrCellEdit();\n    }\n  }; // pass in 'true' to cancel the editing.\n\n\n  CellComp.prototype.stopRowOrCellEdit = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.stopRowEditing(cancel);\n    } else {\n      this.stopEditing(cancel);\n    }\n  };\n\n  CellComp.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (!this.editingCell) {\n      return;\n    } // if no cell editor, this means due to async, that the cell editor never got initialised,\n    // so we just carry on regardless as if the editing was never started.\n\n\n    if (!this.cellEditor) {\n      this.editingCell = false;\n      return;\n    }\n\n    var newValueExists = false;\n    var newValue;\n\n    if (!cancel) {\n      // also have another option here to cancel after editing, so for example user could have a popup editor and\n      // it is closed by user clicking outside the editor. then the editor will close automatically (with false\n      // passed above) and we need to see if the editor wants to accept the new value.\n      var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\n\n      if (!userWantsToCancel) {\n        newValue = this.cellEditor.getValue();\n        newValueExists = true;\n      }\n    } // it is important we set this after setValue() above, as otherwise the cell will flash\n    // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\n    // thus it will skip the refresh on this cell until the end of this method where we call\n    // refresh directly and we suppress the flash.\n\n\n    this.editingCell = false;\n\n    if (this.cellEditor.destroy) {\n      this.cellEditor.destroy();\n    } // important to clear this out - as parts of the code will check for\n    // this to see if an async cellEditor has yet to be created\n\n\n    this.cellEditor = null;\n\n    if (this.cellEditorInPopup && this.hideEditorPopup) {\n      this.hideEditorPopup();\n      this.hideEditorPopup = null;\n    } else {\n      utils_1._.clearElement(this.getGui()); // put the cell back the way it was before editing\n\n\n      if (this.usingWrapper) {\n        // if wrapper, then put the wrapper back\n        this.getGui().appendChild(this.eCellWrapper);\n      } else {\n        // if cellRenderer, then put the gui back in. if the renderer has\n        // a refresh, it will be called. however if it doesn't, then later\n        // the renderer will be destroyed and a new one will be created.\n        if (this.cellRenderer) {\n          // we know it's a dom element (not a string) because we converted\n          // it after the gui was attached if it was a string.\n          var eCell = this.cellRendererGui; // can be null if cell was previously null / contained empty string,\n          // this will result in new value not being rendered.\n\n          if (eCell) {\n            this.getGui().appendChild(eCell);\n          }\n        }\n      }\n    }\n\n    this.setInlineEditingClass();\n\n    if (newValueExists) {\n      // we suppressRefreshCell because the call to rowNode.setDataValue() results in change detection\n      // getting triggered, which results in all cells getting refreshed. we do not want this refresh\n      // to happen on this call as we want to call it explicitly below. otherwise refresh gets called twice.\n      // if we only did this refresh (and not the one below) then the cell would flash and not be forced.\n      this.suppressRefreshCell = true;\n      this.rowNode.setDataValue(this.column, newValue);\n      this.suppressRefreshCell = false;\n    } // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\n    // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\n    // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\n\n\n    this.refreshCell({\n      forceRefresh: true,\n      suppressFlash: true\n    });\n    var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STOPPED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\n  CellComp.CELL_RENDERER_TYPE_NORMAL = 'cellRenderer';\n  CellComp.CELL_RENDERER_TYPE_PINNED = 'pinnedRowCellRenderer';\n  return CellComp;\n}(component_1.Component);\n\nexports.CellComp = CellComp;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/rendering/cellComp.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","defineProperty","exports","value","column_1","require","constants_1","events_1","component_1","checkboxSelectionComponent_1","iRangeController_1","rowDragComp_1","popupEditorWrapper_1","utils_1","dndSourceComp_1","CellComp","_super","scope","beans","column","rowNode","rowComp","autoHeightCell","printLayout","_this","editingCell","suppressRefreshCell","cellEditorVersion","cellRendererVersion","createGridCellVo","rangeSelectionEnabled","gridOptionsWrapper","isEnableRangeSelection","cellFocused","focusedCellController","isCellFocused","cellPosition","firstRightPinned","isFirstRightPinned","lastLeftPinned","isLastLeftPinned","rangeController","rangeCount","getCellRangeCount","hasChartRange","getCellRanges","every","range","_","exists","type","getValueAndFormat","setUsingWrapper","chooseCellRenderer","setupColSpan","rowSpan","getRowSpan","getCreateTemplate","unselectable","isEnableCellTextSelection","templateParts","col","width","getCellWidth","left","modifyLeftForPrintLayout","getCellLeft","valueToRender","getInitialValueToRender","valueSanitised","get","escape","tooltip","getToolTip","tooltipSanitised","colIdSanitised","getId","wrapperStartTemplate","wrapperEndTemplate","stylesFromColDef","preProcessStylesFromColDef","cssClasses","getInitialCssClasses","stylesForRowSpanning","getStylesForRowSpanning","usingWrapper","push","getCompId","join","isEnableBrowserTooltips","singleRowHeight","getRowHeightAsNumber","totalRowHeight","afterAttached","querySelector","eGui","eParentRow","setGui","addDomData","populateTemplate","createCellRendererInstance","angular1Compile","shouldHaveSelectionHandle","addSelectionHandle","tooltipManager","registerTooltip","onColumnHover","isHovered","columnHoverService","addOrRemoveCssClass","getGui","onCellChanged","event","eventImpactsThisCell","refreshCell","mostLeftCol","isEnableRtl","colsSpanning","last","getLeft","getActualWidth","result","forEach","onFlashCells","cellId","cellPositionUtils","createId","shouldFlash","cells","animateCell","missing","getComponentHolder","colSpan","addDestroyableEventListener","eventService","Events","EVENT_DISPLAYED_COLUMNS_CHANGED","onDisplayColumnsChanged","bind","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onWidthChanged","getColSpanningList","getColSpan","pointer","pinned","getPinned","columnController","getDisplayedColAfter","compareArrays","onLeftChanged","doingFocusCss","isSuppressCellSelection","pushAll","preProcessClassesFromColDef","preProcessCellClassRules","getInitialRangeClasses","usingCellRenderer","cellRendererGui","colDef","template","templateUrl","templateService","getTemplate","getValueToUse","getRenderedRow","isSuppressNavigable","getCellRenderer","cellRenderer","getCellEditor","cellEditor","params","newData","suppressFlash","suppressCellFlash","forceRefresh","oldValue","valuesDifferent","valuesAreEqual","dataNeedsUpdating","cellRendererRefreshed","attemptCellRendererRefresh","replaceContentsAfterRefresh","processingFilterChange","filterManager","isSuppressFlashingCellsBecauseFiltering","flashCell","isEnableCellChangeFlash","enableCellChangeFlash","postProcessStylesFromColDef","postProcessClassesFromColDef","updateAngular1ScopeAndCompile","refreshToolTip","postProcessCellClassRules","cssName","fullName","animationFullName","element","addCssClass","removeCssClass","window","setTimeout","clearElement","eParentOfValue","destroy","putDataIntoCellAfterRefresh","isAngularCompileRows","data","classList","contains","childElementCount","compiledElement_1","$compile","addDestroyFunc","remove","stylesToUse","processStylesFromColDef","addStylesToElement","cssStyleObjectToMarkup","cellStyle","cssToUse","cellStyleParams","node","$scope","context","getContext","api","getApi","cellStyleFunc","processClassesFromColDef","className","res","onApplicableClass","stylingService","processStaticCellClasses","rowIndex","columnApi","getColumnApi","innerHTML","valueToUse","undefined","refresh","createCellRendererParams","finalParams","userComponentFactory","createFinalParams","cellRendererType","newTooltip","hasNewTooltip","hadTooltip","toString","setAttribute","removeAttribute","unregisterTooltip","val1","val2","equalsMethod","equals","tooltipField","getValueUsingField","isTooltipFieldContainsDots","valueGetter","tooltipValueGetter","getColumn","valueFormatted","getTooltipText","processCellClassRules","onNotApplicableClass","processClassRules","cellClassRules","rowPinned","includeSelectionComponent","includeRowDraggingComponent","includeDndSourceComponent","cbSelectionIsFunc","checkboxSelection","rowDraggableIsFunc","rowDrag","dndSourceIsFunc","dndSource","lookupComponentClassDef","pinnedRowCellRenderer","CELL_RENDERER_TYPE_PINNED","CELL_RENDERER_TYPE_NORMAL","useTaskService","angularCompileRows","suppressAnimationFrame","isSuppressAnimationFrame","callback","afterCellRendererCreated","cellRendererTypeNormal","task","componentPromise","newCellRenderer","newPinnedRowCellRenderer","then","taskQueue","addP2Task","isAlive","appendChild","getValue","setValue","valueService","formatValue","eGridCell","addRowCompListener","addEventListener","addRenderedRowListener","eventType","listener","console","warn","valueFormatterService","valueFormattedExists","lockedClosedGroup","leafGroup","isPivotMode","isOpenGroup","group","expanded","footer","groupFootersEnabled","isGroupIncludeFooter","groupAlwaysShowAggData","isGroupSuppressBlankHeader","ignoreAggData","onMouseEvent","eventName","mouseEvent","isStopPropagationForAgGrid","onCellClicked","onMouseDown","onCellDoubleClicked","onMouseOut","onMouseOver","dispatchCellContextMenuEvent","cellContextMenuEvent","createEvent","EVENT_CELL_CONTEXT_MENU","dispatchEvent","onCellContextMenu","domEvent","gridApi","cellMouseOutEvent","EVENT_CELL_MOUSE_OUT","clearMouseOver","cellMouseOverEvent","EVENT_CELL_MOUSE_OVER","setMouseOver","cellDoubleClickedEvent","EVENT_CELL_DOUBLE_CLICKED","editOnDoubleClick","isSingleClickEdit","isSuppressClickEdit","startRowOrCellEdit","keyPress","charPress","isFullRowEdit","startRowEditing","startEditingIfEnabled","isCellEditable","cellStartedEdit","afterCellEditorCreated","createCellEditorParams","createCellEditor","cellEditorAsync","focusCell","cellEditorPromise","newCellEditor","getColDef","map","isPopup","popupEditorWrapper","PopupEditorWrapper","wireBean","init","versionMismatch","isCancelBeforeStart","render","cellEditorInPopup","setInlineEditingClass","addPopupCellEditor","addInCellEditor","afterGuiAttached","EVENT_CELL_EDITING_STARTED","ePopupGui","hideEditorPopup","popupService","addAsModalPopup","onPopupEditorClosed","positionPopupOverComponent","eventSource","ePopup","keepWithinBounds","stopRowOrCellEdit","editingInline","popupEditorShowing","parentNode","onKeyDown","stopEditing","stopEditingAndFocus","parseValue","suppressNavigateAfterEdit","navigateAfterEdit","newValue","valueParser","expressionService","evaluate","forceBrowserFocus","setFocusedCell","setFocusInOnEditor","focusIn","isEditing","key","which","keyCode","Constants","KEY_ENTER","onEnterKeyDown","KEY_F2","onF2KeyDown","KEY_ESCAPE","onEscapeKeyDown","KEY_TAB","onTabKeyDown","KEY_BACKSPACE","KEY_DELETE","onBackspaceOrDeleteKeyPressed","KEY_DOWN","KEY_UP","KEY_RIGHT","KEY_LEFT","onNavigationKeyPressed","setFocusOutOnEditor","focusOut","shiftKey","onShiftRangeSelect","rowRenderer","navigateToNextCell","preventDefault","endCell","extendLatestRangeInDirection","ensureCellVisible","isEnterMovesDown","fullRowEdit","enterMovesDownAfterEdit","isEnterMovesDownAfterEdit","onKeyPress","eventTarget","getTarget","eventOnChildComponent","pressedChar","String","fromCharCode","charCode","onSpaceKeyPressed","isEventFromPrintableCharacter","isRowSelection","selected","isSelected","setSelected","button","ctrlKey","metaKey","target","_a","cellInRange","isCellInAnyRange","getCellPosition","isBrowserIE","isElementChildOfClass","leftMouseButtonClick","isLeftClick","thisCell","extendLatestRangeToCell","ctrlKeyPressed","setRangeToCell","cellMouseDownEvent","EVENT_CELL_MOUSE_DOWN","isDoubleClickOnIPad","isUserAgentIPad","nowMillis","Date","getTime","lastIPadMouseClickEvent","cellClickedEvent","EVENT_CELL_CLICKED","editOnSingleClick","singleClickEdit","doIeFocusHack","getParentRow","setParentRow","detach","removeChild","selectionHandle","style","leftPosition","Column","PINNED_LEFT","PINNED_RIGHT","leftWidth_1","getPinnedLeftContainerWidth","bodyWidth","getBodyContainerWidth","leftWidth","getRangeBorders","isRtl","top","right","bottom","thisCol","leftCol","rightCol","getDisplayedColBefore","ranges","filter","isCellInSpecificRange","startRow","getRangeStartRow","endRow","getRangeEndRow","rowPositionUtils","sameRow","columns","indexOf","count","Math","min","isMoreThanOneCell","borders","onRowIndexChanged","onCellFocused","onRangeSelectionChanged","enterprise","newRangeCount","updateRangeBorders","isSingleCell","refreshHandle","el","cellRanges","rangesLen","lastRange","isFirstRangeCategory","CellRangeType","DIMENSION","handlesAllowed","isEnableFillHandle","isEnableRangeHandle","isCategory","isContiguousRange","containsClass","cellRangeType","getType","createComponentFromElement","document","createElement","updateRangeBordersIfRangeCount","rangeBorders","isTop","isRight","isBottom","isLeft","onFirstRightPinnedChanged","onLastLeftPinnedChanged","getRefElement","eCellWrapper","addRowDragging","addDndSource","addSelectionCheckbox","getFrameworkOverrides","frameworkOverrides","pagination","isPagination","rowDragManaged","isRowDragManaged","clientSideRowModelActive","isRowModelDefault","doOnce","rowDraggingComp","RowDragComp","addFeature","insertBefore","dndSourceComp","DndSourceComp","cbSelectionComponent","CheckboxSelectionComponent","visibleFunc","setDomData","DOM_DATA_KEY_CELL_COMP","focus","cancel","stopRowEditing","newValueExists","userWantsToCancel","isCancelAfterEnd","eCell","setDataValue","EVENT_CELL_EDITING_STOPPED","Component"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar column_1 = require(\"../entities/column\");\nvar constants_1 = require(\"../constants\");\nvar events_1 = require(\"../events\");\nvar component_1 = require(\"../widgets/component\");\nvar checkboxSelectionComponent_1 = require(\"./checkboxSelectionComponent\");\nvar iRangeController_1 = require(\"../interfaces/iRangeController\");\nvar rowDragComp_1 = require(\"./rowDragComp\");\nvar popupEditorWrapper_1 = require(\"./cellEditors/popupEditorWrapper\");\nvar utils_1 = require(\"../utils\");\nvar dndSourceComp_1 = require(\"./dndSourceComp\");\nvar CellComp = /** @class */ (function (_super) {\n    __extends(CellComp, _super);\n    function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell, printLayout) {\n        var _this = _super.call(this) || this;\n        _this.editingCell = false;\n        _this.suppressRefreshCell = false;\n        _this.scope = null;\n        // every time we go into edit mode, or back again, this gets incremented.\n        // it's the components way of dealing with the async nature of framework components,\n        // so if a framework component takes a while to be created, we know if the object\n        // is still relevant when creating is finished. eg we could click edit / un-edit 20\n        // times before the first React edit component comes back - we should discard\n        // the first 19.\n        _this.cellEditorVersion = 0;\n        _this.cellRendererVersion = 0;\n        _this.scope = scope;\n        _this.beans = beans;\n        _this.column = column;\n        _this.rowNode = rowNode;\n        _this.rowComp = rowComp;\n        _this.autoHeightCell = autoHeightCell;\n        _this.printLayout = printLayout;\n        _this.createGridCellVo();\n        _this.rangeSelectionEnabled = beans.gridOptionsWrapper.isEnableRangeSelection();\n        _this.cellFocused = _this.beans.focusedCellController.isCellFocused(_this.cellPosition);\n        _this.firstRightPinned = _this.column.isFirstRightPinned();\n        _this.lastLeftPinned = _this.column.isLastLeftPinned();\n        if (_this.rangeSelectionEnabled) {\n            var rangeController = _this.beans.rangeController;\n            _this.rangeCount = rangeController.getCellRangeCount(_this.cellPosition);\n            if (_this.rangeCount) {\n                _this.hasChartRange = rangeController.getCellRanges().every(function (range) { return utils_1._.exists(range.type); });\n            }\n        }\n        _this.getValueAndFormat();\n        _this.setUsingWrapper();\n        _this.chooseCellRenderer();\n        _this.setupColSpan();\n        _this.rowSpan = _this.column.getRowSpan(_this.rowNode);\n        return _this;\n    }\n    CellComp.prototype.getCreateTemplate = function () {\n        var unselectable = !this.beans.gridOptionsWrapper.isEnableCellTextSelection() ? 'unselectable=\"on\"' : '';\n        var templateParts = [];\n        var col = this.column;\n        var width = this.getCellWidth();\n        var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n        var valueToRender = this.getInitialValueToRender();\n        var valueSanitised = utils_1._.get(this.column, 'colDef.template', null) ? valueToRender : utils_1._.escape(valueToRender);\n        this.tooltip = this.getToolTip();\n        var tooltipSanitised = utils_1._.escape(this.tooltip);\n        var colIdSanitised = utils_1._.escape(col.getId());\n        var wrapperStartTemplate = '';\n        var wrapperEndTemplate = '';\n        var stylesFromColDef = this.preProcessStylesFromColDef();\n        var cssClasses = this.getInitialCssClasses();\n        var stylesForRowSpanning = this.getStylesForRowSpanning();\n        if (this.usingWrapper) {\n            wrapperStartTemplate = \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\"><span ref=\\\"eCellValue\\\" class=\\\"ag-cell-value\\\" \" + unselectable + \">\";\n            wrapperEndTemplate = '</span></div>';\n        }\n        templateParts.push(\"<div\");\n        templateParts.push(\" tabindex=\\\"-1\\\"\");\n        templateParts.push(\" \" + unselectable); // THIS IS FOR IE ONLY so text selection doesn't bubble outside of the grid\n        templateParts.push(\" role=\\\"gridcell\\\"\");\n        templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\n        templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\n        templateParts.push(\" class=\\\"\" + cssClasses.join(' ') + \"\\\"\");\n        if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips() && utils_1._.exists(tooltipSanitised)) {\n            templateParts.push(\"title=\\\"\" + tooltipSanitised + \"\\\"\");\n        }\n        templateParts.push(\" style=\\\"width: \" + width + \"px; left: \" + left + \"px; \" + stylesFromColDef + \" \" + stylesForRowSpanning + \"\\\" >\");\n        templateParts.push(wrapperStartTemplate);\n        if (utils_1._.exists(valueSanitised, true)) {\n            templateParts.push(valueSanitised);\n        }\n        templateParts.push(wrapperEndTemplate);\n        templateParts.push(\"</div>\");\n        return templateParts.join('');\n    };\n    CellComp.prototype.getStylesForRowSpanning = function () {\n        if (this.rowSpan === 1) {\n            return '';\n        }\n        var singleRowHeight = this.beans.gridOptionsWrapper.getRowHeightAsNumber();\n        var totalRowHeight = singleRowHeight * this.rowSpan;\n        return \"height: \" + totalRowHeight + \"px; z-index: 1;\";\n    };\n    CellComp.prototype.afterAttached = function () {\n        var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\n        var eGui = this.eParentRow.querySelector(querySelector);\n        this.setGui(eGui);\n        // all of these have dependencies on the eGui, so only do them after eGui is set\n        this.addDomData();\n        this.populateTemplate();\n        this.createCellRendererInstance(true);\n        this.angular1Compile();\n        // if not doing enterprise, then range selection service would be missing\n        // so need to check before trying to use it\n        if (this.rangeSelectionEnabled) {\n            if (this.shouldHaveSelectionHandle()) {\n                this.addSelectionHandle();\n            }\n        }\n        if (utils_1._.exists(this.tooltip) && !this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n            this.beans.tooltipManager.registerTooltip(this);\n        }\n    };\n    CellComp.prototype.onColumnHover = function () {\n        var isHovered = this.beans.columnHoverService.isHovered(this.column);\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\n    };\n    CellComp.prototype.onCellChanged = function (event) {\n        var eventImpactsThisCell = event.column === this.column;\n        if (eventImpactsThisCell) {\n            this.refreshCell({});\n        }\n    };\n    CellComp.prototype.getCellLeft = function () {\n        var mostLeftCol;\n        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n            mostLeftCol = utils_1._.last(this.colsSpanning);\n        }\n        else {\n            mostLeftCol = this.column;\n        }\n        return mostLeftCol.getLeft();\n    };\n    CellComp.prototype.getCellWidth = function () {\n        if (!this.colsSpanning) {\n            return this.column.getActualWidth();\n        }\n        var result = 0;\n        this.colsSpanning.forEach(function (col) { return result += col.getActualWidth(); });\n        return result;\n    };\n    CellComp.prototype.onFlashCells = function (event) {\n        var cellId = this.beans.cellPositionUtils.createId(this.cellPosition);\n        var shouldFlash = event.cells[cellId];\n        if (shouldFlash) {\n            this.animateCell('highlight');\n        }\n    };\n    CellComp.prototype.setupColSpan = function () {\n        // if no col span is active, then we don't set it up, as it would be wasteful of CPU\n        if (utils_1._.missing(this.getComponentHolder().colSpan)) {\n            return;\n        }\n        // because we are col spanning, a reorder of the cols can change what cols we are spanning over\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));\n        // because we are spanning over multiple cols, we check for width any time any cols width changes.\n        // this is expensive - really we should be explicitly checking only the cols we are spanning over\n        // instead of every col, however it would be tricky code to track the cols we are spanning over, so\n        // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.\n        this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n        this.colsSpanning = this.getColSpanningList();\n    };\n    CellComp.prototype.getColSpanningList = function () {\n        var colSpan = this.column.getColSpan(this.rowNode);\n        var colsSpanning = [];\n        // if just one col, the col span is just the column we are in\n        if (colSpan === 1) {\n            colsSpanning.push(this.column);\n        }\n        else {\n            var pointer = this.column;\n            var pinned = this.column.getPinned();\n            for (var i = 0; pointer && i < colSpan; i++) {\n                colsSpanning.push(pointer);\n                pointer = this.beans.columnController.getDisplayedColAfter(pointer);\n                if (!pointer || utils_1._.missing(pointer)) {\n                    break;\n                }\n                // we do not allow col spanning to span outside of pinned areas\n                if (pinned !== pointer.getPinned()) {\n                    break;\n                }\n            }\n        }\n        return colsSpanning;\n    };\n    CellComp.prototype.onDisplayColumnsChanged = function () {\n        var colsSpanning = this.getColSpanningList();\n        if (!utils_1._.compareArrays(this.colsSpanning, colsSpanning)) {\n            this.colsSpanning = colsSpanning;\n            this.onWidthChanged();\n            this.onLeftChanged(); // left changes when doing RTL\n        }\n    };\n    CellComp.prototype.getInitialCssClasses = function () {\n        var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"];\n        // if we are putting the cell into a dummy container, to work out it's height,\n        // then we don't put the height css in, as we want cell to fit height in that case.\n        if (!this.autoHeightCell) {\n            cssClasses.push('ag-cell-with-height');\n        }\n        var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n        if (doingFocusCss && this.cellFocused) {\n            // otherwise the class depends on the focus state\n            cssClasses.push('ag-cell-focus');\n        }\n        if (this.firstRightPinned) {\n            cssClasses.push('ag-cell-first-right-pinned');\n        }\n        if (this.lastLeftPinned) {\n            cssClasses.push('ag-cell-last-left-pinned');\n        }\n        if (this.beans.columnHoverService.isHovered(this.column)) {\n            cssClasses.push('ag-column-hover');\n        }\n        utils_1._.pushAll(cssClasses, this.preProcessClassesFromColDef());\n        utils_1._.pushAll(cssClasses, this.preProcessCellClassRules());\n        utils_1._.pushAll(cssClasses, this.getInitialRangeClasses());\n        // if using the wrapper, this class goes on the wrapper instead\n        if (!this.usingWrapper) {\n            cssClasses.push('ag-cell-value');\n        }\n        return cssClasses;\n    };\n    CellComp.prototype.getInitialValueToRender = function () {\n        // if using a cellRenderer, then render the html from the cell renderer if it exists\n        if (this.usingCellRenderer) {\n            if (typeof this.cellRendererGui === 'string') {\n                return this.cellRendererGui;\n            }\n            else {\n                return '';\n            }\n        }\n        var colDef = this.getComponentHolder();\n        if (colDef.template) {\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n            return colDef.template;\n        }\n        else if (colDef.templateUrl) {\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n            if (template) {\n                return template;\n            }\n            else {\n                return '';\n            }\n        }\n        else {\n            return this.getValueToUse();\n        }\n    };\n    CellComp.prototype.getRenderedRow = function () {\n        return this.rowComp;\n    };\n    CellComp.prototype.isSuppressNavigable = function () {\n        return this.column.isSuppressNavigable(this.rowNode);\n    };\n    CellComp.prototype.getCellRenderer = function () {\n        return this.cellRenderer;\n    };\n    CellComp.prototype.getCellEditor = function () {\n        return this.cellEditor;\n    };\n    // + stop editing {forceRefresh: true, suppressFlash: true}\n    // + event cellChanged {}\n    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\n    // + rowComp: event dataChanged {animate: update, newData: !update}\n    // + rowComp: api refreshCells() {animate: true/false}\n    // + rowRenderer: api softRefreshView() {}\n    CellComp.prototype.refreshCell = function (params) {\n        // if we are in the middle of 'stopEditing', then we don't refresh here, as refresh gets called explicitly\n        if (this.suppressRefreshCell || this.editingCell) {\n            return;\n        }\n        var colDef = this.getComponentHolder();\n        var newData = params && params.newData;\n        var suppressFlash = (params && params.suppressFlash) || colDef.suppressCellFlash;\n        var forceRefresh = params && params.forceRefresh;\n        var oldValue = this.value;\n        this.getValueAndFormat();\n        // for simple values only (not pojo's), see if the value is the same, and if it is, skip the refresh.\n        // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\n        // if was before the edit.\n        var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\n        var dataNeedsUpdating = forceRefresh || valuesDifferent;\n        if (dataNeedsUpdating) {\n            // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\n            // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\n            // then we are not showing a movement in the stock price, rather we are showing different stock.\n            var cellRendererRefreshed = newData ? false : this.attemptCellRendererRefresh();\n            // we do the replace if not doing refresh, or if refresh was unsuccessful.\n            // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\n            // wrapper has the refresh method, but the underlying component doesn't\n            if (!cellRendererRefreshed) {\n                this.replaceContentsAfterRefresh();\n            }\n            // we don't want to flash the cells when processing a filter change, as otherwise the UI would\n            // be to busy. see comment in FilterManager with regards processingFilterChange\n            var processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();\n            var flashCell = !suppressFlash && !processingFilterChange &&\n                (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || colDef.enableCellChangeFlash);\n            if (flashCell) {\n                this.flashCell();\n            }\n            // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\n            this.postProcessStylesFromColDef();\n            this.postProcessClassesFromColDef();\n        }\n        // we can't readily determine if the data in an angularjs template has changed, so here we just update\n        // and recompile (if applicable)\n        this.updateAngular1ScopeAndCompile();\n        this.refreshToolTip();\n        // we do cellClassRules even if the value has not changed, so that users who have rules that\n        // look at other parts of the row (where the other part of the row might of changed) will work.\n        this.postProcessCellClassRules();\n    };\n    // user can also call this via API\n    CellComp.prototype.flashCell = function () {\n        this.animateCell('data-changed');\n    };\n    CellComp.prototype.animateCell = function (cssName) {\n        var fullName = 'ag-cell-' + cssName;\n        var animationFullName = 'ag-cell-' + cssName + '-animation';\n        var element = this.getGui();\n        // we want to highlight the cells, without any animation\n        utils_1._.addCssClass(element, fullName);\n        utils_1._.removeCssClass(element, animationFullName);\n        // then once that is applied, we remove the highlight with animation\n        window.setTimeout(function () {\n            utils_1._.removeCssClass(element, fullName);\n            utils_1._.addCssClass(element, animationFullName);\n            window.setTimeout(function () {\n                // and then to leave things as we got them, we remove the animation\n                utils_1._.removeCssClass(element, animationFullName);\n            }, 1000);\n        }, 500);\n    };\n    CellComp.prototype.replaceContentsAfterRefresh = function () {\n        // otherwise we rip out the cell and replace it\n        utils_1._.clearElement(this.eParentOfValue);\n        // remove old renderer component if it exists\n        if (this.cellRenderer && this.cellRenderer.destroy) {\n            this.cellRenderer.destroy();\n        }\n        this.cellRenderer = null;\n        this.cellRendererGui = null;\n        // populate\n        this.putDataIntoCellAfterRefresh();\n        this.updateAngular1ScopeAndCompile();\n    };\n    CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n            this.scope.data = __assign({}, this.rowNode.data);\n            this.angular1Compile();\n        }\n    };\n    CellComp.prototype.angular1Compile = function () {\n        // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\n            var eGui = this.getGui();\n            // only compile the node if it hasn't already been done\n            // this prevents \"orphaned\" node leaks\n            if (!eGui.classList.contains('ng-scope') || eGui.childElementCount === 0) {\n                var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\n                this.addDestroyFunc(function () {\n                    compiledElement_1.remove();\n                });\n            }\n        }\n    };\n    CellComp.prototype.postProcessStylesFromColDef = function () {\n        var stylesToUse = this.processStylesFromColDef();\n        if (stylesToUse) {\n            utils_1._.addStylesToElement(this.getGui(), stylesToUse);\n        }\n    };\n    CellComp.prototype.preProcessStylesFromColDef = function () {\n        var stylesToUse = this.processStylesFromColDef();\n        return utils_1._.cssStyleObjectToMarkup(stylesToUse);\n    };\n    CellComp.prototype.processStylesFromColDef = function () {\n        var colDef = this.getComponentHolder();\n        if (colDef.cellStyle) {\n            var cssToUse = void 0;\n            if (typeof colDef.cellStyle === 'function') {\n                var cellStyleParams = {\n                    value: this.value,\n                    data: this.rowNode.data,\n                    node: this.rowNode,\n                    colDef: colDef,\n                    column: this.column,\n                    $scope: this.scope,\n                    context: this.beans.gridOptionsWrapper.getContext(),\n                    api: this.beans.gridOptionsWrapper.getApi()\n                };\n                var cellStyleFunc = colDef.cellStyle;\n                cssToUse = cellStyleFunc(cellStyleParams);\n            }\n            else {\n                cssToUse = colDef.cellStyle;\n            }\n            return cssToUse;\n        }\n    };\n    CellComp.prototype.postProcessClassesFromColDef = function () {\n        var _this = this;\n        this.processClassesFromColDef(function (className) { return utils_1._.addCssClass(_this.getGui(), className); });\n    };\n    CellComp.prototype.preProcessClassesFromColDef = function () {\n        var res = [];\n        this.processClassesFromColDef(function (className) { return res.push(className); });\n        return res;\n    };\n    CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\n        var colDef = this.getComponentHolder();\n        this.beans.stylingService.processStaticCellClasses(colDef, {\n            value: this.value,\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: colDef,\n            rowIndex: this.rowNode.rowIndex,\n            $scope: this.scope,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext()\n        }, onApplicableClass);\n    };\n    CellComp.prototype.putDataIntoCellAfterRefresh = function () {\n        // template gets preference, then cellRenderer, then do it ourselves\n        var colDef = this.getComponentHolder();\n        if (colDef.template) {\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n            this.eParentOfValue.innerHTML = colDef.template;\n        }\n        else if (colDef.templateUrl) {\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n            if (template) {\n                this.eParentOfValue.innerHTML = template;\n            }\n        }\n        else {\n            // we can switch from using a cell renderer back to the default if a user\n            // is using cellRendererSelect\n            this.chooseCellRenderer();\n            if (this.usingCellRenderer) {\n                this.createCellRendererInstance();\n            }\n            else {\n                var valueToUse = this.getValueToUse();\n                if (valueToUse !== null && valueToUse !== undefined) {\n                    this.eParentOfValue.innerHTML = utils_1._.escape(valueToUse);\n                }\n            }\n        }\n    };\n    CellComp.prototype.attemptCellRendererRefresh = function () {\n        if (utils_1._.missing(this.cellRenderer) || !this.cellRenderer || utils_1._.missing(this.cellRenderer.refresh)) {\n            return false;\n        }\n        // if the cell renderer has a refresh method, we call this instead of doing a refresh\n        var params = this.createCellRendererParams();\n        // take any custom params off of the user\n        var finalParams = this.beans.userComponentFactory.createFinalParams(this.getComponentHolder(), this.cellRendererType, params);\n        var result = this.cellRenderer.refresh(finalParams);\n        // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n        // returned nothing, if the method existed, we assumed it refreshed. so for\n        // backwards compatibility, we assume if method exists and returns nothing,\n        // that it was successful.\n        return result === true || result === undefined;\n    };\n    CellComp.prototype.refreshToolTip = function () {\n        var newTooltip = this.getToolTip();\n        if (this.tooltip === newTooltip) {\n            return;\n        }\n        var hasNewTooltip = utils_1._.exists(newTooltip);\n        var hadTooltip = utils_1._.exists(this.tooltip);\n        if (hasNewTooltip && this.tooltip === newTooltip.toString()) {\n            return;\n        }\n        this.tooltip = newTooltip;\n        if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n            if (hasNewTooltip) {\n                var tooltipSanitised = utils_1._.escape(this.tooltip);\n                this.eParentOfValue.setAttribute('title', tooltipSanitised);\n            }\n            else {\n                this.eParentOfValue.removeAttribute('title');\n            }\n        }\n        else {\n            if (hadTooltip) {\n                if (!hasNewTooltip) {\n                    this.beans.tooltipManager.unregisterTooltip(this);\n                }\n            }\n            else if (hasNewTooltip) {\n                this.beans.tooltipManager.registerTooltip(this);\n            }\n        }\n    };\n    CellComp.prototype.valuesAreEqual = function (val1, val2) {\n        // if the user provided an equals method, use that, otherwise do simple comparison\n        var colDef = this.getComponentHolder();\n        var equalsMethod = colDef ? colDef.equals : null;\n        if (equalsMethod) {\n            return equalsMethod(val1, val2);\n        }\n        return val1 === val2;\n    };\n    CellComp.prototype.getToolTip = function () {\n        var colDef = this.getComponentHolder();\n        var data = this.rowNode.data;\n        if (colDef.tooltipField && utils_1._.exists(data)) {\n            return utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\n        }\n        var valueGetter = colDef.tooltipValueGetter || colDef.tooltip;\n        if (valueGetter) {\n            return valueGetter({\n                api: this.beans.gridOptionsWrapper.getApi(),\n                columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n                colDef: colDef,\n                column: this.getColumn(),\n                context: this.beans.gridOptionsWrapper.getContext(),\n                value: this.value,\n                valueFormatted: this.valueFormatted,\n                rowIndex: this.cellPosition.rowIndex,\n                node: this.rowNode,\n                data: this.rowNode.data,\n                $scope: this.scope,\n            });\n        }\n        return null;\n    };\n    CellComp.prototype.getTooltipText = function (escape) {\n        if (escape === void 0) { escape = true; }\n        return escape ? utils_1._.escape(this.tooltip) : this.tooltip;\n    };\n    CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\n        var colDef = this.getComponentHolder();\n        this.beans.stylingService.processClassRules(colDef.cellClassRules, {\n            value: this.value,\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: colDef,\n            rowIndex: this.cellPosition.rowIndex,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            $scope: this.scope,\n            context: this.beans.gridOptionsWrapper.getContext()\n        }, onApplicableClass, onNotApplicableClass);\n    };\n    CellComp.prototype.postProcessCellClassRules = function () {\n        var _this = this;\n        this.processCellClassRules(function (className) {\n            utils_1._.addCssClass(_this.getGui(), className);\n        }, function (className) {\n            utils_1._.removeCssClass(_this.getGui(), className);\n        });\n    };\n    CellComp.prototype.preProcessCellClassRules = function () {\n        var res = [];\n        this.processCellClassRules(function (className) {\n            res.push(className);\n        }, function (className) {\n            // not catered for, if creating, no need\n            // to remove class as it was never there\n        });\n        return res;\n    };\n    // a wrapper is used when we are putting a selection checkbox in the cell with the value\n    CellComp.prototype.setUsingWrapper = function () {\n        var colDef = this.getComponentHolder();\n        // never allow selection or dragging on pinned rows\n        if (this.rowNode.rowPinned) {\n            this.usingWrapper = false;\n            this.includeSelectionComponent = false;\n            this.includeRowDraggingComponent = false;\n            this.includeDndSourceComponent = false;\n            return;\n        }\n        var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\n        var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\n        var dndSourceIsFunc = typeof colDef.dndSource === 'function';\n        this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\n        this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\n        this.includeDndSourceComponent = dndSourceIsFunc || colDef.dndSource === true;\n        this.usingWrapper = this.includeRowDraggingComponent || this.includeSelectionComponent || this.includeDndSourceComponent;\n    };\n    CellComp.prototype.chooseCellRenderer = function () {\n        // template gets preference, then cellRenderer, then do it ourselves\n        var colDef = this.getComponentHolder();\n        // templates are for ng1, ideally we wouldn't have these, they are ng1 support\n        // inside the core which is bad\n        if (colDef.template || colDef.templateUrl) {\n            this.usingCellRenderer = false;\n            return;\n        }\n        var params = this.createCellRendererParams();\n        var cellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'cellRenderer', params);\n        var pinnedRowCellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'pinnedRowCellRenderer', params);\n        if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\n            this.cellRendererType = CellComp.CELL_RENDERER_TYPE_PINNED;\n            this.usingCellRenderer = true;\n        }\n        else if (cellRenderer) {\n            this.cellRendererType = CellComp.CELL_RENDERER_TYPE_NORMAL;\n            this.usingCellRenderer = true;\n        }\n        else {\n            this.usingCellRenderer = false;\n        }\n    };\n    CellComp.prototype.createCellRendererInstance = function (useTaskService) {\n        var _this = this;\n        if (useTaskService === void 0) { useTaskService = false; }\n        if (!this.usingCellRenderer) {\n            return;\n        }\n        // never use task service if angularCompileRows=true, as that assume the cell renderers\n        // are finished when the row is created. also we never use it if animation frame service\n        // is turned off.\n        // and lastly we never use it if doing auto-height, as the auto-height service checks the\n        // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n        var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n        var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n        if (angularCompileRows || suppressAnimationFrame || this.autoHeightCell) {\n            useTaskService = false;\n        }\n        var params = this.createCellRendererParams();\n        this.cellRendererVersion++;\n        var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\n        var cellRendererTypeNormal = this.cellRendererType === CellComp.CELL_RENDERER_TYPE_NORMAL;\n        var task = function () {\n            // this can return null in the event that the user has switched from a renderer component to nothing, for example\n            // when using a cellRendererSelect to return a component or null depending on row data etc\n            var componentPromise;\n            if (cellRendererTypeNormal) {\n                componentPromise = _this.beans.userComponentFactory.newCellRenderer(_this.getComponentHolder(), params);\n            }\n            else {\n                componentPromise = _this.beans.userComponentFactory.newPinnedRowCellRenderer(_this.getComponentHolder(), params);\n            }\n            if (componentPromise) {\n                componentPromise.then(callback);\n            }\n        };\n        if (useTaskService) {\n            this.beans.taskQueue.addP2Task(task);\n        }\n        else {\n            task();\n        }\n    };\n    CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\n        // see if daemon\n        if (!this.isAlive() || (cellRendererVersion !== this.cellRendererVersion)) {\n            if (cellRenderer.destroy) {\n                cellRenderer.destroy();\n            }\n            return;\n        }\n        this.cellRenderer = cellRenderer;\n        this.cellRendererGui = this.cellRenderer.getGui();\n        if (utils_1._.missing(this.cellRendererGui)) {\n            return;\n        }\n        // if async components, then it's possible the user started editing since\n        // this call was made\n        if (!this.editingCell) {\n            this.eParentOfValue.appendChild(this.cellRendererGui);\n        }\n    };\n    CellComp.prototype.createCellRendererParams = function () {\n        var _this = this;\n        var params = {\n            value: this.value,\n            valueFormatted: this.valueFormatted,\n            getValue: this.getValue.bind(this),\n            setValue: function (value) {\n                _this.beans.valueService.setValue(_this.rowNode, _this.column, value);\n            },\n            formatValue: this.formatValue.bind(this),\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: this.getComponentHolder(),\n            column: this.column,\n            $scope: this.scope,\n            rowIndex: this.cellPosition.rowIndex,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            refreshCell: this.refreshCell.bind(this),\n            eGridCell: this.getGui(),\n            eParentOfValue: this.eParentOfValue,\n            // these bits are not documented anywhere, so we could drop them?\n            // it was in the olden days to allow user to register for when rendered\n            // row was removed (the row comp was removed), however now that the user\n            // can provide components for cells, the destroy method gets call when this\n            // happens so no longer need to fire event.\n            addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\n            addRenderedRowListener: function (eventType, listener) {\n                console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\n                if (_this.rowComp) {\n                    _this.rowComp.addEventListener(eventType, listener);\n                }\n            }\n        };\n        return params;\n    };\n    CellComp.prototype.formatValue = function (value) {\n        var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\n        var valueFormattedExists = valueFormatted !== null && valueFormatted !== undefined;\n        return valueFormattedExists ? valueFormatted : value;\n    };\n    CellComp.prototype.getValueToUse = function () {\n        var valueFormattedExists = this.valueFormatted !== null && this.valueFormatted !== undefined;\n        return valueFormattedExists ? this.valueFormatted : this.value;\n    };\n    CellComp.prototype.getValueAndFormat = function () {\n        this.value = this.getValue();\n        this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n    };\n    CellComp.prototype.getValue = function () {\n        // if we don't check this, then the grid will render leaf groups as open even if we are not\n        // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\n        // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\n        // them via the API, or user user expanded them in the UI before turning on pivot mode\n        var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\n        var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup;\n        // are we showing group footers\n        var groupFootersEnabled = this.beans.gridOptionsWrapper.isGroupIncludeFooter();\n        // if doing footers, we normally don't show agg data at group level when group is open\n        var groupAlwaysShowAggData = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader();\n        // if doing grouping and footers, we don't want to include the agg value\n        // in the header when the group is open\n        var ignoreAggData = (isOpenGroup && groupFootersEnabled) && !groupAlwaysShowAggData;\n        return this.beans.valueService.getValue(this.column, this.rowNode, false, ignoreAggData);\n    };\n    CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\n        if (utils_1._.isStopPropagationForAgGrid(mouseEvent)) {\n            return;\n        }\n        switch (eventName) {\n            case 'click':\n                this.onCellClicked(mouseEvent);\n                break;\n            case 'mousedown':\n                this.onMouseDown(mouseEvent);\n                break;\n            case 'dblclick':\n                this.onCellDoubleClicked(mouseEvent);\n                break;\n            case 'mouseout':\n                this.onMouseOut(mouseEvent);\n                break;\n            case 'mouseover':\n                this.onMouseOver(mouseEvent);\n                break;\n        }\n    };\n    CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\n        var colDef = this.getComponentHolder();\n        var cellContextMenuEvent = this.createEvent(event, events_1.Events.EVENT_CELL_CONTEXT_MENU);\n        this.beans.eventService.dispatchEvent(cellContextMenuEvent);\n        if (colDef.onCellContextMenu) {\n            // to make the callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellContextMenu(cellContextMenuEvent); }, 0);\n        }\n    };\n    CellComp.prototype.createEvent = function (domEvent, eventType) {\n        var event = {\n            node: this.rowNode,\n            data: this.rowNode.data,\n            value: this.value,\n            column: this.column,\n            colDef: this.getComponentHolder(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            api: this.beans.gridApi,\n            columnApi: this.beans.columnApi,\n            rowPinned: this.rowNode.rowPinned,\n            event: domEvent,\n            type: eventType,\n            rowIndex: this.rowNode.rowIndex\n        };\n        // because we are hacking in $scope for angular 1, we have to de-reference\n        if (this.scope) {\n            event.$scope = this.scope;\n        }\n        return event;\n    };\n    CellComp.prototype.onMouseOut = function (mouseEvent) {\n        var cellMouseOutEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OUT);\n        this.beans.eventService.dispatchEvent(cellMouseOutEvent);\n        this.beans.columnHoverService.clearMouseOver();\n    };\n    CellComp.prototype.onMouseOver = function (mouseEvent) {\n        var cellMouseOverEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OVER);\n        this.beans.eventService.dispatchEvent(cellMouseOverEvent);\n        this.beans.columnHoverService.setMouseOver([this.column]);\n    };\n    CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\n        var colDef = this.getComponentHolder();\n        // always dispatch event to eventService\n        var cellDoubleClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_DOUBLE_CLICKED);\n        this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);\n        // check if colDef also wants to handle event\n        if (typeof colDef.onCellDoubleClicked === 'function') {\n            // to make the callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellDoubleClicked(cellDoubleClickedEvent); }, 0);\n        }\n        var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit()\n            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n        if (editOnDoubleClick) {\n            this.startRowOrCellEdit();\n        }\n    };\n    // called by rowRenderer when user navigates via tab key\n    CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n            this.rowComp.startRowEditing(keyPress, charPress, this);\n        }\n        else {\n            this.startEditingIfEnabled(keyPress, charPress, true);\n        }\n    };\n    CellComp.prototype.isCellEditable = function () {\n        return this.column.isCellEditable(this.rowNode);\n    };\n    // either called internally if single cell editing, or called by rowRenderer if row editing\n    CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\n        if (keyPress === void 0) { keyPress = null; }\n        if (charPress === void 0) { charPress = null; }\n        if (cellStartedEdit === void 0) { cellStartedEdit = false; }\n        // don't do it if not editable\n        if (!this.isCellEditable()) {\n            return;\n        }\n        // don't do it if already editing\n        if (this.editingCell) {\n            return;\n        }\n        this.editingCell = true;\n        this.cellEditorVersion++;\n        var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\n        var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\n        this.createCellEditor(params).then(callback);\n        // if we don't do this, and editor component is async, then there will be a period\n        // when the component isn't present and keyboard navigation won't work - so example\n        // of user hitting tab quickly (more quickly than renderers getting created) won't work\n        var cellEditorAsync = utils_1._.missing(this.cellEditor);\n        if (cellEditorAsync && cellStartedEdit) {\n            this.focusCell(true);\n        }\n    };\n    CellComp.prototype.createCellEditor = function (params) {\n        var _this = this;\n        var cellEditorPromise = this.beans.userComponentFactory.newCellEditor(this.column.getColDef(), params);\n        return cellEditorPromise.map(function (cellEditor) {\n            var isPopup = cellEditor.isPopup && cellEditor.isPopup();\n            if (!isPopup) {\n                return cellEditor;\n            }\n            if (_this.beans.gridOptionsWrapper.isFullRowEdit()) {\n                console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' +\n                    '- either turn off fullRowEdit, or stop using popup editors.');\n            }\n            // if a popup, then we wrap in a popup editor and return the popup\n            var popupEditorWrapper = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);\n            _this.beans.context.wireBean(popupEditorWrapper);\n            popupEditorWrapper.init(params);\n            return popupEditorWrapper;\n        });\n    };\n    CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\n        // if editingCell=false, means user cancelled the editor before component was ready.\n        // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n        //   is the first editor which is now stale.\n        var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\n        if (versionMismatch || !this.editingCell) {\n            if (cellEditor.destroy) {\n                cellEditor.destroy();\n            }\n            return;\n        }\n        if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {\n            if (cellEditor.destroy) {\n                cellEditor.destroy();\n            }\n            this.editingCell = false;\n            return;\n        }\n        if (!cellEditor.getGui) {\n            console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\");\n            // no getGui, for React guys, see if they attached a react component directly\n            if (cellEditor.render) {\n                console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\n            }\n            if (cellEditor.destroy) {\n                cellEditor.destroy();\n            }\n            this.editingCell = false;\n            return;\n        }\n        this.cellEditor = cellEditor;\n        this.cellEditorInPopup = cellEditor.isPopup !== undefined && cellEditor.isPopup();\n        this.setInlineEditingClass();\n        if (this.cellEditorInPopup) {\n            this.addPopupCellEditor();\n        }\n        else {\n            this.addInCellEditor();\n        }\n        if (cellEditor.afterGuiAttached) {\n            cellEditor.afterGuiAttached();\n        }\n        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STARTED);\n        this.beans.eventService.dispatchEvent(event);\n    };\n    CellComp.prototype.addInCellEditor = function () {\n        utils_1._.clearElement(this.getGui());\n        if (this.cellEditor) {\n            this.getGui().appendChild(this.cellEditor.getGui());\n        }\n        this.angular1Compile();\n    };\n    CellComp.prototype.addPopupCellEditor = function () {\n        var _this = this;\n        var ePopupGui = this.cellEditor ? this.cellEditor.getGui() : null;\n        this.hideEditorPopup = this.beans.popupService.addAsModalPopup(ePopupGui, true, \n        // callback for when popup disappears\n        function () {\n            _this.onPopupEditorClosed();\n        });\n        this.beans.popupService.positionPopupOverComponent({\n            column: this.column,\n            rowNode: this.rowNode,\n            type: 'popupCellEditor',\n            eventSource: this.getGui(),\n            ePopup: ePopupGui,\n            keepWithinBounds: true\n        });\n        this.angular1Compile();\n    };\n    CellComp.prototype.onPopupEditorClosed = function () {\n        // we only call stopEditing if we are editing, as\n        // it's possible the popup called 'stop editing'\n        // before this, eg if 'enter key' was pressed on\n        // the editor.\n        if (this.editingCell) {\n            // note: this only happens when use clicks outside of the grid. if use clicks on another\n            // cell, then the editing will have already stopped on this cell\n            this.stopRowOrCellEdit();\n            // we only focus cell again if this cell is still focused. it is possible\n            // it is not focused if the user cancelled the edit by clicking on another\n            // cell outside of this one\n            if (this.beans.focusedCellController.isCellFocused(this.cellPosition)) {\n                this.focusCell(true);\n            }\n        }\n    };\n    // if we are editing inline, then we don't have the padding in the cell (set in the themes)\n    // to allow the text editor full access to the entire cell\n    CellComp.prototype.setInlineEditingClass = function () {\n        // ag-cell-inline-editing - appears when user is inline editing\n        // ag-cell-not-inline-editing - appears when user is no inline editing\n        // ag-cell-popup-editing - appears when user is editing cell in popup (appears on the cell, not on the popup)\n        // note: one of {ag-cell-inline-editing, ag-cell-not-inline-editing} is always present, they toggle.\n        //       however {ag-cell-popup-editing} shows when popup, so you have both {ag-cell-popup-editing}\n        //       and {ag-cell-not-inline-editing} showing at the same time.\n        var editingInline = this.editingCell && !this.cellEditorInPopup;\n        var popupEditorShowing = this.editingCell && this.cellEditorInPopup;\n        utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-inline-editing\", editingInline);\n        utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-not-inline-editing\", !editingInline);\n        utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-popup-editing\", popupEditorShowing);\n        utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-inline-editing\", editingInline);\n        utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-not-inline-editing\", !editingInline);\n    };\n    CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\n        var params = {\n            value: this.getValue(),\n            keyPress: keyPress,\n            charPress: charPress,\n            column: this.column,\n            colDef: this.column.getColDef(),\n            rowIndex: this.cellPosition.rowIndex,\n            node: this.rowNode,\n            data: this.rowNode.data,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            cellStartedEdit: cellStartedEdit,\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            $scope: this.scope,\n            onKeyDown: this.onKeyDown.bind(this),\n            stopEditing: this.stopEditingAndFocus.bind(this),\n            eGridCell: this.getGui(),\n            parseValue: this.parseValue.bind(this),\n            formatValue: this.formatValue.bind(this)\n        };\n        return params;\n    };\n    // cell editors call this, when they want to stop for reasons other\n    // than what we pick up on. eg selecting from a dropdown ends editing.\n    CellComp.prototype.stopEditingAndFocus = function (suppressNavigateAfterEdit) {\n        if (suppressNavigateAfterEdit === void 0) { suppressNavigateAfterEdit = false; }\n        this.stopRowOrCellEdit();\n        this.focusCell(true);\n        if (!suppressNavigateAfterEdit) {\n            this.navigateAfterEdit();\n        }\n    };\n    CellComp.prototype.parseValue = function (newValue) {\n        var colDef = this.getComponentHolder();\n        var params = {\n            node: this.rowNode,\n            data: this.rowNode.data,\n            oldValue: this.value,\n            newValue: newValue,\n            colDef: colDef,\n            column: this.column,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext()\n        };\n        var valueParser = colDef.valueParser;\n        return utils_1._.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\n    };\n    CellComp.prototype.focusCell = function (forceBrowserFocus) {\n        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }\n        this.beans.focusedCellController.setFocusedCell(this.cellPosition.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\n    };\n    CellComp.prototype.setFocusInOnEditor = function () {\n        if (this.editingCell) {\n            if (this.cellEditor && this.cellEditor.focusIn) {\n                // if the editor is present, then we just focus it\n                this.cellEditor.focusIn();\n            }\n            else {\n                // if the editor is not present, it means async cell editor (eg React fibre)\n                // and we are trying to set focus before the cell editor is present, so we\n                // focus the cell instead\n                this.focusCell(true);\n            }\n        }\n    };\n    CellComp.prototype.isEditing = function () {\n        return this.editingCell;\n    };\n    CellComp.prototype.onKeyDown = function (event) {\n        var key = event.which || event.keyCode;\n        switch (key) {\n            case constants_1.Constants.KEY_ENTER:\n                this.onEnterKeyDown();\n                break;\n            case constants_1.Constants.KEY_F2:\n                this.onF2KeyDown();\n                break;\n            case constants_1.Constants.KEY_ESCAPE:\n                this.onEscapeKeyDown();\n                break;\n            case constants_1.Constants.KEY_TAB:\n                this.onTabKeyDown(event);\n                break;\n            case constants_1.Constants.KEY_BACKSPACE:\n            case constants_1.Constants.KEY_DELETE:\n                this.onBackspaceOrDeleteKeyPressed(key);\n                break;\n            case constants_1.Constants.KEY_DOWN:\n            case constants_1.Constants.KEY_UP:\n            case constants_1.Constants.KEY_RIGHT:\n            case constants_1.Constants.KEY_LEFT:\n                this.onNavigationKeyPressed(event, key);\n                break;\n        }\n    };\n    CellComp.prototype.setFocusOutOnEditor = function () {\n        if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\n            this.cellEditor.focusOut();\n        }\n    };\n    CellComp.prototype.onNavigationKeyPressed = function (event, key) {\n        if (this.editingCell) {\n            return;\n        }\n        if (event.shiftKey && this.rangeSelectionEnabled) {\n            this.onShiftRangeSelect(key);\n        }\n        else {\n            this.beans.rowRenderer.navigateToNextCell(event, key, this.cellPosition, true);\n        }\n        // if we don't prevent default, the grid will scroll with the navigation keys\n        event.preventDefault();\n    };\n    CellComp.prototype.onShiftRangeSelect = function (key) {\n        var endCell = this.beans.rangeController.extendLatestRangeInDirection(key);\n        if (endCell) {\n            this.beans.rowRenderer.ensureCellVisible(endCell);\n        }\n    };\n    CellComp.prototype.onTabKeyDown = function (event) {\n        this.beans.rowRenderer.onTabKeyDown(this, event);\n    };\n    CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\n        if (!this.editingCell) {\n            this.startRowOrCellEdit(key);\n        }\n    };\n    CellComp.prototype.onEnterKeyDown = function () {\n        if (this.editingCell || this.rowComp.isEditing()) {\n            this.stopEditingAndFocus();\n        }\n        else {\n            if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\n                this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.cellPosition, false);\n            }\n            else {\n                this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);\n            }\n        }\n    };\n    CellComp.prototype.navigateAfterEdit = function () {\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n        if (fullRowEdit) {\n            return;\n        }\n        var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\n        if (enterMovesDownAfterEdit) {\n            this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.cellPosition, false);\n        }\n    };\n    CellComp.prototype.onF2KeyDown = function () {\n        if (!this.editingCell) {\n            this.startRowOrCellEdit(constants_1.Constants.KEY_F2);\n        }\n    };\n    CellComp.prototype.onEscapeKeyDown = function () {\n        if (this.editingCell) {\n            this.stopRowOrCellEdit(true);\n            this.focusCell(true);\n        }\n    };\n    CellComp.prototype.onKeyPress = function (event) {\n        // check this, in case focus is on a (for example) a text field inside the cell,\n        // in which cse we should not be listening for these key pressed\n        var eventTarget = utils_1._.getTarget(event);\n        var eventOnChildComponent = eventTarget !== this.getGui();\n        if (eventOnChildComponent || this.editingCell) {\n            return;\n        }\n        var pressedChar = String.fromCharCode(event.charCode);\n        if (pressedChar === ' ') {\n            this.onSpaceKeyPressed(event);\n        }\n        else {\n            if (utils_1._.isEventFromPrintableCharacter(event)) {\n                this.startRowOrCellEdit(null, pressedChar);\n                // if we don't prevent default, then the keypress also gets applied to the text field\n                // (at least when doing the default editor), but we need to allow the editor to decide\n                // what it wants to do. we only do this IF editing was started - otherwise it messes\n                // up when the use is not doing editing, but using rendering with text fields in cellRenderer\n                // (as it would block the the user from typing into text fields).\n                event.preventDefault();\n            }\n        }\n    };\n    CellComp.prototype.onSpaceKeyPressed = function (event) {\n        if (!this.editingCell && this.beans.gridOptionsWrapper.isRowSelection()) {\n            var selected = this.rowNode.isSelected();\n            this.rowNode.setSelected(!selected);\n        }\n        // prevent default as space key, by default, moves browser scroll down\n        event.preventDefault();\n    };\n    CellComp.prototype.onMouseDown = function (mouseEvent) {\n        // we only need to pass true to focusCell in when the browser is IE\n        // and we are trying to focus a cell (has ag-cell class), otherwise\n        // we pass false, as we don't want the cell to focus also get the browser\n        // focus. if we did, then the cellRenderer could have a text field in it,\n        // for example, and as the user clicks on the text field, the text field,\n        // the focus doesn't get to the text field, instead to goes to the div\n        // behind, making it impossible to select the text field.\n        var forceBrowserFocus = false;\n        var button = mouseEvent.button, ctrlKey = mouseEvent.ctrlKey, metaKey = mouseEvent.metaKey, shiftKey = mouseEvent.shiftKey, target = mouseEvent.target;\n        var _a = this.beans, eventService = _a.eventService, rangeController = _a.rangeController;\n        if (rangeController) {\n            var cellInRange = rangeController.isCellInAnyRange(this.getCellPosition());\n            if (cellInRange && button === 2) {\n                return;\n            }\n        }\n        if (utils_1._.isBrowserIE()) {\n            if (target.classList.contains('ag-cell')) {\n                forceBrowserFocus = true;\n            }\n        }\n        if (!shiftKey || (rangeController && !rangeController.getCellRanges().length)) {\n            this.focusCell(forceBrowserFocus);\n        }\n        else {\n            // if a range is being changed, we need to make sure the focused cell does not change.\n            mouseEvent.preventDefault();\n        }\n        // if we are clicking on a checkbox, we need to make sure the cell wrapping that checkbox\n        // is focused but we don't want to change the range selection, so return here.\n        if (utils_1._.isElementChildOfClass(target, 'ag-selection-checkbox', 3)) {\n            return;\n        }\n        // if it's a right click, then if the cell is already in range,\n        // don't change the range, however if the cell is not in a range,\n        // we set a new range\n        var leftMouseButtonClick = utils_1._.isLeftClick(mouseEvent);\n        if (leftMouseButtonClick && rangeController) {\n            var thisCell = this.cellPosition;\n            if (shiftKey) {\n                rangeController.extendLatestRangeToCell(thisCell);\n            }\n            else {\n                var ctrlKeyPressed = ctrlKey || metaKey;\n                rangeController.setRangeToCell(thisCell, ctrlKeyPressed);\n            }\n        }\n        var cellMouseDownEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_DOWN);\n        eventService.dispatchEvent(cellMouseDownEvent);\n    };\n    // returns true if on iPad and this is second 'click' event in 200ms\n    CellComp.prototype.isDoubleClickOnIPad = function () {\n        if (!utils_1._.isUserAgentIPad()) {\n            return false;\n        }\n        var nowMillis = new Date().getTime();\n        var res = nowMillis - this.lastIPadMouseClickEvent < 200;\n        this.lastIPadMouseClickEvent = nowMillis;\n        return res;\n    };\n    CellComp.prototype.onCellClicked = function (mouseEvent) {\n        // iPad doesn't have double click - so we need to mimic it do enable editing for\n        // iPad.\n        if (this.isDoubleClickOnIPad()) {\n            this.onCellDoubleClicked(mouseEvent);\n            mouseEvent.preventDefault(); // if we don't do this, then iPad zooms in\n            return;\n        }\n        var cellClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CLICKED);\n        this.beans.eventService.dispatchEvent(cellClickedEvent);\n        var colDef = this.getComponentHolder();\n        if (colDef.onCellClicked) {\n            // to make callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellClicked(cellClickedEvent); }, 0);\n        }\n        var editOnSingleClick = (this.beans.gridOptionsWrapper.isSingleClickEdit() || colDef.singleClickEdit)\n            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n        if (editOnSingleClick) {\n            this.startRowOrCellEdit();\n        }\n        utils_1._.doIeFocusHack(this.getGui());\n    };\n    CellComp.prototype.createGridCellVo = function () {\n        this.cellPosition = {\n            rowIndex: this.rowNode.rowIndex,\n            rowPinned: this.rowNode.rowPinned,\n            column: this.column\n        };\n    };\n    CellComp.prototype.getCellPosition = function () {\n        return this.cellPosition;\n    };\n    CellComp.prototype.getParentRow = function () {\n        return this.eParentRow;\n    };\n    CellComp.prototype.setParentRow = function (eParentRow) {\n        this.eParentRow = eParentRow;\n    };\n    CellComp.prototype.getColumn = function () {\n        return this.column;\n    };\n    CellComp.prototype.getComponentHolder = function () {\n        return this.column.getColDef();\n    };\n    CellComp.prototype.detach = function () {\n        this.eParentRow.removeChild(this.getGui());\n    };\n    // if the row is also getting destroyed, then we don't need to remove from dom,\n    // as the row will also get removed, so no need to take out the cells from the row\n    // if the row is going (removing is an expensive operation, so only need to remove\n    // the top part)\n    CellComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.cellEditor && this.cellEditor.destroy) {\n            this.cellEditor.destroy();\n            this.cellEditor = null;\n        }\n        if (this.cellRenderer && this.cellRenderer.destroy) {\n            this.cellRenderer.destroy();\n            this.cellRenderer = null;\n        }\n        if (this.selectionHandle) {\n            this.selectionHandle.destroy();\n        }\n    };\n    CellComp.prototype.onLeftChanged = function () {\n        var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n        this.getGui().style.left = left + 'px';\n    };\n    CellComp.prototype.modifyLeftForPrintLayout = function (leftPosition) {\n        if (!this.printLayout) {\n            return leftPosition;\n        }\n        if (this.column.getPinned() === column_1.Column.PINNED_LEFT) {\n            return leftPosition;\n        }\n        if (this.column.getPinned() === column_1.Column.PINNED_RIGHT) {\n            var leftWidth_1 = this.beans.columnController.getPinnedLeftContainerWidth();\n            var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n            return leftWidth_1 + bodyWidth + leftPosition;\n        }\n        // is in body\n        var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n        return leftWidth + leftPosition;\n    };\n    CellComp.prototype.onWidthChanged = function () {\n        var width = this.getCellWidth();\n        this.getGui().style.width = width + 'px';\n    };\n    CellComp.prototype.getRangeBorders = function () {\n        var _this = this;\n        var isRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n        var top = false;\n        var right = false;\n        var bottom = false;\n        var left = false;\n        var thisCol = this.cellPosition.column;\n        var rangeController = this.beans.rangeController;\n        var leftCol;\n        var rightCol;\n        if (isRtl) {\n            leftCol = this.beans.columnController.getDisplayedColAfter(thisCol);\n            rightCol = this.beans.columnController.getDisplayedColBefore(thisCol);\n        }\n        else {\n            leftCol = this.beans.columnController.getDisplayedColBefore(thisCol);\n            rightCol = this.beans.columnController.getDisplayedColAfter(thisCol);\n        }\n        var ranges = rangeController.getCellRanges().filter(function (range) { return rangeController.isCellInSpecificRange(_this.cellPosition, range); });\n        // this means we are the first column in the grid\n        if (!leftCol) {\n            left = true;\n        }\n        // this means we are the last column in the grid\n        if (!rightCol) {\n            right = true;\n        }\n        for (var i = 0; i < ranges.length; i++) {\n            if (top && right && bottom && left) {\n                break;\n            }\n            var range = ranges[i];\n            var startRow = rangeController.getRangeStartRow(range);\n            var endRow = rangeController.getRangeEndRow(range);\n            if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellPosition)) {\n                top = true;\n            }\n            if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellPosition)) {\n                bottom = true;\n            }\n            if (!left && range.columns.indexOf(leftCol) < 0) {\n                left = true;\n            }\n            if (!right && range.columns.indexOf(rightCol) < 0) {\n                right = true;\n            }\n        }\n        return { top: top, right: right, bottom: bottom, left: left };\n    };\n    CellComp.prototype.getInitialRangeClasses = function () {\n        var res = [];\n        if (!this.rangeSelectionEnabled || !this.rangeCount) {\n            return res;\n        }\n        var beans = this.beans;\n        var rangeController = beans.rangeController;\n        res.push('ag-cell-range-selected');\n        if (this.hasChartRange) {\n            res.push('ag-cell-range-chart');\n        }\n        var count = Math.min(this.rangeCount, 4);\n        res.push(\"ag-cell-range-selected-\" + count);\n        if (this.rangeCount === 1 && !rangeController.isMoreThanOneCell()) {\n            res.push('ag-cell-range-single-cell');\n        }\n        if (this.rangeCount > 0) {\n            var borders = this.getRangeBorders();\n            if (borders.top) {\n                res.push('ag-cell-range-top');\n            }\n            if (borders.right) {\n                res.push('ag-cell-range-right');\n            }\n            if (borders.bottom) {\n                res.push('ag-cell-range-bottom');\n            }\n            if (borders.left) {\n                res.push('ag-cell-range-left');\n            }\n        }\n        if (!!this.selectionHandle) {\n            res.push('ag-cell-range-handle');\n        }\n        return res;\n    };\n    CellComp.prototype.onRowIndexChanged = function () {\n        // when index changes, this influences items that need the index, so we update the\n        // grid cell so they are working off the new index.\n        this.createGridCellVo();\n        // when the index of the row changes, ie means the cell may have lost or gained focus\n        this.onCellFocused();\n        // check range selection\n        this.onRangeSelectionChanged();\n    };\n    CellComp.prototype.onRangeSelectionChanged = function () {\n        if (!this.beans.enterprise) {\n            return;\n        }\n        var _a = this, beans = _a.beans, cellPosition = _a.cellPosition, rangeCount = _a.rangeCount;\n        var rangeController = beans.rangeController;\n        var newRangeCount = rangeController.getCellRangeCount(cellPosition);\n        var element = this.getGui();\n        if (rangeCount !== newRangeCount) {\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\n            this.rangeCount = newRangeCount;\n        }\n        var hasChartRange = this.rangeCount && rangeController.getCellRanges().every(function (range) { return utils_1._.exists(range.type); });\n        if (this.hasChartRange !== hasChartRange) {\n            utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-chart', hasChartRange);\n            this.hasChartRange = hasChartRange;\n        }\n        this.updateRangeBorders();\n        var isSingleCell = this.rangeCount === 1 && !rangeController.isMoreThanOneCell();\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-single-cell', isSingleCell);\n        this.refreshHandle();\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-handle', !!this.selectionHandle);\n    };\n    CellComp.prototype.shouldHaveSelectionHandle = function () {\n        var _a = this.beans, gridOptionsWrapper = _a.gridOptionsWrapper, rangeController = _a.rangeController;\n        var el = this.getGui();\n        var cellRanges = rangeController.getCellRanges();\n        var rangesLen = cellRanges.length;\n        if (!rangesLen) {\n            return false;\n        }\n        var lastRange = utils_1._.last(cellRanges);\n        var isFirstRangeCategory = cellRanges[0].type === iRangeController_1.CellRangeType.DIMENSION;\n        var handlesAllowed = (gridOptionsWrapper.isEnableFillHandle() ||\n            gridOptionsWrapper.isEnableRangeHandle() ||\n            this.hasChartRange && !isFirstRangeCategory) && rangesLen === 1;\n        if (!handlesAllowed && this.hasChartRange) {\n            var cellPosition = this.getCellPosition();\n            handlesAllowed =\n                isFirstRangeCategory &&\n                    rangesLen === 2 &&\n                    rangeController.isCellInSpecificRange(this.getCellPosition(), lastRange);\n            var isCategory = isFirstRangeCategory &&\n                rangeController.isCellInSpecificRange(cellPosition, cellRanges[0]);\n            utils_1._.addOrRemoveCssClass(el, 'ag-cell-range-chart-category', isCategory);\n        }\n        return this.rangeCount &&\n            handlesAllowed &&\n            lastRange.endRow != null &&\n            this.beans.rangeController.isContiguousRange(lastRange) &&\n            (utils_1._.containsClass(el, 'ag-cell-range-single-cell') ||\n                (utils_1._.containsClass(el, 'ag-cell-range-bottom') && utils_1._.containsClass(el, 'ag-cell-range-right')));\n    };\n    CellComp.prototype.addSelectionHandle = function () {\n        var _a = this.beans, gridOptionsWrapper = _a.gridOptionsWrapper, context = _a.context, rangeController = _a.rangeController;\n        var cellRangeType = utils_1._.last(rangeController.getCellRanges()).type;\n        var type = (gridOptionsWrapper.isEnableFillHandle() && utils_1._.missing(cellRangeType)) ? 'fill' : 'range';\n        if (this.selectionHandle && this.selectionHandle.getType() !== type) {\n            this.selectionHandle.destroy();\n            this.selectionHandle = undefined;\n        }\n        if (!this.selectionHandle) {\n            this.selectionHandle = context.createComponentFromElement(document.createElement(\"ag-\" + type + \"-handle\"));\n        }\n        this.selectionHandle.refresh(this);\n    };\n    CellComp.prototype.updateRangeBordersIfRangeCount = function () {\n        // we only need to update range borders if we are in a range\n        if (this.rangeCount > 0) {\n            this.updateRangeBorders();\n            this.refreshHandle();\n        }\n    };\n    CellComp.prototype.refreshHandle = function () {\n        var shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();\n        if (this.selectionHandle && !shouldHaveSelectionHandle) {\n            this.selectionHandle.destroy();\n            this.selectionHandle = null;\n        }\n        if (shouldHaveSelectionHandle) {\n            this.addSelectionHandle();\n        }\n    };\n    CellComp.prototype.updateRangeBorders = function () {\n        var rangeBorders = this.getRangeBorders();\n        var isSingleCell = this.rangeCount === 1 && !this.beans.rangeController.isMoreThanOneCell();\n        var isTop = !isSingleCell && rangeBorders.top;\n        var isRight = !isSingleCell && rangeBorders.right;\n        var isBottom = !isSingleCell && rangeBorders.bottom;\n        var isLeft = !isSingleCell && rangeBorders.left;\n        var element = this.getGui();\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-top', isTop);\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-right', isRight);\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-bottom', isBottom);\n        utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-left', isLeft);\n    };\n    CellComp.prototype.onFirstRightPinnedChanged = function () {\n        var firstRightPinned = this.column.isFirstRightPinned();\n        if (this.firstRightPinned !== firstRightPinned) {\n            this.firstRightPinned = firstRightPinned;\n            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\n        }\n    };\n    CellComp.prototype.onLastLeftPinnedChanged = function () {\n        var lastLeftPinned = this.column.isLastLeftPinned();\n        if (this.lastLeftPinned !== lastLeftPinned) {\n            this.lastLeftPinned = lastLeftPinned;\n            utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\n        }\n    };\n    CellComp.prototype.populateTemplate = function () {\n        if (this.usingWrapper) {\n            this.eParentOfValue = this.getRefElement('eCellValue');\n            this.eCellWrapper = this.getRefElement('eCellWrapper');\n            if (this.includeRowDraggingComponent) {\n                this.addRowDragging();\n            }\n            if (this.includeDndSourceComponent) {\n                this.addDndSource();\n            }\n            if (this.includeSelectionComponent) {\n                this.addSelectionCheckbox();\n            }\n        }\n        else {\n            this.eParentOfValue = this.getGui();\n        }\n    };\n    CellComp.prototype.getFrameworkOverrides = function () {\n        return this.beans.frameworkOverrides;\n    };\n    CellComp.prototype.addRowDragging = function () {\n        var pagination = this.beans.gridOptionsWrapper.isPagination();\n        var rowDragManaged = this.beans.gridOptionsWrapper.isRowDragManaged();\n        var clientSideRowModelActive = this.beans.gridOptionsWrapper.isRowModelDefault();\n        if (rowDragManaged) {\n            // row dragging only available in default row model\n            if (!clientSideRowModelActive) {\n                utils_1._.doOnce(function () { return console.warn('ag-Grid: managed row dragging is only allowed in the Client Side Row Model'); }, 'CellComp.addRowDragging');\n                return;\n            }\n            if (pagination) {\n                utils_1._.doOnce(function () { return console.warn('ag-Grid: managed row dragging is not possible when doing pagination'); }, 'CellComp.addRowDragging');\n                return;\n            }\n        }\n        var rowDraggingComp = new rowDragComp_1.RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\n        this.addFeature(this.beans.context, rowDraggingComp);\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addDndSource = function () {\n        var dndSourceComp = new dndSourceComp_1.DndSourceComp(this.rowNode, this.column, this.getValueToUse(), this.beans, this.getGui());\n        this.addFeature(this.beans.context, dndSourceComp);\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(dndSourceComp.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addSelectionCheckbox = function () {\n        var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();\n        this.beans.context.wireBean(cbSelectionComponent);\n        var visibleFunc = this.getComponentHolder().checkboxSelection;\n        visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n        cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc });\n        this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addDomData = function () {\n        var _this = this;\n        var element = this.getGui();\n        this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\n        this.addDestroyFunc(function () {\n            return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);\n        });\n    };\n    CellComp.prototype.onCellFocused = function (event) {\n        var cellFocused = this.beans.focusedCellController.isCellFocused(this.cellPosition);\n        // see if we need to change the classes on this cell\n        if (cellFocused !== this.cellFocused) {\n            // if we are not doing cell selection, then the focus class does not change\n            var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n            if (doingFocusCss) {\n                utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\n            }\n            this.cellFocused = cellFocused;\n        }\n        // if this cell was just focused, see if we need to force browser focus, his can\n        // happen if focus is programmatically set.\n        if (cellFocused && event && event.forceBrowserFocus) {\n            var eGui = this.getGui();\n            eGui.focus();\n            utils_1._.doIeFocusHack(eGui);\n        }\n        // if another cell was focused, and we are editing, then stop editing\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n        if (!cellFocused && !fullRowEdit && this.editingCell) {\n            this.stopRowOrCellEdit();\n        }\n    };\n    // pass in 'true' to cancel the editing.\n    CellComp.prototype.stopRowOrCellEdit = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n            this.rowComp.stopRowEditing(cancel);\n        }\n        else {\n            this.stopEditing(cancel);\n        }\n    };\n    CellComp.prototype.stopEditing = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        if (!this.editingCell) {\n            return;\n        }\n        // if no cell editor, this means due to async, that the cell editor never got initialised,\n        // so we just carry on regardless as if the editing was never started.\n        if (!this.cellEditor) {\n            this.editingCell = false;\n            return;\n        }\n        var newValueExists = false;\n        var newValue;\n        if (!cancel) {\n            // also have another option here to cancel after editing, so for example user could have a popup editor and\n            // it is closed by user clicking outside the editor. then the editor will close automatically (with false\n            // passed above) and we need to see if the editor wants to accept the new value.\n            var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\n            if (!userWantsToCancel) {\n                newValue = this.cellEditor.getValue();\n                newValueExists = true;\n            }\n        }\n        // it is important we set this after setValue() above, as otherwise the cell will flash\n        // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\n        // thus it will skip the refresh on this cell until the end of this method where we call\n        // refresh directly and we suppress the flash.\n        this.editingCell = false;\n        if (this.cellEditor.destroy) {\n            this.cellEditor.destroy();\n        }\n        // important to clear this out - as parts of the code will check for\n        // this to see if an async cellEditor has yet to be created\n        this.cellEditor = null;\n        if (this.cellEditorInPopup && this.hideEditorPopup) {\n            this.hideEditorPopup();\n            this.hideEditorPopup = null;\n        }\n        else {\n            utils_1._.clearElement(this.getGui());\n            // put the cell back the way it was before editing\n            if (this.usingWrapper) {\n                // if wrapper, then put the wrapper back\n                this.getGui().appendChild(this.eCellWrapper);\n            }\n            else {\n                // if cellRenderer, then put the gui back in. if the renderer has\n                // a refresh, it will be called. however if it doesn't, then later\n                // the renderer will be destroyed and a new one will be created.\n                if (this.cellRenderer) {\n                    // we know it's a dom element (not a string) because we converted\n                    // it after the gui was attached if it was a string.\n                    var eCell = this.cellRendererGui;\n                    // can be null if cell was previously null / contained empty string,\n                    // this will result in new value not being rendered.\n                    if (eCell) {\n                        this.getGui().appendChild(eCell);\n                    }\n                }\n            }\n        }\n        this.setInlineEditingClass();\n        if (newValueExists) {\n            // we suppressRefreshCell because the call to rowNode.setDataValue() results in change detection\n            // getting triggered, which results in all cells getting refreshed. we do not want this refresh\n            // to happen on this call as we want to call it explicitly below. otherwise refresh gets called twice.\n            // if we only did this refresh (and not the one below) then the cell would flash and not be forced.\n            this.suppressRefreshCell = true;\n            this.rowNode.setDataValue(this.column, newValue);\n            this.suppressRefreshCell = false;\n        }\n        // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\n        // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\n        // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\n        this.refreshCell({ forceRefresh: true, suppressFlash: true });\n        var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STOPPED);\n        this.beans.eventService.dispatchEvent(event);\n    };\n    CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\n    CellComp.CELL_RENDERER_TYPE_NORMAL = 'cellRenderer';\n    CellComp.CELL_RENDERER_TYPE_PINNED = 'pinnedRowCellRenderer';\n    return CellComp;\n}(component_1.Component));\nexports.CellComp = CellComp;\n"]},"metadata":{},"sourceType":"script"}