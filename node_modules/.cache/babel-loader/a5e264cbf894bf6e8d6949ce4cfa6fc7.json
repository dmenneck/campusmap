{"ast":null,"code":"/**\n * @module ol/style/AtlasManager\n */\nimport { MAX_TEXTURE_SIZE as WEBGL_MAX_TEXTURE_SIZE } from '../webgl.js';\nimport { VOID } from '../functions.js';\nimport Atlas from './Atlas.js';\n/**\n * @typedef {Object} Options\n * @property {number} [initialSize=256] The size in pixels of the first atlas image.\n * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\n * `webgl/MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\n * @property {number} [space=1] The space in pixels between images.\n */\n\n/**\n * Provides information for an image inside an atlas manager.\n * `offsetX` and `offsetY` is the position of the image inside\n * the atlas image `image` and the position of the hit-detection image\n * inside the hit-detection atlas image `hitImage`.\n * @typedef {Object} AtlasManagerInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n * @property {HTMLCanvasElement} hitImage\n */\n\n/**\n * The size in pixels of the first atlas image.\n * @type {number}\n */\n\nvar INITIAL_ATLAS_SIZE = 256;\n/**\n * The maximum size in pixels of atlas images.\n * @type {number}\n */\n\nvar MAX_ATLAS_SIZE = -1;\n/**\n * @classdesc\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n * @api\n */\n\nvar AtlasManager = function AtlasManager(opt_options) {\n  var options = opt_options || {};\n  /**\n   * The size in pixels of the latest atlas image.\n   * @private\n   * @type {number}\n   */\n\n  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : INITIAL_ATLAS_SIZE;\n  /**\n   * The maximum size in pixels of atlas images.\n   * @private\n   * @type {number}\n   */\n\n  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : MAX_ATLAS_SIZE != -1 ? MAX_ATLAS_SIZE : WEBGL_MAX_TEXTURE_SIZE !== undefined ? WEBGL_MAX_TEXTURE_SIZE : 2048;\n  /**\n   * The size in pixels between images.\n   * @private\n   * @type {number}\n   */\n\n  this.space_ = options.space !== undefined ? options.space : 1;\n  /**\n   * @private\n   * @type {Array<import(\"./Atlas.js\").default>}\n   */\n\n  this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\n  /**\n   * The size in pixels of the latest atlas image for hit-detection images.\n   * @private\n   * @type {number}\n   */\n\n  this.currentHitSize_ = this.currentSize_;\n  /**\n   * @private\n   * @type {Array<import(\"./Atlas.js\").default>}\n   */\n\n  this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\n};\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?AtlasManagerInfo} The position and atlas image for the\n *  entry, or `null` if the entry is not part of the atlas manager.\n */\n\n\nAtlasManager.prototype.getInfo = function getInfo(id) {\n  /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n  var info = this.getInfo_(this.atlases_, id);\n\n  if (!info) {\n    return null;\n  }\n\n  var hitInfo =\n  /** @type {import(\"./Atlas.js\").AtlasInfo} */\n  this.getInfo_(this.hitAtlases_, id);\n  return this.mergeInfos_(info, hitInfo);\n};\n/**\n * @private\n * @param {Array<import(\"./Atlas.js\").default>} atlases The atlases to search.\n * @param {string} id The identifier of the entry to check.\n * @return {?import(\"./Atlas.js\").AtlasInfo} The position and atlas image for the entry,\n *  or `null` if the entry is not part of the atlases.\n */\n\n\nAtlasManager.prototype.getInfo_ = function getInfo_(atlases, id) {\n  for (var i = 0, ii = atlases.length; i < ii; ++i) {\n    var atlas = atlases[i];\n    var info = atlas.get(id);\n\n    if (info) {\n      return info;\n    }\n  }\n\n  return null;\n};\n/**\n * @private\n * @param {import(\"./Atlas.js\").AtlasInfo} info The info for the real image.\n * @param {import(\"./Atlas.js\").AtlasInfo} hitInfo The info for the hit-detection\n *  image.\n * @return {?AtlasManagerInfo} The position and atlas image for the\n *  entry, or `null` if the entry is not part of the atlases.\n */\n\n\nAtlasManager.prototype.mergeInfos_ = function mergeInfos_(info, hitInfo) {\n  return (\n    /** @type {AtlasManagerInfo} */\n    {\n      offsetX: info.offsetX,\n      offsetY: info.offsetY,\n      image: info.image,\n      hitImage: hitInfo.image\n    }\n  );\n};\n/**\n * Add an image to the atlas manager.\n *\n * If an entry for the given id already exists, the entry will\n * be overridden (but the space on the atlas graphic will not be freed).\n *\n * If `renderHitCallback` is provided, the image (or the hit-detection version\n * of the image) will be rendered into a separate hit-detection atlas image.\n *\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {function(CanvasRenderingContext2D, number, number)=} opt_renderHitCallback Called to render a hit-detection image onto a hit\n *  detection atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback` and `renderHitCallback`.\n * @return {?AtlasManagerInfo}The position and atlas image for the\n *  entry, or `null` if the image is too big.\n */\n\n\nAtlasManager.prototype.add = function add(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {\n    return null;\n  }\n  /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n\n\n  var info = this.add_(false, id, width, height, renderCallback, opt_this);\n\n  if (!info) {\n    return null;\n  } // even if no hit-detection entry is requested, we insert a fake entry into\n  // the hit-detection atlas, to make sure that the offset is the same for\n  // the original image and the hit-detection image.\n\n\n  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : VOID;\n  var hitInfo =\n  /** @type {import(\"./Atlas.js\").AtlasInfo} */\n  this.add_(true, id, width, height, renderHitCallback, opt_this);\n  return this.mergeInfos_(info, hitInfo);\n};\n/**\n * @private\n * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback` and `renderHitCallback`.\n * @return {?import(\"./Atlas.js\").AtlasInfo}The position and atlas image for the entry,\n *  or `null` if the image is too big.\n */\n\n\nAtlasManager.prototype.add_ = function add_(isHitAtlas, id, width, height, renderCallback, opt_this) {\n  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;\n  var atlas, info, i, ii;\n\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.add(id, width, height, renderCallback, opt_this);\n\n    if (info) {\n      return info;\n    } else if (!info && i === ii - 1) {\n      // the entry could not be added to one of the existing atlases,\n      // create a new atlas that is twice as big and try to add to this one.\n      var size = void 0;\n\n      if (isHitAtlas) {\n        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n        this.currentHitSize_ = size;\n      } else {\n        size = Math.min(this.currentSize_ * 2, this.maxSize_);\n        this.currentSize_ = size;\n      }\n\n      atlas = new Atlas(size, this.space_);\n      atlases.push(atlas); // run the loop another time\n\n      ++ii;\n    }\n  }\n\n  return null;\n};\n\nexport default AtlasManager;","map":{"version":3,"sources":["../../../src/ol/style/AtlasManager.js"],"names":["const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/style/AtlasManager\n */\nimport {MAX_TEXTURE_SIZE as WEBGL_MAX_TEXTURE_SIZE} from '../webgl.js';\nimport {VOID} from '../functions.js';\nimport Atlas from './Atlas.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [initialSize=256] The size in pixels of the first atlas image.\n * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\n * `webgl/MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\n * @property {number} [space=1] The space in pixels between images.\n */\n\n\n/**\n * Provides information for an image inside an atlas manager.\n * `offsetX` and `offsetY` is the position of the image inside\n * the atlas image `image` and the position of the hit-detection image\n * inside the hit-detection atlas image `hitImage`.\n * @typedef {Object} AtlasManagerInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n * @property {HTMLCanvasElement} hitImage\n */\n\n\n/**\n * The size in pixels of the first atlas image.\n * @type {number}\n */\nconst INITIAL_ATLAS_SIZE = 256;\n\n/**\n * The maximum size in pixels of atlas images.\n * @type {number}\n */\nconst MAX_ATLAS_SIZE = -1;\n\n\n/**\n * @classdesc\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n * @api\n */\nclass AtlasManager {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options || {};\n\n    /**\n     * The size in pixels of the latest atlas image.\n     * @private\n     * @type {number}\n     */\n    this.currentSize_ = options.initialSize !== undefined ?\n      options.initialSize : INITIAL_ATLAS_SIZE;\n\n    /**\n     * The maximum size in pixels of atlas images.\n     * @private\n     * @type {number}\n     */\n    this.maxSize_ = options.maxSize !== undefined ?\n      options.maxSize : MAX_ATLAS_SIZE != -1 ?\n        MAX_ATLAS_SIZE : WEBGL_MAX_TEXTURE_SIZE !== undefined ?\n          WEBGL_MAX_TEXTURE_SIZE : 2048;\n\n    /**\n     * The size in pixels between images.\n     * @private\n     * @type {number}\n     */\n    this.space_ = options.space !== undefined ? options.space : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"./Atlas.js\").default>}\n     */\n    this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\n\n    /**\n     * The size in pixels of the latest atlas image for hit-detection images.\n     * @private\n     * @type {number}\n     */\n    this.currentHitSize_ = this.currentSize_;\n\n    /**\n     * @private\n     * @type {Array<import(\"./Atlas.js\").default>}\n     */\n    this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlas manager.\n   */\n  getInfo(id) {\n    /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n    const info = this.getInfo_(this.atlases_, id);\n\n    if (!info) {\n      return null;\n    }\n    const hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */ (this.getInfo_(this.hitAtlases_, id));\n\n    return this.mergeInfos_(info, hitInfo);\n  }\n\n  /**\n   * @private\n   * @param {Array<import(\"./Atlas.js\").default>} atlases The atlases to search.\n   * @param {string} id The identifier of the entry to check.\n   * @return {?import(\"./Atlas.js\").AtlasInfo} The position and atlas image for the entry,\n   *    or `null` if the entry is not part of the atlases.\n   */\n  getInfo_(atlases, id) {\n    for (let i = 0, ii = atlases.length; i < ii; ++i) {\n      const atlas = atlases[i];\n      const info = atlas.get(id);\n      if (info) {\n        return info;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"./Atlas.js\").AtlasInfo} info The info for the real image.\n   * @param {import(\"./Atlas.js\").AtlasInfo} hitInfo The info for the hit-detection\n   *    image.\n   * @return {?AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlases.\n   */\n  mergeInfos_(info, hitInfo) {\n    return (\n      /** @type {AtlasManagerInfo} */ ({\n        offsetX: info.offsetX,\n        offsetY: info.offsetY,\n        image: info.image,\n        hitImage: hitInfo.image\n      })\n    );\n  }\n\n  /**\n   * Add an image to the atlas manager.\n   *\n   * If an entry for the given id already exists, the entry will\n   * be overridden (but the space on the atlas graphic will not be freed).\n   *\n   * If `renderHitCallback` is provided, the image (or the hit-detection version\n   * of the image) will be rendered into a separate hit-detection atlas image.\n   *\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {function(CanvasRenderingContext2D, number, number)=} opt_renderHitCallback Called to render a hit-detection image onto a hit\n   *    detection atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?AtlasManagerInfo}  The position and atlas image for the\n   *    entry, or `null` if the image is too big.\n   */\n  add(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n    if (width + this.space_ > this.maxSize_ ||\n        height + this.space_ > this.maxSize_) {\n      return null;\n    }\n\n    /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n    const info = this.add_(false, id, width, height, renderCallback, opt_this);\n    if (!info) {\n      return null;\n    }\n\n    // even if no hit-detection entry is requested, we insert a fake entry into\n    // the hit-detection atlas, to make sure that the offset is the same for\n    // the original image and the hit-detection image.\n    const renderHitCallback = opt_renderHitCallback !== undefined ?\n      opt_renderHitCallback : VOID;\n\n    const hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */ (this.add_(true,\n      id, width, height, renderHitCallback, opt_this));\n\n    return this.mergeInfos_(info, hitInfo);\n  }\n\n  /**\n   * @private\n   * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?import(\"./Atlas.js\").AtlasInfo}  The position and atlas image for the entry,\n   *    or `null` if the image is too big.\n   */\n  add_(isHitAtlas, id, width, height, renderCallback, opt_this) {\n    const atlases = (isHitAtlas) ? this.hitAtlases_ : this.atlases_;\n    let atlas, info, i, ii;\n    for (i = 0, ii = atlases.length; i < ii; ++i) {\n      atlas = atlases[i];\n      info = atlas.add(id, width, height, renderCallback, opt_this);\n      if (info) {\n        return info;\n      } else if (!info && i === ii - 1) {\n        // the entry could not be added to one of the existing atlases,\n        // create a new atlas that is twice as big and try to add to this one.\n        let size;\n        if (isHitAtlas) {\n          size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n          this.currentHitSize_ = size;\n        } else {\n          size = Math.min(this.currentSize_ * 2, this.maxSize_);\n          this.currentSize_ = size;\n        }\n        atlas = new Atlas(size, this.space_);\n        atlases.push(atlas);\n        // run the loop another time\n        ++ii;\n      }\n    }\n    return null;\n  }\n}\n\nexport default AtlasManager;\n"]},"metadata":{},"sourceType":"module"}