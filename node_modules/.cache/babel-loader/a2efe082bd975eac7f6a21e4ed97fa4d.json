{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"./logger\");\n\nvar context_1 = require(\"./context/context\");\n\nvar context_2 = require(\"./context/context\");\n\nvar gridOptionsWrapper_1 = require(\"./gridOptionsWrapper\");\n\nvar utils_1 = require(\"./utils\");\n\nvar EventService =\n/** @class */\nfunction () {\n  function EventService() {\n    this.allSyncListeners = {};\n    this.allAsyncListeners = {};\n    this.globalSyncListeners = [];\n    this.globalAsyncListeners = [];\n    this.asyncFunctionsQueue = [];\n    this.scheduled = false;\n    this.firedEvents = {};\n  }\n\n  EventService_1 = EventService; // because this class is used both inside the context and outside the context, we do not\n  // use autowired attributes, as that would be confusing, as sometimes the attributes\n  // would be wired, and sometimes not.\n  //\n  // the global event servers used by ag-Grid is autowired by the context once, and this\n  // setBeans method gets called once.\n  //\n  // the times when this class is used outside of the context (eg RowNode has an instance of this\n  // class) then it is not a bean, and this setBeans method is not called.\n\n  EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, globalEventListener) {\n    if (globalEventListener === void 0) {\n      globalEventListener = null;\n    }\n\n    this.logger = loggerFactory.create('EventService');\n\n    if (globalEventListener) {\n      var async = gridOptionsWrapper.useAsyncEvents();\n      this.addGlobalListener(globalEventListener, async);\n    }\n  };\n\n  EventService.prototype.getListenerList = function (eventType, async) {\n    var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n    var listenerList = listenerMap[eventType];\n\n    if (!listenerList) {\n      listenerList = [];\n      listenerMap[eventType] = listenerList;\n    }\n\n    return listenerList;\n  };\n\n  EventService.prototype.addEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    var listenerList = this.getListenerList(eventType, async);\n\n    if (listenerList.indexOf(listener) < 0) {\n      listenerList.push(listener);\n    }\n  }; // for some events, it's important that the model gets to hear about them before the view,\n  // as the model may need to update before the view works on the info. if you register\n  // via this method, you get notified before the view parts\n\n\n  EventService.prototype.addModalPriorityEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    this.addEventListener(eventType + EventService_1.PRIORITY, listener, async);\n  };\n\n  EventService.prototype.addGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    if (async) {\n      this.globalAsyncListeners.push(listener);\n    } else {\n      this.globalSyncListeners.push(listener);\n    }\n  };\n\n  EventService.prototype.removeEventListener = function (eventType, listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    var listenerList = this.getListenerList(eventType, async);\n\n    utils_1._.removeFromArray(listenerList, listener);\n  };\n\n  EventService.prototype.removeGlobalListener = function (listener, async) {\n    if (async === void 0) {\n      async = false;\n    }\n\n    if (async) {\n      utils_1._.removeFromArray(this.globalAsyncListeners, listener);\n    } else {\n      utils_1._.removeFromArray(this.globalSyncListeners, listener);\n    }\n  }; // why do we pass the type here? the type is in ColumnChangeEvent, so unless the\n  // type is not in other types of events???\n\n\n  EventService.prototype.dispatchEvent = function (event) {\n    // console.log(`dispatching ${eventType}: ${event}`);\n    this.dispatchToListeners(event, true);\n    this.dispatchToListeners(event, false);\n    this.firedEvents[event.type] = true;\n  };\n\n  EventService.prototype.dispatchEventOnce = function (event) {\n    if (!this.firedEvents[event.type]) {\n      this.dispatchEvent(event);\n    }\n  };\n\n  EventService.prototype.dispatchToListeners = function (event, async) {\n    var _this = this;\n\n    var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n    var eventType = event.type; // this allows the columnController to get events before anyone else\n\n    var p1ListenerList = this.getListenerList(eventType + EventService_1.PRIORITY, async);\n\n    utils_1._.forEachSnapshotFirst(p1ListenerList, function (listener) {\n      if (async) {\n        _this.dispatchAsync(function () {\n          return listener(event);\n        });\n      } else {\n        listener(event);\n      }\n    });\n\n    var listenerList = this.getListenerList(eventType, async);\n\n    utils_1._.forEachSnapshotFirst(listenerList, function (listener) {\n      if (async) {\n        _this.dispatchAsync(function () {\n          return listener(event);\n        });\n      } else {\n        listener(event);\n      }\n    });\n\n    utils_1._.forEachSnapshotFirst(globalListeners, function (listener) {\n      if (async) {\n        _this.dispatchAsync(function () {\n          return listener(eventType, event);\n        });\n      } else {\n        listener(eventType, event);\n      }\n    });\n  }; // this gets called inside the grid's thread, for each event that it\n  // wants to set async. the grid then batches the events into one setTimeout()\n  // because setTimeout() is an expensive operation. ideally we would have\n  // each event in it's own setTimeout(), but we batch for performance.\n\n\n  EventService.prototype.dispatchAsync = function (func) {\n    // add to the queue for executing later in the next VM turn\n    this.asyncFunctionsQueue.push(func); // check if timeout is already scheduled. the first time the grid calls\n    // this within it's thread turn, this should be false, so it will schedule\n    // the 'flush queue' method the first time it comes here. then the flag is\n    // set to 'true' so it will know it's already scheduled for subsequent calls.\n\n    if (!this.scheduled) {\n      // if not scheduled, schedule one\n      window.setTimeout(this.flushAsyncQueue.bind(this), 0); // mark that it is scheduled\n\n      this.scheduled = true;\n    }\n  }; // this happens in the next VM turn only, and empties the queue of events\n\n\n  EventService.prototype.flushAsyncQueue = function () {\n    this.scheduled = false; // we take a copy, because the event listener could be using\n    // the grid, which would cause more events, which would be potentially\n    // added to the queue, so safe to take a copy, the new events will\n    // get executed in a later VM turn rather than risk updating the\n    // queue as we are flushing it.\n\n    var queueCopy = this.asyncFunctionsQueue.slice();\n    this.asyncFunctionsQueue = []; // execute the queue\n\n    queueCopy.forEach(function (func) {\n      return func();\n    });\n  };\n\n  var EventService_1; // this is an old idea niall had, should really take it out, was to do with ordering who gets to process\n  // events first, to give model and service objects preference over the view\n\n  EventService.PRIORITY = '-P1';\n\n  __decorate([__param(0, context_2.Qualifier('loggerFactory')), __param(1, context_2.Qualifier('gridOptionsWrapper')), __param(2, context_2.Qualifier('globalEventListener')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [logger_1.LoggerFactory, gridOptionsWrapper_1.GridOptionsWrapper, Function]), __metadata(\"design:returntype\", void 0)], EventService.prototype, \"setBeans\", null);\n\n  EventService = EventService_1 = __decorate([context_1.Bean('eventService')], EventService);\n  return EventService;\n}();\n\nexports.EventService = EventService;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/eventService.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","__param","paramIndex","decorator","exports","value","logger_1","require","context_1","context_2","gridOptionsWrapper_1","utils_1","EventService","allSyncListeners","allAsyncListeners","globalSyncListeners","globalAsyncListeners","asyncFunctionsQueue","scheduled","firedEvents","EventService_1","prototype","setBeans","loggerFactory","gridOptionsWrapper","globalEventListener","logger","create","async","useAsyncEvents","addGlobalListener","getListenerList","eventType","listenerMap","listenerList","addEventListener","listener","indexOf","push","addModalPriorityEventListener","PRIORITY","removeEventListener","_","removeFromArray","removeGlobalListener","dispatchEvent","event","dispatchToListeners","type","dispatchEventOnce","_this","globalListeners","p1ListenerList","forEachSnapshotFirst","dispatchAsync","func","window","setTimeout","flushAsyncQueue","bind","queueCopy","slice","forEach","Qualifier","Function","LoggerFactory","GridOptionsWrapper","Bean"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logger_1 = require(\"./logger\");\nvar context_1 = require(\"./context/context\");\nvar context_2 = require(\"./context/context\");\nvar gridOptionsWrapper_1 = require(\"./gridOptionsWrapper\");\nvar utils_1 = require(\"./utils\");\nvar EventService = /** @class */ (function () {\n    function EventService() {\n        this.allSyncListeners = {};\n        this.allAsyncListeners = {};\n        this.globalSyncListeners = [];\n        this.globalAsyncListeners = [];\n        this.asyncFunctionsQueue = [];\n        this.scheduled = false;\n        this.firedEvents = {};\n    }\n    EventService_1 = EventService;\n    // because this class is used both inside the context and outside the context, we do not\n    // use autowired attributes, as that would be confusing, as sometimes the attributes\n    // would be wired, and sometimes not.\n    //\n    // the global event servers used by ag-Grid is autowired by the context once, and this\n    // setBeans method gets called once.\n    //\n    // the times when this class is used outside of the context (eg RowNode has an instance of this\n    // class) then it is not a bean, and this setBeans method is not called.\n    EventService.prototype.setBeans = function (loggerFactory, gridOptionsWrapper, globalEventListener) {\n        if (globalEventListener === void 0) { globalEventListener = null; }\n        this.logger = loggerFactory.create('EventService');\n        if (globalEventListener) {\n            var async = gridOptionsWrapper.useAsyncEvents();\n            this.addGlobalListener(globalEventListener, async);\n        }\n    };\n    EventService.prototype.getListenerList = function (eventType, async) {\n        var listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n        var listenerList = listenerMap[eventType];\n        if (!listenerList) {\n            listenerList = [];\n            listenerMap[eventType] = listenerList;\n        }\n        return listenerList;\n    };\n    EventService.prototype.addEventListener = function (eventType, listener, async) {\n        if (async === void 0) { async = false; }\n        var listenerList = this.getListenerList(eventType, async);\n        if (listenerList.indexOf(listener) < 0) {\n            listenerList.push(listener);\n        }\n    };\n    // for some events, it's important that the model gets to hear about them before the view,\n    // as the model may need to update before the view works on the info. if you register\n    // via this method, you get notified before the view parts\n    EventService.prototype.addModalPriorityEventListener = function (eventType, listener, async) {\n        if (async === void 0) { async = false; }\n        this.addEventListener(eventType + EventService_1.PRIORITY, listener, async);\n    };\n    EventService.prototype.addGlobalListener = function (listener, async) {\n        if (async === void 0) { async = false; }\n        if (async) {\n            this.globalAsyncListeners.push(listener);\n        }\n        else {\n            this.globalSyncListeners.push(listener);\n        }\n    };\n    EventService.prototype.removeEventListener = function (eventType, listener, async) {\n        if (async === void 0) { async = false; }\n        var listenerList = this.getListenerList(eventType, async);\n        utils_1._.removeFromArray(listenerList, listener);\n    };\n    EventService.prototype.removeGlobalListener = function (listener, async) {\n        if (async === void 0) { async = false; }\n        if (async) {\n            utils_1._.removeFromArray(this.globalAsyncListeners, listener);\n        }\n        else {\n            utils_1._.removeFromArray(this.globalSyncListeners, listener);\n        }\n    };\n    // why do we pass the type here? the type is in ColumnChangeEvent, so unless the\n    // type is not in other types of events???\n    EventService.prototype.dispatchEvent = function (event) {\n        // console.log(`dispatching ${eventType}: ${event}`);\n        this.dispatchToListeners(event, true);\n        this.dispatchToListeners(event, false);\n        this.firedEvents[event.type] = true;\n    };\n    EventService.prototype.dispatchEventOnce = function (event) {\n        if (!this.firedEvents[event.type]) {\n            this.dispatchEvent(event);\n        }\n    };\n    EventService.prototype.dispatchToListeners = function (event, async) {\n        var _this = this;\n        var globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n        var eventType = event.type;\n        // this allows the columnController to get events before anyone else\n        var p1ListenerList = this.getListenerList(eventType + EventService_1.PRIORITY, async);\n        utils_1._.forEachSnapshotFirst(p1ListenerList, function (listener) {\n            if (async) {\n                _this.dispatchAsync(function () { return listener(event); });\n            }\n            else {\n                listener(event);\n            }\n        });\n        var listenerList = this.getListenerList(eventType, async);\n        utils_1._.forEachSnapshotFirst(listenerList, function (listener) {\n            if (async) {\n                _this.dispatchAsync(function () { return listener(event); });\n            }\n            else {\n                listener(event);\n            }\n        });\n        utils_1._.forEachSnapshotFirst(globalListeners, function (listener) {\n            if (async) {\n                _this.dispatchAsync(function () { return listener(eventType, event); });\n            }\n            else {\n                listener(eventType, event);\n            }\n        });\n    };\n    // this gets called inside the grid's thread, for each event that it\n    // wants to set async. the grid then batches the events into one setTimeout()\n    // because setTimeout() is an expensive operation. ideally we would have\n    // each event in it's own setTimeout(), but we batch for performance.\n    EventService.prototype.dispatchAsync = function (func) {\n        // add to the queue for executing later in the next VM turn\n        this.asyncFunctionsQueue.push(func);\n        // check if timeout is already scheduled. the first time the grid calls\n        // this within it's thread turn, this should be false, so it will schedule\n        // the 'flush queue' method the first time it comes here. then the flag is\n        // set to 'true' so it will know it's already scheduled for subsequent calls.\n        if (!this.scheduled) {\n            // if not scheduled, schedule one\n            window.setTimeout(this.flushAsyncQueue.bind(this), 0);\n            // mark that it is scheduled\n            this.scheduled = true;\n        }\n    };\n    // this happens in the next VM turn only, and empties the queue of events\n    EventService.prototype.flushAsyncQueue = function () {\n        this.scheduled = false;\n        // we take a copy, because the event listener could be using\n        // the grid, which would cause more events, which would be potentially\n        // added to the queue, so safe to take a copy, the new events will\n        // get executed in a later VM turn rather than risk updating the\n        // queue as we are flushing it.\n        var queueCopy = this.asyncFunctionsQueue.slice();\n        this.asyncFunctionsQueue = [];\n        // execute the queue\n        queueCopy.forEach(function (func) { return func(); });\n    };\n    var EventService_1;\n    // this is an old idea niall had, should really take it out, was to do with ordering who gets to process\n    // events first, to give model and service objects preference over the view\n    EventService.PRIORITY = '-P1';\n    __decorate([\n        __param(0, context_2.Qualifier('loggerFactory')),\n        __param(1, context_2.Qualifier('gridOptionsWrapper')),\n        __param(2, context_2.Qualifier('globalEventListener')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [logger_1.LoggerFactory,\n            gridOptionsWrapper_1.GridOptionsWrapper,\n            Function]),\n        __metadata(\"design:returntype\", void 0)\n    ], EventService.prototype, \"setBeans\", null);\n    EventService = EventService_1 = __decorate([\n        context_1.Bean('eventService')\n    ], EventService);\n    return EventService;\n}());\nexports.EventService = EventService;\n"]},"metadata":{},"sourceType":"script"}