{"ast":null,"code":"/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport { inherits } from '../../util.js';\nimport { scale as scaleCoordinate } from '../../coordinate.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport { UNDEFINED } from '../../functions.js';\nimport CanvasLayerRenderer from '../canvas/Layer.js';\nimport { create as createTransform, apply as applyTransform } from '../../transform.js';\n/**\n * @constructor\n * @abstract\n * @extends {module:ol/renderer/canvas/Layer}\n * @param {module:ol/layer/Layer} layer Layer.\n */\n\nconst IntermediateCanvasRenderer = function (layer) {\n  CanvasLayerRenderer.call(this, layer);\n  /**\n   * @protected\n   * @type {module:ol/transform~Transform}\n   */\n\n  this.coordinateToCanvasPixelTransform = createTransform();\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n\n  this.hitCanvasContext_ = null;\n};\n\ninherits(IntermediateCanvasRenderer, CanvasLayerRenderer);\n/**\n * @inheritDoc\n */\n\nIntermediateCanvasRenderer.prototype.composeFrame = function (frameState, layerState, context) {\n  this.preCompose(context, frameState);\n  const image = this.getImage();\n\n  if (image) {\n    // clipped rendering if layer extent is set\n    const extent = layerState.extent;\n    const clipped = extent !== undefined && !containsExtent(extent, frameState.extent) && intersects(extent, frameState.extent);\n\n    if (clipped) {\n      this.clip(context, frameState,\n      /** @type {module:ol/extent~Extent} */\n      extent);\n    }\n\n    const imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used\n    // to save and restore the transformation matrix and the opacity.\n    // see http://jsperf.com/context-save-restore-versus-variable\n\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used\n    // when the view is rotated. see http://jsperf.com/canvas-transform\n\n    const dx = imageTransform[4];\n    const dy = imageTransform[5];\n    const dw = image.width * imageTransform[0];\n    const dh = image.height * imageTransform[3];\n    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n    context.globalAlpha = alpha;\n\n    if (clipped) {\n      context.restore();\n    }\n  }\n\n  this.postCompose(context, frameState, layerState);\n};\n/**\n * @abstract\n * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.\n */\n\n\nIntermediateCanvasRenderer.prototype.getImage = function () {};\n/**\n * @abstract\n * @return {!module:ol/transform~Transform} Image transform.\n */\n\n\nIntermediateCanvasRenderer.prototype.getImageTransform = function () {};\n/**\n * @inheritDoc\n */\n\n\nIntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\n  const layer = this.getLayer();\n  const source = layer.getSource();\n  const resolution = frameState.viewState.resolution;\n  const rotation = frameState.viewState.rotation;\n  const skippedFeatureUids = frameState.skippedFeatureUids;\n  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\n  /**\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   * @return {?} Callback result.\n   */\n  function (feature) {\n    return callback.call(thisArg, feature, layer);\n  });\n};\n/**\n * @inheritDoc\n */\n\n\nIntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\n  if (!this.getImage()) {\n    return undefined;\n  }\n\n  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== UNDEFINED) {\n    // for ImageCanvas sources use the original hit-detection logic,\n    // so that for example also transparent polygons are detected\n    return CanvasLayerRenderer.prototype.forEachLayerAtCoordinate.apply(this, arguments);\n  } else {\n    const pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n    const imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  }\n};\n\nexport default IntermediateCanvasRenderer;","map":null,"metadata":{},"sourceType":"module"}