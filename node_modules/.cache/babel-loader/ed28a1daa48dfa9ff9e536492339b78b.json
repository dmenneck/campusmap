{"ast":null,"code":"/**\n * @module ol/geom/Point\n */\nimport { createOrUpdateFromCoordinate, containsXY } from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\n\nvar Point =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function Point(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    this.setCoordinates(coordinates, opt_layout);\n  }\n\n  if (SimpleGeometry) Point.__proto__ = SimpleGeometry;\n  Point.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  Point.prototype.constructor = Point;\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @override\n   * @api\n   */\n\n  Point.prototype.clone = function clone() {\n    var point = new Point(this.flatCoordinates.slice(), this.layout);\n    return point;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Point.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      var stride = this.stride;\n\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  Point.prototype.getCoordinates = function getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Point.prototype.computeExtent = function computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.getType = function getType() {\n    return GeometryType.POINT;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return Point;\n}(SimpleGeometry);\n\nexport default Point;","map":{"version":3,"sources":["../../../src/ol/geom/Point.js"],"names":["super","const","let"],"mappings":"AAAA;;;AAGA,SAAQ,4BAAR,EAAsC,UAAtC,QAAuD,cAAvD;AACA,OAAO,YAAP,MAAyB,mBAAzB;AACA,OAAO,cAAP,MAA2B,qBAA3B;AACA,SAAQ,iBAAR,QAAgC,mBAAhC;AACA,SAAQ,eAAe,IAAI,SAA3B,QAA2C,YAA3C;;;;;;;;AAQA,IAAM,KAAK;AAAuB;AAAA,UAAA,cAAA,EAAA;AAMhC,WAAA,KAAA,CAAY,WAAZ,EAAyB,UAAzB,EAAqC;AACnCA,IAAAA,cAAAA,CAAAA,IAAAA,CAAK,IAALA;AACA,SAAK,cAAL,CAAoB,WAApB,EAAiC,UAAjC;;;;;gCACD,K;;;;;;;;kBAQD,K,GAAA,SAAA,KAAA,GAAQ;AACNC,QAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,KAAK,eAAL,CAAqB,KAArB,EAAV,EAAwC,KAAK,MAA7C,CAAdA;AACA,WAAO,KAAP;AACD,G;;;;;;kBAKD,c,GAAA,SAAA,cAAA,CAAe,CAAf,EAAkB,CAAlB,EAAqB,YAArB,EAAmC,kBAAnC,EAAuD;AACrDA,QAAM,eAAe,GAAG,KAAK,eAA7BA;AACAA,QAAM,eAAe,GAAG,SAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,eAAe,CAAC,CAAD,CAAtB,EAA2B,eAAe,CAAC,CAAD,CAA1C,CAAjCA;;AACA,QAAI,eAAe,GAAG,kBAAtB,EAA0C;AACxCA,UAAM,MAAM,GAAG,KAAK,MAApBA;;AACA,WAAKC,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,EAAE,CAA9B,EAAiC;AAC/B,QAAA,YAAY,CAAC,CAAD,CAAZ,GAAkB,eAAe,CAAC,CAAD,CAAjC;AACD;;AACD,MAAA,YAAY,CAAC,MAAb,GAAsB,MAAtB;AACA,aAAO,eAAP;AACD,KAPD,MAOO;AACL,aAAO,kBAAP;AACD;AACF,G;;;;;;;;;kBAQD,c,GAAA,SAAA,cAAA,GAAiB;AACf,WAAO,CAAC,KAAK,eAAN,GAAwB,EAAxB,GAA6B,KAAK,eAAL,CAAqB,KAArB,EAApC;AACD,G;;;;;;kBAKD,a,GAAA,SAAA,aAAA,CAAc,MAAd,EAAsB;AACpB,WAAO,4BAA4B,CAAC,KAAK,eAAN,EAAuB,MAAvB,CAAnC;AACD,G;;;;;;;kBAMD,O,GAAA,SAAA,OAAA,GAAU;AACR,WAAO,YAAY,CAAC,KAApB;AACD,G;;;;;;;kBAMD,gB,GAAA,SAAA,gBAAA,CAAiB,MAAjB,EAAyB;AACvB,WAAO,UAAU,CAAC,MAAD,EAAS,KAAK,eAAL,CAAqB,CAArB,CAAT,EAAkC,KAAK,eAAL,CAAqB,CAArB,CAAlC,CAAjB;AACD,G;;;;;;;kBAMD,c,GAAA,SAAA,cAAA,CAAe,WAAf,EAA4B,UAA5B,EAAwC;AACtC,SAAK,SAAL,CAAe,UAAf,EAA2B,WAA3B,EAAwC,CAAxC;;AACA,QAAI,CAAC,KAAK,eAAV,EAA2B;AACzB,WAAK,eAAL,GAAuB,EAAvB;AACD;;AACD,SAAK,eAAL,CAAqB,MAArB,GAA8B,iBAAiB,CAC7C,KAAK,eADwC,EACvB,CADuB,EACpB,WADoB,EACP,KAAK,MADE,CAA/C;AAEA,SAAK,OAAL;AACD,G;;;CArF+B,CAAd,cAAc,CAAlC;;AAyFA,eAAe,KAAf","sourcesContent":["/**\n * @module ol/geom/Point\n */\nimport {createOrUpdateFromCoordinate, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   */\n  constructor(coordinates, opt_layout) {\n    super();\n    this.setCoordinates(coordinates, opt_layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @override\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    return point;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @override\n   * @api\n   */\n  getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getType() {\n    return GeometryType.POINT;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n}\n\n\nexport default Point;\n"]},"metadata":{},"sourceType":"module"}