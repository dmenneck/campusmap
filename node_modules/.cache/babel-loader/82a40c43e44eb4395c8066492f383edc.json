{"ast":null,"code":"/**\n * @module ol/style/Atlas\n */\nimport { createCanvasContext2D } from '../dom.js';\n/**\n * @typedef {Object} AtlasBlock\n * @property {number} x\n * @property {number} y\n * @property {number} width\n * @property {number} height\n */\n\n/**\n * Provides information for an image inside an atlas.\n * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\n * @typedef {Object} AtlasInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n */\n\n/**\n * @classesc\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\n\nvar Atlas = function Atlas(size, space) {\n  /**\n   * @private\n   * @type {number}\n   */\n  this.space_ = space;\n  /**\n   * @private\n   * @type {Array<AtlasBlock>}\n   */\n\n  this.emptyBlocks_ = [{\n    x: 0,\n    y: 0,\n    width: size,\n    height: size\n  }];\n  /**\n   * @private\n   * @type {Object<string, AtlasInfo>}\n   */\n\n  this.entries_ = {};\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n\n  this.context_ = createCanvasContext2D(size, size);\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = this.context_.canvas;\n};\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?AtlasInfo} The atlas info.\n */\n\n\nAtlas.prototype.get = function get(id) {\n  return this.entries_[id] || null;\n};\n/**\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback`.\n * @return {?AtlasInfo} The position and atlas image for the entry.\n */\n\n\nAtlas.prototype.add = function add(id, width, height, renderCallback, opt_this) {\n  for (var i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n    var block = this.emptyBlocks_[i];\n\n    if (block.width >= width + this.space_ && block.height >= height + this.space_) {\n      // we found a block that is big enough for our entry\n      var entry = {\n        offsetX: block.x + this.space_,\n        offsetY: block.y + this.space_,\n        image: this.canvas_\n      };\n      this.entries_[id] = entry; // render the image on the atlas image\n\n      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_); // split the block after the insertion, either horizontally or vertically\n\n      this.split_(i, block, width + this.space_, height + this.space_);\n      return entry;\n    }\n  } // there is no space for the new entry in this atlas\n\n\n  return null;\n};\n/**\n * @private\n * @param {number} index The index of the block.\n * @param {AtlasBlock} block The block to split.\n * @param {number} width The width of the entry to insert.\n * @param {number} height The height of the entry to insert.\n */\n\n\nAtlas.prototype.split_ = function split_(index, block, width, height) {\n  var deltaWidth = block.width - width;\n  var deltaHeight = block.height - height;\n  /** @type {AtlasBlock} */\n\n  var newBlock1;\n  /** @type {AtlasBlock} */\n\n  var newBlock2;\n\n  if (deltaWidth > deltaHeight) {\n    // split vertically\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: block.height\n    }; // block below the inserted entry\n\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  } else {\n    // split horizontally\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: height\n    }; // block below the inserted entry\n\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: block.width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  }\n};\n/**\n * Remove the old block and insert new blocks at the same array position.\n * The new blocks are inserted at the same position, so that splitted\n * blocks (that are potentially smaller) are filled first.\n * @private\n * @param {number} index The index of the block to remove.\n * @param {AtlasBlock} newBlock1 The 1st block to add.\n * @param {AtlasBlock} newBlock2 The 2nd block to add.\n */\n\n\nAtlas.prototype.updateBlocks_ = function updateBlocks_(index, newBlock1, newBlock2) {\n  var args =\n  /** @type {Array<*>} */\n  [index, 1];\n\n  if (newBlock1.width > 0 && newBlock1.height > 0) {\n    args.push(newBlock1);\n  }\n\n  if (newBlock2.width > 0 && newBlock2.height > 0) {\n    args.push(newBlock2);\n  }\n\n  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n};\n\nexport default Atlas;","map":{"version":3,"sources":["../../../src/ol/style/Atlas.js"],"names":["let","const"],"mappings":"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","sourcesContent":["/**\n * @module ol/style/Atlas\n */\nimport {createCanvasContext2D} from '../dom.js';\n\n\n/**\n * @typedef {Object} AtlasBlock\n * @property {number} x\n * @property {number} y\n * @property {number} width\n * @property {number} height\n */\n\n/**\n * Provides information for an image inside an atlas.\n * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\n * @typedef {Object} AtlasInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n */\n\n\n/**\n * @classesc\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\nclass Atlas {\n\n  /**\n   * @param {number} size The size in pixels of the sprite image.\n   * @param {number} space The space in pixels between images.\n   *    Because texture coordinates are float values, the edges of\n   *    images might not be completely correct (in a way that the\n   *    edges overlap when being rendered). To avoid this we add a\n   *    padding around each image.\n   */\n  constructor(size, space) {\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.space_ = space;\n\n    /**\n     * @private\n     * @type {Array<AtlasBlock>}\n     */\n    this.emptyBlocks_ = [{x: 0, y: 0, width: size, height: size}];\n\n    /**\n     * @private\n     * @type {Object<string, AtlasInfo>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context_ = createCanvasContext2D(size, size);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = this.context_.canvas;\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?AtlasInfo} The atlas info.\n   */\n  get(id) {\n    return this.entries_[id] || null;\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback`.\n   * @return {?AtlasInfo} The position and atlas image for the entry.\n   */\n  add(id, width, height, renderCallback, opt_this) {\n    for (let i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n      const block = this.emptyBlocks_[i];\n      if (block.width >= width + this.space_ &&\n          block.height >= height + this.space_) {\n        // we found a block that is big enough for our entry\n        const entry = {\n          offsetX: block.x + this.space_,\n          offsetY: block.y + this.space_,\n          image: this.canvas_\n        };\n        this.entries_[id] = entry;\n\n        // render the image on the atlas image\n        renderCallback.call(opt_this, this.context_,\n          block.x + this.space_, block.y + this.space_);\n\n        // split the block after the insertion, either horizontally or vertically\n        this.split_(i, block, width + this.space_, height + this.space_);\n\n        return entry;\n      }\n    }\n\n    // there is no space for the new entry in this atlas\n    return null;\n  }\n\n  /**\n   * @private\n   * @param {number} index The index of the block.\n   * @param {AtlasBlock} block The block to split.\n   * @param {number} width The width of the entry to insert.\n   * @param {number} height The height of the entry to insert.\n   */\n  split_(index, block, width, height) {\n    const deltaWidth = block.width - width;\n    const deltaHeight = block.height - height;\n\n    /** @type {AtlasBlock} */\n    let newBlock1;\n    /** @type {AtlasBlock} */\n    let newBlock2;\n\n    if (deltaWidth > deltaHeight) {\n      // split vertically\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: block.height\n      };\n\n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    } else {\n      // split horizontally\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: height\n      };\n\n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: block.width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    }\n  }\n\n  /**\n   * Remove the old block and insert new blocks at the same array position.\n   * The new blocks are inserted at the same position, so that splitted\n   * blocks (that are potentially smaller) are filled first.\n   * @private\n   * @param {number} index The index of the block to remove.\n   * @param {AtlasBlock} newBlock1 The 1st block to add.\n   * @param {AtlasBlock} newBlock2 The 2nd block to add.\n   */\n  updateBlocks_(index, newBlock1, newBlock2) {\n    const args = /** @type {Array<*>} */ ([index, 1]);\n    if (newBlock1.width > 0 && newBlock1.height > 0) {\n      args.push(newBlock1);\n    }\n    if (newBlock2.width > 0 && newBlock2.height > 0) {\n      args.push(newBlock2);\n    }\n    this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n  }\n}\n\nexport default Atlas;\n"]},"metadata":{},"sourceType":"module"}