{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, createEmpty, containsExtent, getWidth } from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\n\nvar CanvasVectorLayerRenderer =\n/*@__PURE__*/\nfunction (CanvasLayerRenderer) {\n  function CanvasVectorLayerRenderer(vectorLayer) {\n    CanvasLayerRenderer.call(this, vectorLayer);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedResolution_ = NaN;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.renderedExtent_ = createEmpty();\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n\n    this.renderedRenderOrder_ = null;\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ReplayGroup.js\").default}\n     */\n\n    this.replayGroup_ = null;\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n\n    this.replayGroupChanged = true;\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = createCanvasContext2D();\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n\n  if (CanvasLayerRenderer) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;\n  CanvasVectorLayerRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasLayerRenderer.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.compose = function compose(context, frameState, layerState) {\n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource =\n    /** @type {import(\"../../source/Vector.js\").default} */\n    this.getLayer().getSource();\n    var transform = this.getTransform(frameState, 0); // clipped rendering if layer extent is set\n\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n\n    if (clipped) {\n      this.clip(context, frameState,\n      /** @type {import(\"../../extent.js\").Extent} */\n      clipExtent);\n    }\n\n    var replayGroup = this.replayGroup_;\n\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n\n      var layer =\n      /** @type {import(\"../../layer/Vector.js\").default} */\n      this.getLayer();\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        } // resize and clear\n\n\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      var alpha = replayContext.globalAlpha;\n\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation, width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n\n      if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = getWidth(projectionExtent);\n        var world = 0;\n        var offsetX;\n\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX += worldWidth;\n        }\n\n        world = 0;\n        startX = extent[2];\n\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX -= worldWidth;\n        }\n      }\n\n      rotateAtOffset(replayContext, rotation, width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n\n      if (replayContext != context) {\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    var transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer =\n      /** @type {import(\"../../layer/Vector.js\").default} */\n      this.getLayer();\n      /** @type {!Object<string, boolean>} */\n\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @return {?} Callback result.\n       */\n      function (feature) {\n        var key = getUid(feature);\n\n        if (!(key in features)) {\n          features[key] = true;\n          return callback.call(thisArg, feature, layer);\n        }\n      }, null);\n      return result;\n    }\n  };\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var vectorLayer =\n    /** @type {import(\"../../layer/Vector.js\").default} */\n    this.getLayer();\n    var vectorSource =\n    /** @type {import(\"../../source/Vector.js\").default} */\n    vectorLayer.getSource();\n    var animating = frameState.viewHints[ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n      return true;\n    }\n\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = getWidth(projectionExtent);\n      var gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n    this.dirty_ = false;\n    var replayGroup = new CanvasReplayGroup(getRenderTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     * @this {CanvasVectorLayerRenderer}\n     */\n\n    var render = function (feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n\n      if (styles) {\n        var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n\n    if (vectorLayerRenderOrder) {\n      /** @type {Array<import(\"../../Feature.js\").default>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       */\n      function (feature) {\n        features.push(feature);\n      });\n      features.sort(vectorLayerRenderOrder);\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render);\n    }\n\n    replayGroup.finish();\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n    this.replayGroupChanged = true;\n    return true;\n  };\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], getSquaredRenderTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, getSquaredRenderTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);\n    }\n\n    return loading;\n  };\n\n  return CanvasVectorLayerRenderer;\n}(CanvasLayerRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasVectorLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorLayerRenderer} The layer renderer.\n */\n\n\nCanvasVectorLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(\n  /** @type {import(\"../../layer/Vector.js\").default} */\n  layer);\n};\n\nexport default CanvasVectorLayerRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/VectorLayer.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, createEmpty, containsExtent, getWidth} from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport {defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/Vector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n\n    super(vectorLayer);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ReplayGroup.js\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = createCanvasContext2D();\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  compose(context, frameState, layerState) {\n    const extent = frameState.extent;\n    const pixelRatio = frameState.pixelRatio;\n    const skippedFeatureUids = layerState.managed ?\n      frameState.skippedFeatureUids : {};\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = /** @type {import(\"../../source/Vector.js\").default} */ (this.getLayer().getSource());\n\n    let transform = this.getTransform(frameState, 0);\n\n    // clipped rendering if layer extent is set\n    const clipExtent = layerState.extent;\n    const clipped = clipExtent !== undefined;\n    if (clipped) {\n      this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */ (clipExtent));\n    }\n    const replayGroup = this.replayGroup_;\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n      const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n      let drawOffsetX = 0;\n      let drawOffsetY = 0;\n      let replayContext;\n      const transparentLayer = layerState.opacity !== 1;\n      const hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n      if (transparentLayer || hasRenderListeners) {\n        let drawWidth = context.canvas.width;\n        let drawHeight = context.canvas.height;\n        if (rotation) {\n          const drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        }\n        // resize and clear\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      const alpha = replayContext.globalAlpha;\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      const viewHints = frameState.viewHints;\n      const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      const width = frameState.size[0] * pixelRatio;\n      const height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation,\n        width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n      if (vectorSource.getWrapX() && projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)) {\n        let startX = extent[0];\n        const worldWidth = getWidth(projectionExtent);\n        let world = 0;\n        let offsetX;\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX += worldWidth;\n        }\n        world = 0;\n        startX = extent[2];\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX -= worldWidth;\n        }\n      }\n      rotateAtOffset(replayContext, rotation,\n        width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n      if (replayContext != context) {\n        if (transparentLayer) {\n          const mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  composeFrame(frameState, layerState, context) {\n    const transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      const resolution = frameState.viewState.resolution;\n      const rotation = frameState.viewState.rotation;\n      const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n      /** @type {!Object<string, boolean>} */\n      const features = {};\n      const result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          const key = getUid(feature);\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      return result;\n    }\n  }\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  handleFontsChanged_(event) {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n    const vectorLayer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const vectorSource = /** @type {import(\"../../source/Vector.js\").default} */ (vectorLayer.getSource());\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && (!updateWhileAnimating && animating) ||\n        (!updateWhileInteracting && interacting)) {\n      return true;\n    }\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const extent = buffer(frameStateExtent,\n      vectorLayerRenderBuffer * resolution);\n    const projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&\n        !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ &&\n        this.renderedResolution_ == resolution &&\n        this.renderedRevision_ == vectorLayerRevision &&\n        this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n        containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    this.dirty_ = false;\n\n    const replayGroup = new CanvasReplayGroup(\n      getRenderTolerance(resolution, pixelRatio), extent, resolution,\n      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     * @this {CanvasVectorLayerRenderer}\n     */\n    const render = function(feature) {\n      let styles;\n      const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n      if (styles) {\n        const dirty = this.renderFeature(\n          feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    if (vectorLayerRenderOrder) {\n      /** @type {Array<import(\"../../Feature.js\").default>} */\n      const features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n        /**\n         * @param {import(\"../../Feature.js\").default} feature Feature.\n         */\n        function(feature) {\n          features.push(feature);\n        });\n      features.sort(vectorLayerRenderOrder);\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render);\n    }\n    replayGroup.finish();\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i],\n          getSquaredRenderTolerance(resolution, pixelRatio),\n          this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles,\n        getSquaredRenderTolerance(resolution, pixelRatio),\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorLayerRenderer} The layer renderer.\n */\nCanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(/** @type {import(\"../../layer/Vector.js\").default} */ (layer));\n};\n\n\nexport default CanvasVectorLayerRenderer;\n"]},"metadata":{},"sourceType":"module"}