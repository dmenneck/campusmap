{"ast":null,"code":"/**\n * @module ol/render/canvas/ReplayGroup\n */\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { isEmpty } from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport { ORDER } from '../replay.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\n\nvar BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\n\nvar CanvasReplayGroup =\n/*@__PURE__*/\nfunction (ReplayGroup) {\n  function CanvasReplayGroup(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n    ReplayGroup.call(this);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = declutterTree;\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n\n    this.declutterGroup_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.tolerance_ = tolerance;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n\n    this.replaysByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.hitDetectionTransform_ = createTransform();\n  }\n\n  if (ReplayGroup) CanvasReplayGroup.__proto__ = ReplayGroup;\n  CanvasReplayGroup.prototype = Object.create(ReplayGroup && ReplayGroup.prototype);\n  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n    var declutter = null;\n\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */\n\n        declutter[4]++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n\n    return declutter;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n\n\n  CanvasReplayGroup.prototype.clip = function clip(context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n\n\n  CanvasReplayGroup.prototype.hasReplays = function hasReplays(replays) {\n    for (var zIndex in this.replaysByZIndex_) {\n      var candidates = this.replaysByZIndex_[zIndex];\n\n      for (var i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * FIXME empty description for jsdoc\n   */\n\n\n  CanvasReplayGroup.prototype.finish = function finish() {\n    for (var zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n\n      for (var replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n\n\n    var hitExtent;\n\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    var mask = getCircleArray(hitTolerance);\n    var declutteredFeatures;\n\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function (entry) {\n        return entry.value;\n      });\n    }\n\n    var replayType;\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n\n      for (var i = 0; i < contextSize; i++) {\n        for (var j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              var result = void 0;\n\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n    /** @type {Array<number>} */\n\n\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, replays, replay, result;\n\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n\n        if (replay !== undefined) {\n          if (declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = declutterReplays[zIndexKey];\n\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n\n\n  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords(transform) {\n    var maxExtent = this.maxExtent_;\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    var replays = this.replaysByZIndex_[zIndexKey];\n\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n\n    var replay = replays[replayType];\n\n    if (replay === undefined) {\n      var Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n\n    return replay;\n  };\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n\n\n  CanvasReplayGroup.prototype.getReplays = function getReplays() {\n    return this.replaysByZIndex_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1() {\n    return isEmpty(this.replaysByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n\n\n  CanvasReplayGroup.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel, opt_replayTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n\n    context.save();\n    this.clip(context, transform);\n    var replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        var replayType = replayTypes[j];\n        replay = replays[replayType];\n\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n\n    context.restore();\n  };\n\n  return CanvasReplayGroup;\n}(ReplayGroup);\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\n\n\nvar circleArrayCache = {\n  0: [[true]]\n};\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\n\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\n\n\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  var x = radius;\n  var y = 0;\n  var error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\n\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  var skippedFeatureUids = {};\n\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var replayData = declutterReplays[zs[z].toString()];\n\n    for (var i = 0, ii = replayData.length; i < ii;) {\n      var replay = replayData[i++];\n      var transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\nexport default CanvasReplayGroup;","map":{"version":3,"sources":["../../../../src/ol/render/canvas/ReplayGroup.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/ReplayGroup\n */\n\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {isEmpty} from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport {ORDER} from '../replay.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\nconst BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\n\n\nclass CanvasReplayGroup extends ReplayGroup {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay group can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree for declutter processing in postrender.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  constructor(\n    tolerance,\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    declutterTree,\n    opt_renderBuffer\n  ) {\n    super();\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n    this.replaysByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addDeclutter(group) {\n    let declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */ (declutter[4])++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  hasReplays(replays) {\n    for (const zIndex in this.replaysByZIndex_) {\n      const candidates = this.replaysByZIndex_[zIndex];\n      for (let i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  finish() {\n    for (const zKey in this.replaysByZIndex_) {\n      const replays = this.replaysByZIndex_[zKey];\n      for (const replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    skippedFeaturesHash,\n    callback,\n    declutterReplays\n  ) {\n\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(this.hitDetectionTransform_,\n      hitTolerance + 0.5, hitTolerance + 0.5,\n      1 / resolution, -1 / resolution,\n      -rotation,\n      -coordinate[0], -coordinate[1]);\n    const context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    const mask = getCircleArray(hitTolerance);\n    let declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function(entry) {\n        return entry.value;\n      });\n    }\n\n    let replayType;\n\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (let i = 0; i < contextSize; i++) {\n        for (let j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              let result;\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) ||\n                  declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation,\n              skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(\n      flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getReplay(zIndex, replayType) {\n    const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    let replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    let replay = replays[replayType];\n    if (replay === undefined) {\n      const Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_,\n        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  }\n\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n  getReplays() {\n    return this.replaysByZIndex_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isEmpty() {\n    return isEmpty(this.replaysByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  replay(\n    context,\n    transform,\n    viewRotation,\n    skippedFeaturesHash,\n    snapToPixel,\n    opt_replayTypes,\n    opt_declutterReplays\n  ) {\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n\n    const replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    let i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        const replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n\n    context.restore();\n  }\n}\n\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nconst circleArrayCache = {\n  0: [[true]]\n};\n\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  let i;\n  const radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  const arraySize = radius * 2 + 1;\n  const arr = new Array(arraySize);\n  for (let i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  let x = radius;\n  let y = 0;\n  let error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  const zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  const skippedFeatureUids = {};\n  for (let z = 0, zz = zs.length; z < zz; ++z) {\n    const replayData = declutterReplays[zs[z].toString()];\n    for (let i = 0, ii = replayData.length; i < ii;) {\n      const replay = replayData[i++];\n      const transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\n\n\nexport default CanvasReplayGroup;\n"]},"metadata":{},"sourceType":"module"}