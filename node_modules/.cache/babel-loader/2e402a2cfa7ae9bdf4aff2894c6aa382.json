{"ast":null,"code":"/**\n * @module ol/interaction/DragAndDrop\n */\n// FIXME should handle all geo-referenced data, not just vector data\nimport { inherits } from '../util.js';\nimport { TRUE } from '../functions.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Interaction from '../interaction/Interaction.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {Array.<function(new: module:ol/format/Feature)>} [formatConstructors] Format constructors.\n * @property {module:ol/source/Vector} [source] Optional vector source where features will be added.  If a source is provided\n * all existing features will be removed and new features will be added when\n * they are dropped on the target.  If you want to add features to a vector\n * source without removing the existing features (append only), instead of\n * providing the source option listen for the \"addfeatures\" event.\n * @property {module:ol/proj~ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n * @property {Element} [target] The element that is used as the drop target, default is the viewport element.\n */\n\n/**\n * @enum {string}\n */\n\nconst DragAndDropEventType = {\n  /**\n   * Triggered when features are added\n   * @event module:ol/interaction/DragAndDrop~DragAndDropEvent#addfeatures\n   * @api\n   */\n  ADD_FEATURES: 'addfeatures'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n * of this type.\n *\n * @constructor\n * @extends {module:ol/events/Event}\n * @param {module:ol/interaction/DragAndDrop~DragAndDropEventType} type Type.\n * @param {File} file File.\n * @param {Array.<module:ol/Feature>=} opt_features Features.\n * @param {module:ol/proj/Projection=} opt_projection Projection.\n */\n\nconst DragAndDropEvent = function (type, file, opt_features, opt_projection) {\n  Event.call(this, type);\n  /**\n   * The features parsed from dropped data.\n   * @type {Array.<module:ol/Feature>|undefined}\n   * @api\n   */\n\n  this.features = opt_features;\n  /**\n   * The dropped file.\n   * @type {File}\n   * @api\n   */\n\n  this.file = file;\n  /**\n   * The feature projection.\n   * @type {module:ol/proj/Projection|undefined}\n   * @api\n   */\n\n  this.projection = opt_projection;\n};\n\ninherits(DragAndDropEvent, Event);\n/**\n * @classdesc\n * Handles input of vector data by drag and drop.\n *\n * @constructor\n * @extends {module:ol/interaction/Interaction}\n * @fires module:ol/interaction/DragAndDrop~DragAndDropEvent\n * @param {module:ol/interaction/DragAndDrop~Options=} opt_options Options.\n * @api\n */\n\nconst DragAndDrop = function (opt_options) {\n  const options = opt_options ? opt_options : {};\n  Interaction.call(this, {\n    handleEvent: TRUE\n  });\n  /**\n   * @private\n   * @type {Array.<function(new: module:ol/format/Feature)>}\n   */\n\n  this.formatConstructors_ = options.formatConstructors ? options.formatConstructors : [];\n  /**\n   * @private\n   * @type {module:ol/proj/Projection}\n   */\n\n  this.projection_ = options.projection ? getProjection(options.projection) : null;\n  /**\n   * @private\n   * @type {Array.<module:ol/events~EventsKey>}\n   */\n\n  this.dropListenKeys_ = null;\n  /**\n   * @private\n   * @type {module:ol/source/Vector}\n   */\n\n  this.source_ = options.source || null;\n  /**\n   * @private\n   * @type {Element}\n   */\n\n  this.target = options.target ? options.target : null;\n};\n\ninherits(DragAndDrop, Interaction);\n/**\n * @param {DragEvent} event Event.\n * @this {module:ol/interaction/DragAndDrop}\n */\n\nfunction handleDrop(event) {\n  const files = event.dataTransfer.files;\n\n  for (let i = 0, ii = files.length; i < ii; ++i) {\n    const file = files.item(i);\n    const reader = new FileReader();\n    reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));\n    reader.readAsText(file);\n  }\n}\n/**\n * @param {DragEvent} event Event.\n */\n\n\nfunction handleStop(event) {\n  event.stopPropagation();\n  event.preventDefault();\n  event.dataTransfer.dropEffect = 'copy';\n}\n/**\n * @param {File} file File.\n * @param {Event} event Load event.\n * @private\n */\n\n\nDragAndDrop.prototype.handleResult_ = function (file, event) {\n  const result = event.target.result;\n  const map = this.getMap();\n  let projection = this.projection_;\n\n  if (!projection) {\n    const view = map.getView();\n    projection = view.getProjection();\n  }\n\n  const formatConstructors = this.formatConstructors_;\n  let features = [];\n\n  for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\n    /**\n     * Avoid \"cannot instantiate abstract class\" error.\n     * @type {Function}\n     */\n    const formatConstructor = formatConstructors[i];\n    /**\n     * @type {module:ol/format/Feature}\n     */\n\n    const format = new formatConstructor();\n    features = this.tryReadFeatures_(format, result, {\n      featureProjection: projection\n    });\n\n    if (features && features.length > 0) {\n      break;\n    }\n  }\n\n  if (this.source_) {\n    this.source_.clear();\n    this.source_.addFeatures(features);\n  }\n\n  this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));\n};\n/**\n * @private\n */\n\n\nDragAndDrop.prototype.registerListeners_ = function () {\n  const map = this.getMap();\n\n  if (map) {\n    const dropArea = this.target ? this.target : map.getViewport();\n    this.dropListenKeys_ = [listen(dropArea, EventType.DROP, handleDrop, this), listen(dropArea, EventType.DRAGENTER, handleStop, this), listen(dropArea, EventType.DRAGOVER, handleStop, this), listen(dropArea, EventType.DROP, handleStop, this)];\n  }\n};\n/**\n * @inheritDoc\n */\n\n\nDragAndDrop.prototype.setActive = function (active) {\n  Interaction.prototype.setActive.call(this, active);\n\n  if (active) {\n    this.registerListeners_();\n  } else {\n    this.unregisterListeners_();\n  }\n};\n/**\n * @inheritDoc\n */\n\n\nDragAndDrop.prototype.setMap = function (map) {\n  this.unregisterListeners_();\n  Interaction.prototype.setMap.call(this, map);\n\n  if (this.getActive()) {\n    this.registerListeners_();\n  }\n};\n/**\n * @param {module:ol/format/Feature} format Format.\n * @param {string} text Text.\n * @param {module:ol/format/Feature~ReadOptions} options Read options.\n * @private\n * @return {Array.<module:ol/Feature>} Features.\n */\n\n\nDragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {\n  try {\n    return format.readFeatures(text, options);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n * @private\n */\n\n\nDragAndDrop.prototype.unregisterListeners_ = function () {\n  if (this.dropListenKeys_) {\n    this.dropListenKeys_.forEach(unlistenByKey);\n    this.dropListenKeys_ = null;\n  }\n};\n\nexport default DragAndDrop;","map":null,"metadata":{},"sourceType":"module"}