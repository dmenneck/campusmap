{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport { getUid, inherits } from '../util.js';\nimport { CollectionEvent } from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment } from '../coordinate.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport PointerInteraction, { handleEvent as handlePointerEvent } from '../interaction/Pointer.js';\nimport { getValues } from '../obj.js';\nimport { VectorSourceEvent } from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {module:ol/coordinate~Coordinate|null} vertex\n * @property {module:ol~Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {module:ol/Feature} feature\n * @property {Array.<module:ol/coordinate~Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @constructor\n * @extends {module:ol/interaction/Pointer}\n * @param {module:ol/interaction/Snap~Options=} opt_options Options.\n * @api\n */\n\nconst Snap = function (opt_options) {\n  PointerInteraction.call(this, {\n    handleEvent: handleEvent,\n    handleDownEvent: TRUE,\n    handleUpEvent: handleUpEvent\n  });\n  const options = opt_options ? opt_options : {};\n  /**\n   * @type {module:ol/source/Vector}\n   * @private\n   */\n\n  this.source_ = options.source ? options.source : null;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.edge_ = options.edge !== undefined ? options.edge : true;\n  /**\n   * @type {module:ol/Collection.<module:ol/Feature>}\n   * @private\n   */\n\n  this.features_ = options.features ? options.features : null;\n  /**\n   * @type {Array.<module:ol/events~EventsKey>}\n   * @private\n   */\n\n  this.featuresListenerKeys_ = [];\n  /**\n   * @type {Object.<number, module:ol/events~EventsKey>}\n   * @private\n   */\n\n  this.featureChangeListenerKeys_ = {};\n  /**\n   * Extents are preserved so indexed segment can be quickly removed\n   * when its feature geometry changes\n   * @type {Object.<number, module:ol/extent~Extent>}\n   * @private\n   */\n\n  this.indexedFeaturesExtents_ = {};\n  /**\n   * If a feature geometry changes while a pointer drag|move event occurs, the\n   * feature doesn't get updated right away.  It will be at the next 'pointerup'\n   * event fired.\n   * @type {!Object.<number, module:ol/Feature>}\n   * @private\n   */\n\n  this.pendingFeatures_ = {};\n  /**\n   * Used for distance sorting in sortByDistance_\n   * @type {module:ol/coordinate~Coordinate}\n   * @private\n   */\n\n  this.pixelCoordinate_ = null;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n  /**\n   * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}\n   * @private\n   */\n\n  this.sortByDistance_ = sortByDistance.bind(this);\n  /**\n  * Segment RTree for each layer\n  * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}\n  * @private\n  */\n\n  this.rBush_ = new RBush();\n  /**\n  * @const\n  * @private\n  * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}\n  */\n\n  this.SEGMENT_WRITERS_ = {\n    'Point': this.writePointGeometry_,\n    'LineString': this.writeLineStringGeometry_,\n    'LinearRing': this.writeLineStringGeometry_,\n    'Polygon': this.writePolygonGeometry_,\n    'MultiPoint': this.writeMultiPointGeometry_,\n    'MultiLineString': this.writeMultiLineStringGeometry_,\n    'MultiPolygon': this.writeMultiPolygonGeometry_,\n    'GeometryCollection': this.writeGeometryCollectionGeometry_,\n    'Circle': this.writeCircleGeometry_\n  };\n};\n\ninherits(Snap, PointerInteraction);\n/**\n * Add a feature to the collection of features that we may snap to.\n * @param {module:ol/Feature} feature Feature.\n * @param {boolean=} opt_listen Whether to listen to the feature change or not\n *     Defaults to `true`.\n * @api\n */\n\nSnap.prototype.addFeature = function (feature, opt_listen) {\n  const register = opt_listen !== undefined ? opt_listen : true;\n  const feature_uid = getUid(feature);\n  const geometry = feature.getGeometry();\n\n  if (geometry) {\n    const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n\n    if (segmentWriter) {\n      this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n      segmentWriter.call(this, feature, geometry);\n    }\n  }\n\n  if (register) {\n    this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature.\n * @private\n */\n\n\nSnap.prototype.forEachFeatureAdd_ = function (feature) {\n  this.addFeature(feature);\n};\n/**\n * @param {module:ol/Feature} feature Feature.\n * @private\n */\n\n\nSnap.prototype.forEachFeatureRemove_ = function (feature) {\n  this.removeFeature(feature);\n};\n/**\n * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.\n * @private\n */\n\n\nSnap.prototype.getFeatures_ = function () {\n  let features;\n\n  if (this.features_) {\n    features = this.features_;\n  } else if (this.source_) {\n    features = this.source_.getFeatures();\n  }\n\n  return (\n    /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */\n    features\n  );\n};\n/**\n * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n * @private\n */\n\n\nSnap.prototype.handleFeatureAdd_ = function (evt) {\n  let feature;\n\n  if (evt instanceof VectorSourceEvent) {\n    feature = evt.feature;\n  } else if (evt instanceof CollectionEvent) {\n    feature = evt.element;\n  }\n\n  this.addFeature(\n  /** @type {module:ol/Feature} */\n  feature);\n};\n/**\n * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.\n * @private\n */\n\n\nSnap.prototype.handleFeatureRemove_ = function (evt) {\n  let feature;\n\n  if (evt instanceof VectorSourceEvent) {\n    feature = evt.feature;\n  } else if (evt instanceof CollectionEvent) {\n    feature = evt.element;\n  }\n\n  this.removeFeature(\n  /** @type {module:ol/Feature} */\n  feature);\n};\n/**\n * @param {module:ol/events/Event} evt Event.\n * @private\n */\n\n\nSnap.prototype.handleFeatureChange_ = function (evt) {\n  const feature =\n  /** @type {module:ol/Feature} */\n  evt.target;\n\n  if (this.handlingDownUpSequence) {\n    const uid = getUid(feature);\n\n    if (!(uid in this.pendingFeatures_)) {\n      this.pendingFeatures_[uid] = feature;\n    }\n  } else {\n    this.updateFeature_(feature);\n  }\n};\n/**\n * Remove a feature from the collection of features that we may snap to.\n * @param {module:ol/Feature} feature Feature\n * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n *     or not. Defaults to `true`.\n * @api\n */\n\n\nSnap.prototype.removeFeature = function (feature, opt_unlisten) {\n  const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n  const feature_uid = getUid(feature);\n  const extent = this.indexedFeaturesExtents_[feature_uid];\n\n  if (extent) {\n    const rBush = this.rBush_;\n    const nodesToRemove = [];\n    rBush.forEachInExtent(extent, function (node) {\n      if (feature === node.feature) {\n        nodesToRemove.push(node);\n      }\n    });\n\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n      rBush.remove(nodesToRemove[i]);\n    }\n  }\n\n  if (unregister) {\n    unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n    delete this.featureChangeListenerKeys_[feature_uid];\n  }\n};\n/**\n * @inheritDoc\n */\n\n\nSnap.prototype.setMap = function (map) {\n  const currentMap = this.getMap();\n  const keys = this.featuresListenerKeys_;\n  const features = this.getFeatures_();\n\n  if (currentMap) {\n    keys.forEach(unlistenByKey);\n    keys.length = 0;\n    features.forEach(this.forEachFeatureRemove_.bind(this));\n  }\n\n  PointerInteraction.prototype.setMap.call(this, map);\n\n  if (map) {\n    if (this.features_) {\n      keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n    } else if (this.source_) {\n      keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n    }\n\n    features.forEach(this.forEachFeatureAdd_.bind(this));\n  }\n};\n/**\n * @inheritDoc\n */\n\n\nSnap.prototype.shouldStopEvent = FALSE;\n/**\n * @param {module:ol~Pixel} pixel Pixel\n * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate\n * @param {module:ol/PluggableMap} map Map.\n * @return {module:ol/interaction/Snap~Result} Snap result\n */\n\nSnap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n  const lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n  const upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n  const box = boundingExtent([lowerLeft, upperRight]);\n  let segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles\n\n  if (this.vertex_ && !this.edge_) {\n    segments = segments.filter(function (segment) {\n      return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n    });\n  }\n\n  let snappedToVertex = false;\n  let snapped = false;\n  let vertex = null;\n  let vertexPixel = null;\n  let dist, pixel1, pixel2, squaredDist1, squaredDist2;\n\n  if (segments.length > 0) {\n    this.pixelCoordinate_ = pixelCoordinate;\n    segments.sort(this.sortByDistance_);\n    const closestSegment = segments[0].segment;\n    const isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n\n    if (this.vertex_ && !this.edge_) {\n      pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n      pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n      squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n      squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n      dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n      snappedToVertex = dist <= this.pixelTolerance_;\n\n      if (snappedToVertex) {\n        snapped = true;\n        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n      }\n    } else if (this.edge_) {\n      if (isCircle) {\n        vertex = closestOnCircle(pixelCoordinate,\n        /** @type {module:ol/geom/Circle} */\n        segments[0].feature.getGeometry());\n      } else {\n        vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      }\n\n      vertexPixel = map.getPixelFromCoordinate(vertex);\n\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        snapped = true;\n\n        if (this.vertex_ && !isCircle) {\n          pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          snappedToVertex = dist <= this.pixelTolerance_;\n\n          if (snappedToVertex) {\n            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n          }\n        }\n      }\n    }\n\n    if (snapped) {\n      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n    }\n  }\n\n  return (\n    /** @type {module:ol/interaction/Snap~Result} */\n    {\n      snapped: snapped,\n      vertex: vertex,\n      vertexPixel: vertexPixel\n    }\n  );\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @private\n */\n\n\nSnap.prototype.updateFeature_ = function (feature) {\n  this.removeFeature(feature, false);\n  this.addFeature(feature, false);\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/Circle} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeCircleGeometry_ = function (feature, geometry) {\n  const polygon = fromCircle(geometry);\n  const coordinates = polygon.getCoordinates()[0];\n\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const segment = coordinates.slice(i, i + 2);\n    const segmentData =\n    /** @type {module:ol/interaction/Snap~SegmentData} */\n    {\n      feature: feature,\n      segment: segment\n    };\n    this.rBush_.insert(boundingExtent(segment), segmentData);\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/GeometryCollection} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {\n  const geometries = geometry.getGeometriesArray();\n\n  for (let i = 0; i < geometries.length; ++i) {\n    const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n\n    if (segmentWriter) {\n      segmentWriter.call(this, feature, geometries[i]);\n    }\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/LineString} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeLineStringGeometry_ = function (feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const segment = coordinates.slice(i, i + 2);\n    const segmentData =\n    /** @type {module:ol/interaction/Snap~SegmentData} */\n    {\n      feature: feature,\n      segment: segment\n    };\n    this.rBush_.insert(boundingExtent(segment), segmentData);\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/MultiLineString} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {\n  const lines = geometry.getCoordinates();\n\n  for (let j = 0, jj = lines.length; j < jj; ++j) {\n    const coordinates = lines[j];\n\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData =\n      /** @type {module:ol/interaction/Snap~SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/MultiPoint} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {\n  const points = geometry.getCoordinates();\n\n  for (let i = 0, ii = points.length; i < ii; ++i) {\n    const coordinates = points[i];\n    const segmentData =\n    /** @type {module:ol/interaction/Snap~SegmentData} */\n    {\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/MultiPolygon} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {\n  const polygons = geometry.getCoordinates();\n\n  for (let k = 0, kk = polygons.length; k < kk; ++k) {\n    const rings = polygons[k];\n\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData =\n        /** @type {module:ol/interaction/Snap~SegmentData} */\n        {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/Point} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writePointGeometry_ = function (feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n  const segmentData =\n  /** @type {module:ol/interaction/Snap~SegmentData} */\n  {\n    feature: feature,\n    segment: [coordinates, coordinates]\n  };\n  this.rBush_.insert(geometry.getExtent(), segmentData);\n};\n/**\n * @param {module:ol/Feature} feature Feature\n * @param {module:ol/geom/Polygon} geometry Geometry.\n * @private\n */\n\n\nSnap.prototype.writePolygonGeometry_ = function (feature, geometry) {\n  const rings = geometry.getCoordinates();\n\n  for (let j = 0, jj = rings.length; j < jj; ++j) {\n    const coordinates = rings[j];\n\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData =\n      /** @type {module:ol/interaction/Snap~SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n/**\n * Handle all pointer events events.\n * @param {module:ol/MapBrowserEvent} evt A move event.\n * @return {boolean} Pass the event to other interactions.\n * @this {module:ol/interaction/Snap}\n */\n\n\nexport function handleEvent(evt) {\n  const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n  if (result.snapped) {\n    evt.coordinate = result.vertex.slice(0, 2);\n    evt.pixel = result.vertexPixel;\n  }\n\n  return handlePointerEvent.call(this, evt);\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/Snap}\n */\n\nfunction handleUpEvent(evt) {\n  const featuresToUpdate = getValues(this.pendingFeatures_);\n\n  if (featuresToUpdate.length) {\n    featuresToUpdate.forEach(this.updateFeature_.bind(this));\n    this.pendingFeatures_ = {};\n  }\n\n  return false;\n}\n/**\n * Sort segments by distance, helper function\n * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.\n * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {module:ol/interaction/Snap}\n */\n\n\nfunction sortByDistance(a, b) {\n  const deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  const deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;","map":null,"metadata":{},"sourceType":"module"}