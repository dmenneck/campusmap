{"ast":null,"code":"/**\n * @module ol/structs/LRUCache\n */\nimport { inherits } from '../util.js';\nimport { assert } from '../asserts.js';\nimport EventTarget from '../events/EventTarget.js';\nimport EventType from '../events/EventType.js';\n/**\n * @typedef {Object} Entry\n * @property {string} key_\n * @property {Object} newer\n * @property {Object} older\n * @property {*} value_\n */\n\n/**\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n * @constructor\n * @extends {module:ol/events/EventTarget}\n * @fires module:ol/events/Event~Event\n * @struct\n * @template T\n * @param {number=} opt_highWaterMark High water mark.\n */\n\nconst LRUCache = function (opt_highWaterMark) {\n  EventTarget.call(this);\n  /**\n   * @type {number}\n   */\n\n  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.count_ = 0;\n  /**\n   * @private\n   * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}\n   */\n\n  this.entries_ = {};\n  /**\n   * @private\n   * @type {?module:ol/structs/LRUCache~Entry}\n   */\n\n  this.oldest_ = null;\n  /**\n   * @private\n   * @type {?module:ol/structs/LRUCache~Entry}\n   */\n\n  this.newest_ = null;\n};\n\ninherits(LRUCache, EventTarget);\n/**\n * @return {boolean} Can expire cache.\n */\n\nLRUCache.prototype.canExpireCache = function () {\n  return this.getCount() > this.highWaterMark;\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\nLRUCache.prototype.clear = function () {\n  this.count_ = 0;\n  this.entries_ = {};\n  this.oldest_ = null;\n  this.newest_ = null;\n  this.dispatchEvent(EventType.CLEAR);\n};\n/**\n * @param {string} key Key.\n * @return {boolean} Contains key.\n */\n\n\nLRUCache.prototype.containsKey = function (key) {\n  return this.entries_.hasOwnProperty(key);\n};\n/**\n * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function\n *     to call for every entry from the oldest to the newer. This function takes\n *     3 arguments (the entry value, the entry key and the LRUCache object).\n *     The return value is ignored.\n * @param {S=} opt_this The object to use as `this` in `f`.\n * @template S\n */\n\n\nLRUCache.prototype.forEach = function (f, opt_this) {\n  let entry = this.oldest_;\n\n  while (entry) {\n    f.call(opt_this, entry.value_, entry.key_, this);\n    entry = entry.newer;\n  }\n};\n/**\n * @param {string} key Key.\n * @return {T} Value.\n */\n\n\nLRUCache.prototype.get = function (key) {\n  const entry = this.entries_[key];\n  assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n  if (entry === this.newest_) {\n    return entry.value_;\n  } else if (entry === this.oldest_) {\n    this.oldest_ =\n    /** @type {module:ol/structs/LRUCache~Entry} */\n    this.oldest_.newer;\n    this.oldest_.older = null;\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n\n  entry.newer = null;\n  entry.older = this.newest_;\n  this.newest_.newer = entry;\n  this.newest_ = entry;\n  return entry.value_;\n};\n/**\n * Remove an entry from the cache.\n * @param {string} key The entry key.\n * @return {T} The removed entry.\n */\n\n\nLRUCache.prototype.remove = function (key) {\n  const entry = this.entries_[key];\n  assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n  if (entry === this.newest_) {\n    this.newest_ =\n    /** @type {module:ol/structs/LRUCache~Entry} */\n    entry.older;\n\n    if (this.newest_) {\n      this.newest_.newer = null;\n    }\n  } else if (entry === this.oldest_) {\n    this.oldest_ =\n    /** @type {module:ol/structs/LRUCache~Entry} */\n    entry.newer;\n\n    if (this.oldest_) {\n      this.oldest_.older = null;\n    }\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n\n  delete this.entries_[key];\n  --this.count_;\n  return entry.value_;\n};\n/**\n * @return {number} Count.\n */\n\n\nLRUCache.prototype.getCount = function () {\n  return this.count_;\n};\n/**\n * @return {Array.<string>} Keys.\n */\n\n\nLRUCache.prototype.getKeys = function () {\n  const keys = new Array(this.count_);\n  let i = 0;\n  let entry;\n\n  for (entry = this.newest_; entry; entry = entry.older) {\n    keys[i++] = entry.key_;\n  }\n\n  return keys;\n};\n/**\n * @return {Array.<T>} Values.\n */\n\n\nLRUCache.prototype.getValues = function () {\n  const values = new Array(this.count_);\n  let i = 0;\n  let entry;\n\n  for (entry = this.newest_; entry; entry = entry.older) {\n    values[i++] = entry.value_;\n  }\n\n  return values;\n};\n/**\n * @return {T} Last value.\n */\n\n\nLRUCache.prototype.peekLast = function () {\n  return this.oldest_.value_;\n};\n/**\n * @return {string} Last key.\n */\n\n\nLRUCache.prototype.peekLastKey = function () {\n  return this.oldest_.key_;\n};\n/**\n * Get the key of the newest item in the cache.  Throws if the cache is empty.\n * @return {string} The newest key.\n */\n\n\nLRUCache.prototype.peekFirstKey = function () {\n  return this.newest_.key_;\n};\n/**\n * @return {T} value Value.\n */\n\n\nLRUCache.prototype.pop = function () {\n  const entry = this.oldest_;\n  delete this.entries_[entry.key_];\n\n  if (entry.newer) {\n    entry.newer.older = null;\n  }\n\n  this.oldest_ =\n  /** @type {module:ol/structs/LRUCache~Entry} */\n  entry.newer;\n\n  if (!this.oldest_) {\n    this.newest_ = null;\n  }\n\n  --this.count_;\n  return entry.value_;\n};\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n\n\nLRUCache.prototype.replace = function (key, value) {\n  this.get(key); // update `newest_`\n\n  this.entries_[key].value_ = value;\n};\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n\n\nLRUCache.prototype.set = function (key, value) {\n  assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n\n  const entry =\n  /** @type {module:ol/structs/LRUCache~Entry} */\n  {\n    key_: key,\n    newer: null,\n    older: this.newest_,\n    value_: value\n  };\n\n  if (!this.newest_) {\n    this.oldest_ = entry;\n  } else {\n    this.newest_.newer = entry;\n  }\n\n  this.newest_ = entry;\n  this.entries_[key] = entry;\n  ++this.count_;\n};\n/**\n * Set a maximum number of entries for the cache.\n * @param {number} size Cache size.\n * @api\n */\n\n\nLRUCache.prototype.setSize = function (size) {\n  this.highWaterMark = size;\n};\n/**\n * Prune the cache.\n */\n\n\nLRUCache.prototype.prune = function () {\n  while (this.canExpireCache()) {\n    this.pop();\n  }\n};\n\nexport default LRUCache;","map":null,"metadata":{},"sourceType":"module"}