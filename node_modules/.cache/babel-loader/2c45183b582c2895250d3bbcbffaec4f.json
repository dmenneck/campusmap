{"ast":null,"code":"/**\n * @module ol/geom/MultiPolygon\n */\nimport { inherits } from '../util.js';\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport Polygon from '../geom/Polygon.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { linearRingss as linearRingssArea } from '../geom/flat/area.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from '../geom/flat/closest.js';\nimport { linearRingssContainsXY } from '../geom/flat/contains.js';\nimport { deflateMultiCoordinatesArray } from '../geom/flat/deflate.js';\nimport { inflateMultiCoordinatesArray } from '../geom/flat/inflate.js';\nimport { getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { intersectsLinearRingMultiArray } from '../geom/flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRingsArray } from '../geom/flat/orient.js';\nimport { quantizeMultiArray } from '../geom/flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @constructor\n * @extends {module:ol/geom/SimpleGeometry}\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @api\n */\n\nconst MultiPolygon = function (coordinates, opt_layout) {\n  SimpleGeometry.call(this);\n  /**\n   * @type {Array.<Array.<number>>}\n   * @private\n   */\n\n  this.endss_ = [];\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.flatInteriorPointsRevision_ = -1;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this.flatInteriorPoints_ = null;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.maxDelta_ = -1;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.maxDeltaRevision_ = -1;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.orientedRevision_ = -1;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this.orientedFlatCoordinates_ = null;\n  this.setCoordinates(coordinates, opt_layout);\n};\n\ninherits(MultiPolygon, SimpleGeometry);\n/**\n * Append the passed polygon to this multipolygon.\n * @param {module:ol/geom/Polygon} polygon Polygon.\n * @api\n */\n\nMultiPolygon.prototype.appendPolygon = function (polygon) {\n  /** @type {Array.<number>} */\n  let ends;\n\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = polygon.getFlatCoordinates().slice();\n    ends = polygon.getEnds().slice();\n    this.endss_.push();\n  } else {\n    const offset = this.flatCoordinates.length;\n    extend(this.flatCoordinates, polygon.getFlatCoordinates());\n    ends = polygon.getEnds().slice();\n\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      ends[i] += offset;\n    }\n  }\n\n  this.endss_.push(ends);\n  this.changed();\n};\n/**\n * Make a complete copy of the geometry.\n * @return {!module:ol/geom/MultiPolygon} Clone.\n * @override\n * @api\n */\n\n\nMultiPolygon.prototype.clone = function () {\n  const multiPolygon = new MultiPolygon(null);\n  const len = this.endss_.length;\n  const newEndss = new Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    newEndss[i] = this.endss_[i].slice();\n  }\n\n  multiPolygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), newEndss);\n  return multiPolygon;\n};\n/**\n * @inheritDoc\n */\n\n\nMultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n\n  return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n/**\n * @inheritDoc\n */\n\n\nMultiPolygon.prototype.containsXY = function (x, y) {\n  return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n};\n/**\n * Return the area of the multipolygon on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n\n\nMultiPolygon.prototype.getArea = function () {\n  return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n};\n/**\n * Get the coordinate array for this geometry.  This array has the structure\n * of a GeoJSON coordinate array for multi-polygons.\n *\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\n *     If `false`, coordinates will be oriented according to the left-hand rule\n *     (clockwise for exterior and counter-clockwise for interior rings).\n *     By default, coordinate orientation will depend on how the geometry was\n *     constructed.\n * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinates.\n * @override\n * @api\n */\n\n\nMultiPolygon.prototype.getCoordinates = function (opt_right) {\n  let flatCoordinates;\n\n  if (opt_right !== undefined) {\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\n    orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n  } else {\n    flatCoordinates = this.flatCoordinates;\n  }\n\n  return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n};\n/**\n * @return {Array.<Array.<number>>} Endss.\n */\n\n\nMultiPolygon.prototype.getEndss = function () {\n  return this.endss_;\n};\n/**\n * @return {Array.<number>} Flat interior points.\n */\n\n\nMultiPolygon.prototype.getFlatInteriorPoints = function () {\n  if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n    const flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n    this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n    this.flatInteriorPointsRevision_ = this.getRevision();\n  }\n\n  return this.flatInteriorPoints_;\n};\n/**\n * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n * @return {module:ol/geom/MultiPoint} Interior points as XYM coordinates, where M is\n * the length of the horizontal intersection that the point belongs to.\n * @api\n */\n\n\nMultiPolygon.prototype.getInteriorPoints = function () {\n  const interiorPoints = new MultiPoint(null);\n  interiorPoints.setFlatCoordinates(GeometryLayout.XYM, this.getFlatInteriorPoints().slice());\n  return interiorPoints;\n};\n/**\n * @return {Array.<number>} Oriented flat coordinates.\n */\n\n\nMultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n  if (this.orientedRevision_ != this.getRevision()) {\n    const flatCoordinates = this.flatCoordinates;\n\n    if (linearRingsAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n      this.orientedFlatCoordinates_ = flatCoordinates;\n    } else {\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\n      this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n    }\n\n    this.orientedRevision_ = this.getRevision();\n  }\n\n  return this.orientedFlatCoordinates_;\n};\n/**\n * @inheritDoc\n */\n\n\nMultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n  const simplifiedFlatCoordinates = [];\n  const simplifiedEndss = [];\n  simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n  const simplifiedMultiPolygon = new MultiPolygon(null);\n  simplifiedMultiPolygon.setFlatCoordinates(GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEndss);\n  return simplifiedMultiPolygon;\n};\n/**\n * Return the polygon at the specified index.\n * @param {number} index Index.\n * @return {module:ol/geom/Polygon} Polygon.\n * @api\n */\n\n\nMultiPolygon.prototype.getPolygon = function (index) {\n  if (index < 0 || this.endss_.length <= index) {\n    return null;\n  }\n\n  let offset;\n\n  if (index === 0) {\n    offset = 0;\n  } else {\n    const prevEnds = this.endss_[index - 1];\n    offset = prevEnds[prevEnds.length - 1];\n  }\n\n  const ends = this.endss_[index].slice();\n  const end = ends[ends.length - 1];\n\n  if (offset !== 0) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      ends[i] -= offset;\n    }\n  }\n\n  const polygon = new Polygon(null);\n  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(offset, end), ends);\n  return polygon;\n};\n/**\n * Return the polygons of this multipolygon.\n * @return {Array.<module:ol/geom/Polygon>} Polygons.\n * @api\n */\n\n\nMultiPolygon.prototype.getPolygons = function () {\n  const layout = this.layout;\n  const flatCoordinates = this.flatCoordinates;\n  const endss = this.endss_;\n  const polygons = [];\n  let offset = 0;\n\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i].slice();\n    const end = ends[ends.length - 1];\n\n    if (offset !== 0) {\n      for (let j = 0, jj = ends.length; j < jj; ++j) {\n        ends[j] -= offset;\n      }\n    }\n\n    const polygon = new Polygon(null);\n    polygon.setFlatCoordinates(layout, flatCoordinates.slice(offset, end), ends);\n    polygons.push(polygon);\n    offset = end;\n  }\n\n  return polygons;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nMultiPolygon.prototype.getType = function () {\n  return GeometryType.MULTI_POLYGON;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nMultiPolygon.prototype.intersectsExtent = function (extent) {\n  return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n};\n/**\n * Set the coordinates of the multipolygon.\n * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n\n\nMultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(GeometryLayout.XY, null, this.endss_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 3);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    const endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n\n    this.changed();\n  }\n};\n/**\n * @param {module:ol/geom/GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<Array.<number>>} endss Endss.\n */\n\n\nMultiPolygon.prototype.setFlatCoordinates = function (layout, flatCoordinates, endss) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.endss_ = endss;\n  this.changed();\n};\n/**\n * @param {Array.<module:ol/geom/Polygon>} polygons Polygons.\n */\n\n\nMultiPolygon.prototype.setPolygons = function (polygons) {\n  let layout = this.getLayout();\n  const flatCoordinates = [];\n  const endss = [];\n\n  for (let i = 0, ii = polygons.length; i < ii; ++i) {\n    const polygon = polygons[i];\n\n    if (i === 0) {\n      layout = polygon.getLayout();\n    }\n\n    const offset = flatCoordinates.length;\n    const ends = polygon.getEnds();\n\n    for (let j = 0, jj = ends.length; j < jj; ++j) {\n      ends[j] += offset;\n    }\n\n    extend(flatCoordinates, polygon.getFlatCoordinates());\n    endss.push(ends);\n  }\n\n  this.setFlatCoordinates(layout, flatCoordinates, endss);\n};\n\nexport default MultiPolygon;","map":null,"metadata":{},"sourceType":"module"}