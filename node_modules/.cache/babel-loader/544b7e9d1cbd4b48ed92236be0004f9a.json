{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _filter = require(\"ol/format/filter\");\n\nvar _WFS = _interopRequireDefault(require(\"ol/format/WFS\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Helper class for building filters to be used with WFS GetFeature requests.\n *\n * @class WfsFilterUtil\n */\n\n\nvar WfsFilterUtil =\n/*#__PURE__*/\nfunction () {\n  function WfsFilterUtil() {\n    _classCallCheck(this, WfsFilterUtil);\n  }\n\n  _createClass(WfsFilterUtil, null, [{\n    key: \"createWfsFilter\",\n\n    /**\n     * Creates a filter for a given feature type considering configured\n     * search attributes, mapped features types to an array of attribute details and the\n     * current search term.\n     * Currently supports EQUALTO and LIKE filters only, which can be combined with\n     * OR filter if searchAttributes array contains multiple values though.\n     *\n     * @param {string} featureType Name of feature type to be used in filter.\n     * @param {string} searchTerm Search value.\n     * @param {Object} searchAttributes An object mapping feature types to an array of\n     *   attributes that should be searched through.\n     * @param {Object} attributeDetails An object mapping feature types to an\n     *   array of attribute details.\n     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.\n     * @private\n     */\n    value: function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {\n      var attributes = searchAttributes && searchAttributes[featureType];\n\n      if (!attributes) {\n        return null;\n      }\n\n      var details = attributeDetails && attributeDetails[featureType];\n      var propertyFilters = attributes.map(function (attribute) {\n        var filterDetails = details && details[attribute];\n\n        if (filterDetails) {\n          var type = filterDetails.type;\n\n          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\\d]/)) {\n            return undefined;\n          }\n\n          if (filterDetails.exactSearch) {\n            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);\n          } else {\n            return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', filterDetails.matchCase || false);\n          }\n        } else {\n          return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', false);\n        }\n      }).filter(function (filter) {\n        return filter !== undefined;\n      });\n\n      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {\n        return _filter.or.apply(void 0, _toConsumableArray(propertyFilters));\n      } else {\n        return propertyFilters[0];\n      }\n    }\n    /**\n     * Creates GetFeature request body for all provided featureTypes and\n     * applies related filter encoding on it.\n     *\n     * @param {Object} searchOpts Search options object which has the following\n     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/\n     * for further options explanations and examples):\n     *   * featureNS        {String}   The namespace URI used for features\n     *   * featurePrefix    {String}   The prefix for the feature namespace.\n     *   * featureTypes     {String[]} The feature type names to search through.\n     *   * geometryName     {String}   Geometry name to use in a BBOX filter.\n     *   * maxFeatures      {Number}   Maximum number of features to fetch.\n     *   * outputFormat     {String}   The output format of the response.\n     *   * propertyNames    {String[]} Optional list of property names to serialize.\n     *   * srsName          {String}   SRS name.\n     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS\n     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)\n     *   * searchAttributes {Object}   An object mapping feature types to an array\n     *                                 of attributes that should be searched through.\n     *   * attributeDetails {Object}   A nested object mapping feature types to an\n     *                                 object of attribute details, which are also\n     *                                 mapped by search attribute name.\n     * @param {string} searchTerm Search string to be used with filter.\n     */\n\n  }, {\n    key: \"getCombinedRequests\",\n    value: function getCombinedRequests(searchOpts, searchTerm) {\n      var featureNS = searchOpts.featureNS,\n          featurePrefix = searchOpts.featurePrefix,\n          featureTypes = searchOpts.featureTypes,\n          geometryName = searchOpts.geometryName,\n          maxFeatures = searchOpts.maxFeatures,\n          outputFormat = searchOpts.outputFormat,\n          propertyNames = searchOpts.propertyNames,\n          srsName = searchOpts.srsName,\n          wfsFormatOptions = searchOpts.wfsFormatOptions,\n          searchAttributes = searchOpts.searchAttributes,\n          attributeDetails = searchOpts.attributeDetails;\n      var requests = featureTypes.map(function (featureType) {\n        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);\n        var options = {\n          featureNS: featureNS,\n          featurePrefix: featurePrefix,\n          featureTypes: [featureType],\n          geometryName: geometryName,\n          maxFeatures: maxFeatures,\n          outputFormat: outputFormat,\n          propertyNames: propertyNames,\n          srsName: srsName,\n          filter: filter\n        };\n        var wfsFormat = new _WFS[\"default\"](wfsFormatOptions);\n        return wfsFormat.writeGetFeature(options);\n      });\n      var request = requests[0];\n      requests.forEach(function (req) {\n        if (req !== request) {\n          var query = req.querySelector('Query');\n          request.append(query);\n        }\n      });\n      return request;\n    }\n  }]);\n\n  return WfsFilterUtil;\n}();\n\nvar _default = WfsFilterUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/@terrestris/react-geo/node_modules/@terrestris/ol-util/dist/WfsFilterUtil/WfsFilterUtil.js"],"names":["Object","defineProperty","exports","value","_filter","require","_WFS","_interopRequireDefault","obj","__esModule","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","WfsFilterUtil","createWfsFilter","featureType","searchTerm","searchAttributes","attributeDetails","attributes","details","propertyFilters","map","attribute","filterDetails","type","match","undefined","exactSearch","equalTo","like","concat","matchCase","filter","keys","or","apply","getCombinedRequests","searchOpts","featureNS","featurePrefix","featureTypes","geometryName","maxFeatures","outputFormat","propertyNames","srsName","wfsFormatOptions","requests","options","wfsFormat","writeGetFeature","request","forEach","req","query","querySelector","append","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _filter = require(\"ol/format/filter\");\n\nvar _WFS = _interopRequireDefault(require(\"ol/format/WFS\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Helper class for building filters to be used with WFS GetFeature requests.\n *\n * @class WfsFilterUtil\n */\nvar WfsFilterUtil =\n/*#__PURE__*/\nfunction () {\n  function WfsFilterUtil() {\n    _classCallCheck(this, WfsFilterUtil);\n  }\n\n  _createClass(WfsFilterUtil, null, [{\n    key: \"createWfsFilter\",\n\n    /**\n     * Creates a filter for a given feature type considering configured\n     * search attributes, mapped features types to an array of attribute details and the\n     * current search term.\n     * Currently supports EQUALTO and LIKE filters only, which can be combined with\n     * OR filter if searchAttributes array contains multiple values though.\n     *\n     * @param {string} featureType Name of feature type to be used in filter.\n     * @param {string} searchTerm Search value.\n     * @param {Object} searchAttributes An object mapping feature types to an array of\n     *   attributes that should be searched through.\n     * @param {Object} attributeDetails An object mapping feature types to an\n     *   array of attribute details.\n     * @return {OlFormatFilter} Filter to be used with WFS GetFeature requests.\n     * @private\n     */\n    value: function createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails) {\n      var attributes = searchAttributes && searchAttributes[featureType];\n\n      if (!attributes) {\n        return null;\n      }\n\n      var details = attributeDetails && attributeDetails[featureType];\n      var propertyFilters = attributes.map(function (attribute) {\n        var filterDetails = details && details[attribute];\n\n        if (filterDetails) {\n          var type = filterDetails.type;\n\n          if (type && (type === 'int' || type === 'number') && searchTerm.match(/[^.\\d]/)) {\n            return undefined;\n          }\n\n          if (filterDetails.exactSearch) {\n            return (0, _filter.equalTo)(attribute, searchTerm, filterDetails.exactSearch);\n          } else {\n            return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', filterDetails.matchCase || false);\n          }\n        } else {\n          return (0, _filter.like)(attribute, \"*\".concat(searchTerm, \"*\"), '*', '.', '!', false);\n        }\n      }).filter(function (filter) {\n        return filter !== undefined;\n      });\n\n      if (attributes.length > 1 && Object.keys(propertyFilters).length > 1) {\n        return _filter.or.apply(void 0, _toConsumableArray(propertyFilters));\n      } else {\n        return propertyFilters[0];\n      }\n    }\n    /**\n     * Creates GetFeature request body for all provided featureTypes and\n     * applies related filter encoding on it.\n     *\n     * @param {Object} searchOpts Search options object which has the following\n     * keys (see also https://github.com/terrestris/react-geo/blob/master/src/Field/WfsSearch/\n     * for further options explanations and examples):\n     *   * featureNS        {String}   The namespace URI used for features\n     *   * featurePrefix    {String}   The prefix for the feature namespace.\n     *   * featureTypes     {String[]} The feature type names to search through.\n     *   * geometryName     {String}   Geometry name to use in a BBOX filter.\n     *   * maxFeatures      {Number}   Maximum number of features to fetch.\n     *   * outputFormat     {String}   The output format of the response.\n     *   * propertyNames    {String[]} Optional list of property names to serialize.\n     *   * srsName          {String}   SRS name.\n     *   * wfsFormatOptions {Object}   Options which are passed to the constructor of the ol.format.WFS\n     *                                 (compare: https://openlayers.org/en/latest/apidoc/ol.format.WFS.html)\n     *   * searchAttributes {Object}   An object mapping feature types to an array\n     *                                 of attributes that should be searched through.\n     *   * attributeDetails {Object}   A nested object mapping feature types to an\n     *                                 object of attribute details, which are also\n     *                                 mapped by search attribute name.\n     * @param {string} searchTerm Search string to be used with filter.\n     */\n\n  }, {\n    key: \"getCombinedRequests\",\n    value: function getCombinedRequests(searchOpts, searchTerm) {\n      var featureNS = searchOpts.featureNS,\n          featurePrefix = searchOpts.featurePrefix,\n          featureTypes = searchOpts.featureTypes,\n          geometryName = searchOpts.geometryName,\n          maxFeatures = searchOpts.maxFeatures,\n          outputFormat = searchOpts.outputFormat,\n          propertyNames = searchOpts.propertyNames,\n          srsName = searchOpts.srsName,\n          wfsFormatOptions = searchOpts.wfsFormatOptions,\n          searchAttributes = searchOpts.searchAttributes,\n          attributeDetails = searchOpts.attributeDetails;\n      var requests = featureTypes.map(function (featureType) {\n        var filter = WfsFilterUtil.createWfsFilter(featureType, searchTerm, searchAttributes, attributeDetails);\n        var options = {\n          featureNS: featureNS,\n          featurePrefix: featurePrefix,\n          featureTypes: [featureType],\n          geometryName: geometryName,\n          maxFeatures: maxFeatures,\n          outputFormat: outputFormat,\n          propertyNames: propertyNames,\n          srsName: srsName,\n          filter: filter\n        };\n        var wfsFormat = new _WFS[\"default\"](wfsFormatOptions);\n        return wfsFormat.writeGetFeature(options);\n      });\n      var request = requests[0];\n      requests.forEach(function (req) {\n        if (req !== request) {\n          var query = req.querySelector('Query');\n          request.append(query);\n        }\n      });\n      return request;\n    }\n  }]);\n\n  return WfsFilterUtil;\n}();\n\nvar _default = WfsFilterUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}