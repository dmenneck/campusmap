{"ast":null,"code":"/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\n\n/**\n * @see http://mapbox.com/developers/api/\n */\nimport { inherits } from '../util.js';\nimport { createFromTemplates } from '../tileurlfunction.js';\nimport { assert } from '../asserts.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { jsonp as requestJSONP } from '../net.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport SourceState from '../source/State.js';\nimport TileImage from '../source/TileImage.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} Options\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image} for more detail.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {boolean} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {tileJSON} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n *\n * @constructor\n * @extends {module:ol/source/TileImage}\n * @param {module:ol/source/TileJSON~Options=} options TileJSON options.\n * @api\n */\n\nconst TileJSON = function (options) {\n  /**\n   * @type {TileJSON}\n   * @private\n   */\n  this.tileJSON_ = null;\n  TileImage.call(this, {\n    attributions: options.attributions,\n    cacheSize: options.cacheSize,\n    crossOrigin: options.crossOrigin,\n    projection: getProjection('EPSG:3857'),\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n    state: SourceState.LOADING,\n    tileLoadFunction: options.tileLoadFunction,\n    wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    transition: options.transition\n  });\n\n  if (options.url) {\n    if (options.jsonp) {\n      requestJSONP(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));\n    } else {\n      const client = new XMLHttpRequest();\n      client.addEventListener('load', this.onXHRLoad_.bind(this));\n      client.addEventListener('error', this.onXHRError_.bind(this));\n      client.open('GET', options.url);\n      client.send();\n    }\n  } else if (options.tileJSON) {\n    this.handleTileJSONResponse(options.tileJSON);\n  } else {\n    assert(false, 51); // Either `url` or `tileJSON` options must be provided\n  }\n};\n\ninherits(TileJSON, TileImage);\n/**\n * @private\n * @param {Event} event The load event.\n */\n\nTileJSON.prototype.onXHRLoad_ = function (event) {\n  const client =\n  /** @type {XMLHttpRequest} */\n  event.target; // status will be 0 for file:// urls\n\n  if (!client.status || client.status >= 200 && client.status < 300) {\n    let response;\n\n    try {\n      response =\n      /** @type {TileJSON} */\n      JSON.parse(client.responseText);\n    } catch (err) {\n      this.handleTileJSONError();\n      return;\n    }\n\n    this.handleTileJSONResponse(response);\n  } else {\n    this.handleTileJSONError();\n  }\n};\n/**\n * @private\n * @param {Event} event The error event.\n */\n\n\nTileJSON.prototype.onXHRError_ = function (event) {\n  this.handleTileJSONError();\n};\n/**\n * @return {TileJSON} The tilejson object.\n * @api\n */\n\n\nTileJSON.prototype.getTileJSON = function () {\n  return this.tileJSON_;\n};\n/**\n * @protected\n * @param {TileJSON} tileJSON Tile JSON.\n */\n\n\nTileJSON.prototype.handleTileJSONResponse = function (tileJSON) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  const sourceProjection = this.getProjection();\n  let extent;\n\n  if (tileJSON.bounds !== undefined) {\n    const transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n    extent = applyTransform(tileJSON.bounds, transform);\n  }\n\n  const minZoom = tileJSON.minzoom || 0;\n  const maxZoom = tileJSON.maxzoom || 22;\n  const tileGrid = createXYZ({\n    extent: extentFromProjection(sourceProjection),\n    maxZoom: maxZoom,\n    minZoom: minZoom\n  });\n  this.tileGrid = tileGrid;\n  this.tileUrlFunction = createFromTemplates(tileJSON.tiles, tileGrid);\n\n  if (tileJSON.attribution !== undefined && !this.getAttributions()) {\n    const attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();\n    this.setAttributions(function (frameState) {\n      if (intersects(attributionExtent, frameState.extent)) {\n        return [tileJSON.attribution];\n      }\n\n      return null;\n    });\n  }\n\n  this.tileJSON_ = tileJSON;\n  this.setState(SourceState.READY);\n};\n/**\n * @protected\n */\n\n\nTileJSON.prototype.handleTileJSONError = function () {\n  this.setState(SourceState.ERROR);\n};\n\nexport default TileJSON;","map":null,"metadata":{},"sourceType":"module"}