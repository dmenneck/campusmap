{"ast":null,"code":"/**\n * @module ol/pointer/MouseSource\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nimport { inherits } from '../util.js';\nimport EventSource from '../pointer/EventSource.js';\n/**\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\n * @constructor\n * @extends {module:ol/pointer/EventSource}\n */\n\nconst MouseSource = function (dispatcher) {\n  const mapping = {\n    'mousedown': this.mousedown,\n    'mousemove': this.mousemove,\n    'mouseup': this.mouseup,\n    'mouseover': this.mouseover,\n    'mouseout': this.mouseout\n  };\n  EventSource.call(this, dispatcher, mapping);\n  /**\n   * @const\n   * @type {!Object.<string, Event|Object>}\n   */\n\n  this.pointerMap = dispatcher.pointerMap;\n  /**\n   * @const\n   * @type {Array.<module:ol~Pixel>}\n   */\n\n  this.lastTouches = [];\n};\n\ninherits(MouseSource, EventSource);\n/**\n * @type {number}\n */\n\nexport const POINTER_ID = 1;\n/**\n * @type {string}\n */\n\nexport const POINTER_TYPE = 'mouse';\n/**\n * Radius around touchend that swallows mouse events.\n *\n * @type {number}\n */\n\nconst DEDUP_DIST = 25;\n/**\n * Detect if a mouse event was simulated from a touch by\n * checking if previously there was a touch event at the\n * same position.\n *\n * FIXME - Known problem with the native Android browser on\n * Samsung GT-I9100 (Android 4.1.2):\n * In case the page is scrolled, this function does not work\n * correctly when a canvas is used (WebGL or canvas renderer).\n * Mouse listeners on canvas elements (for this browser), create\n * two mouse events: One 'good' and one 'bad' one (on other browsers or\n * when a div is used, there is only one event). For the 'bad' one,\n * clientX/clientY and also pageX/pageY are wrong when the page\n * is scrolled. Because of that, this function can not detect if\n * the events were simulated from a touch event. As result, a\n * pointer event at a wrong position is dispatched, which confuses\n * the map interactions.\n * It is unclear, how one can get the correct position for the event\n * or detect that the positions are invalid.\n *\n * @private\n * @param {Event} inEvent The in event.\n * @return {boolean} True, if the event was generated by a touch.\n */\n\nMouseSource.prototype.isEventSimulatedFromTouch_ = function (inEvent) {\n  const lts = this.lastTouches;\n  const x = inEvent.clientX;\n  const y = inEvent.clientY;\n\n  for (let i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\n    // simulated mouse events will be swallowed near a primary touchend\n    const dx = Math.abs(x - t[0]);\n    const dy = Math.abs(y - t[1]);\n\n    if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Creates a copy of the original event that will be used\n * for the fake pointer event.\n *\n * @param {Event} inEvent The in event.\n * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.\n * @return {Object} The copied event.\n */\n\n\nfunction prepareEvent(inEvent, dispatcher) {\n  const e = dispatcher.cloneEvent(inEvent, inEvent); // forward mouse preventDefault\n\n  const pd = e.preventDefault;\n\n  e.preventDefault = function () {\n    inEvent.preventDefault();\n    pd();\n  };\n\n  e.pointerId = POINTER_ID;\n  e.isPrimary = true;\n  e.pointerType = POINTER_TYPE;\n  return e;\n}\n/**\n * Handler for `mousedown`.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.mousedown = function (inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    // TODO(dfreedman) workaround for some elements not sending mouseup\n    // http://crbug/149091\n    if (POINTER_ID.toString() in this.pointerMap) {\n      this.cancel(inEvent);\n    }\n\n    const e = prepareEvent(inEvent, this.dispatcher);\n    this.pointerMap[POINTER_ID.toString()] = inEvent;\n    this.dispatcher.down(e, inEvent);\n  }\n};\n/**\n * Handler for `mousemove`.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.mousemove = function (inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    const e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.move(e, inEvent);\n  }\n};\n/**\n * Handler for `mouseup`.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.mouseup = function (inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    const p = this.pointerMap[POINTER_ID.toString()];\n\n    if (p && p.button === inEvent.button) {\n      const e = prepareEvent(inEvent, this.dispatcher);\n      this.dispatcher.up(e, inEvent);\n      this.cleanupMouse();\n    }\n  }\n};\n/**\n * Handler for `mouseover`.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.mouseover = function (inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    const e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.enterOver(e, inEvent);\n  }\n};\n/**\n * Handler for `mouseout`.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.mouseout = function (inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    const e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.leaveOut(e, inEvent);\n  }\n};\n/**\n * Dispatches a `pointercancel` event.\n *\n * @param {Event} inEvent The in event.\n */\n\n\nMouseSource.prototype.cancel = function (inEvent) {\n  const e = prepareEvent(inEvent, this.dispatcher);\n  this.dispatcher.cancel(e, inEvent);\n  this.cleanupMouse();\n};\n/**\n * Remove the mouse from the list of active pointers.\n */\n\n\nMouseSource.prototype.cleanupMouse = function () {\n  delete this.pointerMap[POINTER_ID.toString()];\n};\n\nexport default MouseSource;","map":null,"metadata":{},"sourceType":"module"}