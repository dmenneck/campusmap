{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\n\nvar TileCache =\n/*@__PURE__*/\nfunction (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n    LRUCache.call(this, opt_highWaterMark);\n  }\n\n  if (LRUCache) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create(LRUCache && LRUCache.prototype);\n  TileCache.prototype.constructor = TileCache;\n  /**\n   * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n   */\n\n  TileCache.prototype.expireCache = function expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      var tile = this.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  };\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n\n\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n\n  return TileCache;\n}(LRUCache);\n\nexport default TileCache;","map":{"version":3,"sources":["../../src/ol/TileCache.js"],"names":["super","const"],"mappings":"AAAA;;;AAGA,OAAO,QAAP,MAAqB,uBAArB;AACA,SAAQ,OAAR,EAAiB,MAAjB,QAA8B,gBAA9B;;AAEA,IAAM,SAAS;AAAiB;AAAA,UAAA,QAAA,EAAA;AAK9B,WAAA,SAAA,CAAY,iBAAZ,EAA+B;AAE7BA,IAAAA,QAAAA,CAAAA,IAAAA,CAAK,IAALA,EAAM,iBAANA;;;;;oCAED,S;;;;;sBAKD,W,GAAA,SAAA,WAAA,CAAY,SAAZ,EAAuB;AACrB,WAAO,KAAK,cAAL,EAAP,EAA8B;AAC5BC,UAAM,IAAI,GAAG,KAAK,QAAL,EAAbA;AACAA,UAAM,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,QAAlB,EAAbA;;AACA,UAAI,IAAI,IAAI,SAAR,IAAqB,SAAS,CAAC,IAAD,CAAT,CAAgB,QAAhB,CAAyB,IAAI,CAAC,SAA9B,CAAzB,EAAmE;AACjE;AACD,OAFD,MAEO;AACL,aAAK,GAAL,GAAW,OAAX;AACD;AACF;AACF,G;;;;;;sBAKD,kB,GAAA,SAAA,kBAAA,GAAqB;AACnB,QAAI,KAAK,QAAL,OAAoB,CAAxB,EAA2B;AACzB;AACD;;AACDA,QAAM,GAAG,GAAG,KAAK,YAAL,EAAZA;AACAA,QAAM,SAAS,GAAG,OAAO,CAAC,GAAD,CAAzBA;AACAA,QAAM,CAAC,GAAG,SAAS,CAAC,CAAD,CAAnBA;AACA,SAAK,OAAL,CAAa,UAAS,IAAT,EAAe;AAC1B,UAAI,IAAI,CAAC,SAAL,CAAe,CAAf,MAAsB,CAA1B,EAA6B;AAC3B,aAAK,MAAL,CAAY,MAAM,CAAC,IAAI,CAAC,SAAN,CAAlB;AACA,QAAA,IAAI,CAAC,OAAL;AACD;AACF,KALD,EAKG,IALH;AAMD,G;;;CA1C6B,CAAR,QAAQ,CAAhC;;AA8CA,eAAe,SAAf","sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n\n  /**\n   * @param {number=} opt_highWaterMark High water mark.\n   */\n  constructor(opt_highWaterMark) {\n\n    super(opt_highWaterMark);\n\n  }\n\n  /**\n   * @param {!Object<string, import(\"./TileRange.js\").default>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      const zKey = tile.tileCoord[0].toString();\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(function(tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  }\n}\n\n\nexport default TileCache;\n"]},"metadata":{},"sourceType":"module"}