{"ast":null,"code":"/**\n * @module ol/format/WFS\n */\nimport { assert } from '../asserts.js';\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport { and as andFilter, bbox as bboxFilter } from './filter.js';\nimport XMLFeature from './XMLFeature.js';\nimport { readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode } from './xsd.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { createElementNS, isDocument, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode, pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI } from '../xml.js';\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds')\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\nvar QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\nvar TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {import(\"../extent.js\").Extent} bounds\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array<string>} insertIds\n */\n\n/**\n * @type {string}\n */\n\nvar FEATURE_PREFIX = 'feature';\n/**\n * @type {string}\n */\n\nvar XMLNS = 'http://www.w3.org/2000/xmlns/';\n/**\n * @type {string}\n */\n\nvar OGCNS = 'http://www.opengis.net/ogc';\n/**\n * @type {string}\n */\n\nvar WFSNS = 'http://www.opengis.net/wfs';\n/**\n * @type {string}\n */\n\nvar FESNS = 'http://www.opengis.net/fes';\n/**\n * @type {Object<string, string>}\n */\n\nvar SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n/**\n * @const\n * @type {string}\n */\n\nvar DEFAULT_VERSION = '1.1.0';\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\n\nvar WFS =\n/*@__PURE__*/\nfunction (XMLFeature) {\n  function WFS(opt_options) {\n    XMLFeature.call(this);\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n\n    this.featureType_ = options.featureType;\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n\n    this.featureNS_ = options.featureNS;\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n\n    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML3();\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  if (XMLFeature) WFS.__proto__ = XMLFeature;\n  WFS.prototype = Object.create(XMLFeature && XMLFeature.prototype);\n  WFS.prototype.constructor = WFS;\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n\n  WFS.prototype.getFeatureType = function getFeatureType() {\n    return this.featureType_;\n  };\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n\n\n  WFS.prototype.setFeatureType = function setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readFeaturesFromNode = function readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    var context = {\n      node: node\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    var objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    var features = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, objectStack, this.gmlFormat_);\n\n    if (!features) {\n      features = [];\n    }\n\n    return features;\n  };\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n\n\n  WFS.prototype.readTransactionResponse = function readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n      /** @type {Document} */\n      source);\n    } else {\n      return this.readTransactionResponseFromNode(\n      /** @type {Element} */\n      source);\n    }\n  };\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadata = function readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n      /** @type {Document} */\n      source);\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n      /** @type {Element} */\n      source);\n    }\n  };\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadataFromDocument = function readFeatureCollectionMetadataFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */\n        n);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadataFromNode = function readFeatureCollectionMetadataFromNode(node) {\n    var result = {};\n    var value = readNonNegativeIntegerString(node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n    /** @type {FeatureCollectionMetadata} */\n    result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  };\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n\n\n  WFS.prototype.readTransactionResponseFromDocument = function readTransactionResponseFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(\n        /** @type {Element} */\n        n);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n\n\n  WFS.prototype.readTransactionResponseFromNode = function readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n    /** @type {TransactionResponse} */\n    {}, TRANSACTION_RESPONSE_PARSERS, node, []);\n  };\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n\n\n  WFS.prototype.writeGetFeature = function writeGetFeature$1(options) {\n    var node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    var filter;\n\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', String(options.maxFeatures));\n      }\n\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', String(options.startIndex));\n      }\n\n      if (options.count !== undefined) {\n        node.setAttribute('count', String(options.count));\n      }\n\n      if (options.viewParams !== undefined) {\n        node.setAttribute('viewParams ', options.viewParams);\n      }\n\n      filter = options.filter;\n\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n\n        var bbox = bboxFilter(\n        /** @type {string} */\n        options.geometryName, options.bbox, options.srsName);\n\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n\n    var context = {\n      node: node\n    };\n    assign(context, {\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    });\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` should be an Array\n\n    writeGetFeature(node,\n    /** @type {!Array<string>} */\n    options.featureTypes, [context]);\n    return node;\n  };\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n\n\n  WFS.prototype.writeTransaction = function writeTransaction(inserts, updates, deletes, options) {\n    var objectStack = [];\n    var node = createElementNS(WFSNS, 'Transaction');\n    var version = options.version ? options.version : DEFAULT_VERSION;\n    var gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    var baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n\n    var obj;\n\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n\n    var schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n    var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n\n    if (inserts) {\n      obj = assign({\n        node: node\n      }, {\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'hasZ': options.hasZ,\n        'srsName': options.srsName\n      });\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Insert'), inserts, objectStack);\n    }\n\n    if (updates) {\n      obj = assign({\n        node: node\n      }, {\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'hasZ': options.hasZ,\n        'srsName': options.srsName\n      });\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Update'), updates, objectStack);\n    }\n\n    if (deletes) {\n      pushSerializeAndPop({\n        node: node,\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'srsName': options.srsName\n      }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Delete'), deletes, objectStack);\n    }\n\n    if (options.nativeElements) {\n      pushSerializeAndPop({\n        node: node,\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'srsName': options.srsName\n      }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Native'), options.nativeElements, objectStack);\n    }\n\n    return node;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readProjectionFromDocument = function readProjectionFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readProjectionFromNode = function readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n\n      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {\n          var objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return WFS;\n}(XMLFeature);\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\n\n\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\n\nvar OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\n\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\n\nvar INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\n\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeFeature(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var featureType = context['featureType'];\n  var featureNS = context['featureNS'];\n  var gmlVersion = context['gmlVersion'];\n  var child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  var filter = createElementNS(OGCNS, 'Filter');\n  var child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid',\n  /** @type {string} */\n  fid);\n  node.appendChild(filter);\n}\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\n\n\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  var prefix = featurePrefix + ':'; // The featureType already contains the prefix.\n\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeDelete(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n\n  var featureType = context['featureType'];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  var fid = feature.getId();\n\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeUpdate(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n\n  var featureType = context['featureType'];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var typeName = getTypeName(featurePrefix, featureType);\n  var geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  var fid = feature.getId();\n\n  if (fid !== undefined) {\n    var keys = feature.getKeys();\n    var values = [];\n\n    for (var i = 0, ii = keys.length; i < ii; i++) {\n      var value = feature.get(keys[i]);\n\n      if (value !== undefined) {\n        var name = keys[i];\n\n        if (value && typeof\n        /** @type {?} */\n        value.getSimplifiedGeometry === 'function') {\n          name = geometryName;\n        }\n\n        values.push({\n          name: name,\n          value: value\n        });\n      }\n    }\n\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    {\n      'gmlVersion': context['gmlVersion'],\n      node: node,\n      'hasZ': context['hasZ'],\n      'srsName': context['srsName']\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Property'), values, objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeProperty(node, pair, objectStack) {\n  var name = createElementNS(WFSNS, 'Name');\n  var context = objectStack[objectStack.length - 1];\n  var gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n\n  if (pair.value !== undefined && pair.value !== null) {\n    var value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n\n    if (pair.value && typeof\n    /** @type {?} */\n    pair.value.getSimplifiedGeometry === 'function') {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\n\nvar GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\n\nfunction writeQuery(node, featureType, objectStack) {\n  var context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var propertyNames = context['propertyNames'];\n  var srsName = context['srsName'];\n  var typeName; // If feature prefix is not defined, we must not use the default prefix.\n\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n\n  node.setAttribute('typeName', typeName);\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n\n  var item =\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory('PropertyName'), propertyNames, objectStack);\n  var filter = context['filter'];\n\n  if (filter) {\n    var child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeBboxFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Contains.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeContainsFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Intersects.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Within.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeWithinFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeDuringFilter(node, filter, objectStack) {\n  var valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n  var timePeriod = createElementNS(GMLNS, 'TimePeriod');\n  node.appendChild(timePeriod);\n  var begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n  var end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  var conditions = filter.conditions;\n\n  for (var i = 0, ii = conditions.length; i < ii; ++i) {\n    var condition = conditions[i];\n    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  var condition = filter.condition;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n  var lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n  var upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\n\n\nfunction writeOgcExpression(tagName, node, value) {\n  var property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\n\n\nfunction writeTimeInstant(node, time) {\n  var timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n  var timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @return {Node} Result.\n * @api\n */\n\n\nexport function writeFilter(filter) {\n  var child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n/**\n * @param {Node} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\n\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  var context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  var item =\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory('Query'), featureTypes, objectStack);\n}\n\nexport default WFS;","map":null,"metadata":{},"sourceType":"module"}