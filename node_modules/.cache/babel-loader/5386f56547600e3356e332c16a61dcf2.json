{"ast":null,"code":"/**\n * @module ol/source/Tile\n */\nimport { inherits } from '../util.js';\nimport { UNDEFINED } from '../functions.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport Event from '../events/Event.js';\nimport { equivalent } from '../proj.js';\nimport { toSize, scale as scaleSize } from '../size.js';\nimport Source from '../source/Source.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { wrapX, getForProjection as getTileGridForProjection } from '../tilegrid.js';\n/**\n * @typedef {Object} Options\n * @property {module:ol/source/Source~AttributionLike} [attributions]\n * @property {number} [cacheSize]\n * @property {module:ol/extent~Extent} [extent]\n * @property {boolean} [opaque]\n * @property {number} [tilePixelRatio]\n * @property {module:ol/proj~ProjectionLike} [projection]\n * @property {module:ol/source/State} [state]\n * @property {module:ol/tilegrid/TileGrid} [tileGrid]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @constructor\n * @abstract\n * @extends {module:ol/source/Source}\n * @param {module:ol/source/Tile~Options=} options SourceTile source options.\n * @api\n */\n\nconst TileSource = function (options) {\n  Source.call(this, {\n    attributions: options.attributions,\n    extent: options.extent,\n    projection: options.projection,\n    state: options.state,\n    wrapX: options.wrapX\n  });\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n  /**\n   * @protected\n   * @type {module:ol/tilegrid/TileGrid}\n   */\n\n  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n  /**\n   * @protected\n   * @type {module:ol/TileCache}\n   */\n\n  this.tileCache = new TileCache(options.cacheSize);\n  /**\n   * @protected\n   * @type {module:ol/size~Size}\n   */\n\n  this.tmpSize = [0, 0];\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this.key_ = '';\n  /**\n   * @protected\n   * @type {module:ol/Tile~Options}\n   */\n\n  this.tileOptions = {\n    transition: options.transition\n  };\n};\n\ninherits(TileSource, Source);\n/**\n * @return {boolean} Can expire cache.\n */\n\nTileSource.prototype.canExpireCache = function () {\n  return this.tileCache.canExpireCache();\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\n */\n\n\nTileSource.prototype.expireCache = function (projection, usedTiles) {\n  const tileCache = this.getTileCacheForProjection(projection);\n\n  if (tileCache) {\n    tileCache.expireCache(usedTiles);\n  }\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @param {number} z Zoom level.\n * @param {module:ol/TileRange} tileRange Tile range.\n * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each\n *     loaded tile.  If the callback returns `false`, the tile will not be\n *     considered loaded.\n * @return {boolean} The tile range is fully covered with loaded tiles.\n */\n\n\nTileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {\n  const tileCache = this.getTileCacheForProjection(projection);\n\n  if (!tileCache) {\n    return false;\n  }\n\n  let covered = true;\n  let tile, tileCoordKey, loaded;\n\n  for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n    for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n      tileCoordKey = getKeyZXY(z, x, y);\n      loaded = false;\n\n      if (tileCache.containsKey(tileCoordKey)) {\n        tile =\n        /** @type {!module:ol/Tile} */\n        tileCache.get(tileCoordKey);\n        loaded = tile.getState() === TileState.LOADED;\n\n        if (loaded) {\n          loaded = callback(tile) !== false;\n        }\n      }\n\n      if (!loaded) {\n        covered = false;\n      }\n    }\n  }\n\n  return covered;\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {number} Gutter.\n */\n\n\nTileSource.prototype.getGutter = function (projection) {\n  return 0;\n};\n/**\n * Return the key to be used for all tiles in the source.\n * @return {string} The key for all tiles.\n * @protected\n */\n\n\nTileSource.prototype.getKey = function () {\n  return this.key_;\n};\n/**\n * Set the value to be used as the key for all tiles in the source.\n * @param {string} key The key for tiles.\n * @protected\n */\n\n\nTileSource.prototype.setKey = function (key) {\n  if (this.key_ !== key) {\n    this.key_ = key;\n    this.changed();\n  }\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {boolean} Opaque.\n */\n\n\nTileSource.prototype.getOpaque = function (projection) {\n  return this.opaque_;\n};\n/**\n * @inheritDoc\n */\n\n\nTileSource.prototype.getResolutions = function () {\n  return this.tileGrid.getResolutions();\n};\n/**\n * @abstract\n * @param {number} z Tile coordinate z.\n * @param {number} x Tile coordinate x.\n * @param {number} y Tile coordinate y.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {!module:ol/Tile} Tile.\n */\n\n\nTileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {};\n/**\n * Return the tile grid of the tile source.\n * @return {module:ol/tilegrid/TileGrid} Tile grid.\n * @api\n */\n\n\nTileSource.prototype.getTileGrid = function () {\n  return this.tileGrid;\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {!module:ol/tilegrid/TileGrid} Tile grid.\n */\n\n\nTileSource.prototype.getTileGridForProjection = function (projection) {\n  if (!this.tileGrid) {\n    return getTileGridForProjection(projection);\n  } else {\n    return this.tileGrid;\n  }\n};\n/**\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {module:ol/TileCache} Tile cache.\n * @protected\n */\n\n\nTileSource.prototype.getTileCacheForProjection = function (projection) {\n  const thisProj = this.getProjection();\n\n  if (thisProj && !equivalent(thisProj, projection)) {\n    return null;\n  } else {\n    return this.tileCache;\n  }\n};\n/**\n * Get the tile pixel ratio for this source. Subclasses may override this\n * method, which is meant to return a supported pixel ratio that matches the\n * provided `pixelRatio` as close as possible.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Tile pixel ratio.\n */\n\n\nTileSource.prototype.getTilePixelRatio = function (pixelRatio) {\n  return this.tilePixelRatio_;\n};\n/**\n * @param {number} z Z.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/proj/Projection} projection Projection.\n * @return {module:ol/size~Size} Tile size.\n */\n\n\nTileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n  const tileGrid = this.getTileGridForProjection(projection);\n  const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n  const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n\n  if (tilePixelRatio == 1) {\n    return tileSize;\n  } else {\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n};\n/**\n * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n * is outside the resolution and extent range of the tile grid, `null` will be\n * returned.\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\n * @param {module:ol/proj/Projection=} opt_projection Projection.\n * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n *     null if no tile URL should be created for the passed `tileCoord`.\n */\n\n\nTileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {\n  const projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n  const tileGrid = this.getTileGridForProjection(projection);\n\n  if (this.getWrapX() && projection.isGlobal()) {\n    tileCoord = wrapX(tileGrid, tileCoord, projection);\n  }\n\n  return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n};\n/**\n * @inheritDoc\n */\n\n\nTileSource.prototype.refresh = function () {\n  this.tileCache.clear();\n  this.changed();\n};\n/**\n * Marks a tile coord as being used, without triggering a load.\n * @param {number} z Tile coordinate z.\n * @param {number} x Tile coordinate x.\n * @param {number} y Tile coordinate y.\n * @param {module:ol/proj/Projection} projection Projection.\n */\n\n\nTileSource.prototype.useTile = UNDEFINED;\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n *\n * @constructor\n * @extends {module:ol/events/Event}\n * @param {string} type Type.\n * @param {module:ol/Tile} tile The tile.\n */\n\nexport const TileSourceEvent = function (type, tile) {\n  Event.call(this, type);\n  /**\n   * The tile related to the event.\n   * @type {module:ol/Tile}\n   * @api\n   */\n\n  this.tile = tile;\n};\ninherits(TileSourceEvent, Event);\nexport default TileSource;","map":null,"metadata":{},"sourceType":"module"}