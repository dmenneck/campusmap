{"ast":null,"code":"/**\n * @module ol/events/EventTarget\n */\nimport { inherits } from '../util.js';\nimport Disposable from '../Disposable.js';\nimport { unlistenAll } from '../events.js';\nimport { UNDEFINED } from '../functions.js';\nimport Event from '../events/Event.js';\n/**\n * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n *\n * @constructor\n * @extends {module:ol/Disposable}\n */\n\nconst EventTarget = function () {\n  Disposable.call(this);\n  /**\n   * @private\n   * @type {!Object.<string, number>}\n   */\n\n  this.pendingRemovals_ = {};\n  /**\n   * @private\n   * @type {!Object.<string, number>}\n   */\n\n  this.dispatching_ = {};\n  /**\n   * @private\n   * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}\n   */\n\n  this.listeners_ = {};\n};\n\ninherits(EventTarget, Disposable);\n/**\n * @param {string} type Type.\n * @param {module:ol/events~ListenerFunction} listener Listener.\n */\n\nEventTarget.prototype.addEventListener = function (type, listener) {\n  let listeners = this.listeners_[type];\n\n  if (!listeners) {\n    listeners = this.listeners_[type] = [];\n  }\n\n  if (listeners.indexOf(listener) === -1) {\n    listeners.push(listener);\n  }\n};\n/**\n * @param {{type: string,\n *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|module:ol/events/Event|\n *     string} event Event or event type.\n * @return {boolean|undefined} `false` if anyone called preventDefault on the\n *     event object or if any of the listeners returned false.\n */\n\n\nEventTarget.prototype.dispatchEvent = function (event) {\n  const evt = typeof event === 'string' ? new Event(event) : event;\n  const type = evt.type;\n  evt.target = this;\n  const listeners = this.listeners_[type];\n  let propagate;\n\n  if (listeners) {\n    if (!(type in this.dispatching_)) {\n      this.dispatching_[type] = 0;\n      this.pendingRemovals_[type] = 0;\n    }\n\n    ++this.dispatching_[type];\n\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n\n    --this.dispatching_[type];\n\n    if (this.dispatching_[type] === 0) {\n      let pendingRemovals = this.pendingRemovals_[type];\n      delete this.pendingRemovals_[type];\n\n      while (pendingRemovals--) {\n        this.removeEventListener(type, UNDEFINED);\n      }\n\n      delete this.dispatching_[type];\n    }\n\n    return propagate;\n  }\n};\n/**\n * @inheritDoc\n */\n\n\nEventTarget.prototype.disposeInternal = function () {\n  unlistenAll(this);\n};\n/**\n * Get the listeners for a specified event type. Listeners are returned in the\n * order that they will be called in.\n *\n * @param {string} type Type.\n * @return {Array.<module:ol/events~ListenerFunction>} Listeners.\n */\n\n\nEventTarget.prototype.getListeners = function (type) {\n  return this.listeners_[type];\n};\n/**\n * @param {string=} opt_type Type. If not provided,\n *     `true` will be returned if this EventTarget has any listeners.\n * @return {boolean} Has listeners.\n */\n\n\nEventTarget.prototype.hasListener = function (opt_type) {\n  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n};\n/**\n * @param {string} type Type.\n * @param {module:ol/events~ListenerFunction} listener Listener.\n */\n\n\nEventTarget.prototype.removeEventListener = function (type, listener) {\n  const listeners = this.listeners_[type];\n\n  if (listeners) {\n    const index = listeners.indexOf(listener);\n\n    if (type in this.pendingRemovals_) {\n      // make listener a no-op, and remove later in #dispatchEvent()\n      listeners[index] = UNDEFINED;\n      ++this.pendingRemovals_[type];\n    } else {\n      listeners.splice(index, 1);\n\n      if (listeners.length === 0) {\n        delete this.listeners_[type];\n      }\n    }\n  }\n};\n\nexport default EventTarget;","map":null,"metadata":{},"sourceType":"module"}