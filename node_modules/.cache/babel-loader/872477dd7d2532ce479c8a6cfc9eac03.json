{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport { getUid, inherits } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport { equivalent as equivalentProjection } from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup, { replayDeclutter } from '../../render/canvas/ReplayGroup.js';\nimport { ORDER } from '../../render/replay.js';\nimport CanvasTileLayerRenderer from '../canvas/TileLayer.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { create as createTransform, compose as composeTransform, reset as resetTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\n/**\n * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}\n */\n\nconst IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n/**\n * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}\n */\n\nconst VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n/**\n * @constructor\n * @extends {module:ol/renderer/canvas/TileLayer}\n * @param {module:ol/layer/VectorTile} layer VectorTile layer.\n * @api\n */\n\nconst CanvasVectorTileLayerRenderer = function (layer) {\n  /**\n   * @type {CanvasRenderingContext2D}\n   */\n  this.context = null;\n  CanvasTileLayerRenderer.call(this, layer);\n  /**\n   * Declutter tree.\n   * @private\n   */\n\n  this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.dirty_ = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.renderedLayerRevision_;\n  /**\n   * @private\n   * @type {module:ol/transform~Transform}\n   */\n\n  this.tmpTransform_ = createTransform(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n\n  this.zDirection = layer.getRenderMode() == VectorTileRenderType.VECTOR ? 1 : 0;\n  listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n};\n\ninherits(CanvasVectorTileLayerRenderer, CanvasTileLayerRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\nCanvasVectorTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/VectorTileLayer} The layer renderer.\n */\n\n\nCanvasVectorTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer(\n  /** @type {module:ol/layer/VectorTile} */\n  layer);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.disposeInternal = function () {\n  unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n  const tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n\n  if (tile.getState() === TileState.LOADED) {\n    this.createReplayGroup_(tile, pixelRatio, projection);\n\n    if (this.context) {\n      this.renderTileImage_(tile, pixelRatio, projection);\n    }\n  }\n\n  return tile;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState, layerState) {\n  const layer = this.getLayer();\n  const layerRevision = layer.getRevision();\n\n  if (this.renderedLayerRevision_ != layerRevision) {\n    this.renderedTiles.length = 0;\n    const renderMode = layer.getRenderMode();\n\n    if (!this.context && renderMode != VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n\n    if (this.context && renderMode == VectorTileRenderType.VECTOR) {\n      this.context = null;\n    }\n  }\n\n  this.renderedLayerRevision_ = layerRevision;\n  return CanvasTileLayerRenderer.prototype.prepareFrame.apply(this, arguments);\n};\n/**\n * @param {module:ol/VectorImageTile} tile Tile.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/proj/Projection} projection Projection.\n * @private\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function (tile, pixelRatio, projection) {\n  const layer = this.getLayer();\n  const revision = layer.getRevision();\n  const renderOrder =\n  /** @type {module:ol/render~OrderFunction} */\n  layer.getRenderOrder() || null;\n  const replayState = tile.getReplayState(layer);\n\n  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n    return;\n  }\n\n  const source =\n  /** @type {module:ol/source/VectorTile} */\n  layer.getSource();\n  const sourceTileGrid = source.getTileGrid();\n  const tileGrid = source.getTileGridForProjection(projection);\n  const resolution = tileGrid.getResolution(tile.tileCoord[0]);\n  const tileExtent = tile.extent;\n  const zIndexKeys = {};\n\n  for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n    const sourceTile = tile.getTile(tile.tileKeys[t]);\n\n    if (sourceTile.getState() != TileState.LOADED) {\n      continue;\n    }\n\n    const sourceTileCoord = sourceTile.tileCoord;\n    const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n    const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n    const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\n    const tileProjection = sourceTile.getProjection();\n    let reproject = false;\n\n    if (!equivalentProjection(projection, tileProjection)) {\n      reproject = true;\n      sourceTile.setProjection(projection);\n    }\n\n    replayState.dirty = false;\n    const replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    /**\n     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n     * @this {module:ol/renderer/canvas/VectorTileLayer}\n     */\n\n    const render = function (feature) {\n      let styles;\n      const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n\n      if (styles) {\n        const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n        replayState.dirty = replayState.dirty || dirty;\n      }\n    };\n\n    const features = sourceTile.getFeatures();\n\n    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n      features.sort(renderOrder);\n    }\n\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      const feature = features[i];\n\n      if (reproject) {\n        if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n          // projected tile extent\n          tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space\n\n          tileProjection.setExtent(sourceTile.getExtent());\n        }\n\n        feature.getGeometry().transform(tileProjection, projection);\n      }\n\n      if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n        render.call(this, feature);\n      }\n    }\n\n    replayGroup.finish();\n\n    for (const r in replayGroup.getReplays()) {\n      zIndexKeys[r] = true;\n    }\n\n    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n  }\n\n  replayState.renderedRevision = revision;\n  replayState.renderedRenderOrder = renderOrder;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\n  const resolution = frameState.viewState.resolution;\n  const rotation = frameState.viewState.rotation;\n  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n  const layer = this.getLayer();\n  /** @type {!Object.<string, boolean>} */\n\n  const features = {};\n  /** @type {Array.<module:ol/VectorImageTile>} */\n\n  const renderedTiles = this.renderedTiles;\n  let bufferedExtent, found;\n  let i, ii, replayGroup;\n\n  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n    const tile = renderedTiles[i];\n    bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n\n    if (!containsCoordinate(bufferedExtent, coordinate)) {\n      continue;\n    }\n\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n      /**\n       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n       * @return {?} Callback result.\n       */\n      function (feature) {\n        const key = getUid(feature).toString();\n\n        if (!(key in features)) {\n          features[key] = true;\n          return callback.call(thisArg, feature, layer);\n        }\n      }, null);\n    }\n  }\n\n  return found;\n};\n/**\n * @param {module:ol/VectorTile} tile Tile.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @return {module:ol/transform~Transform} transform Transform.\n * @private\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function (tile, frameState) {\n  const layer = this.getLayer();\n  const source =\n  /** @type {module:ol/source/VectorTile} */\n  layer.getSource();\n  const tileGrid = source.getTileGrid();\n  const tileCoord = tile.tileCoord;\n  const tileResolution = tileGrid.getResolution(tileCoord[0]);\n  const viewState = frameState.viewState;\n  const pixelRatio = frameState.pixelRatio;\n  const renderResolution = viewState.resolution / pixelRatio;\n  const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n  const center = viewState.center;\n  const origin = getTopLeft(tileExtent);\n  const size = frameState.size;\n  const offsetX = Math.round(pixelRatio * size[0] / 2);\n  const offsetY = Math.round(pixelRatio * size[1] / 2);\n  return composeTransform(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n};\n/**\n * @param {module:ol/events/Event} event Event.\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function (event) {\n  const layer = this.getLayer();\n\n  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n    layer.changed();\n  }\n};\n/**\n * Handle changes in image style state.\n * @param {module:ol/events/Event} event Image style change event.\n * @private\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n  this.renderIfReadyAndVisible();\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.postCompose = function (context, frameState, layerState) {\n  const layer = this.getLayer();\n  const renderMode = layer.getRenderMode();\n\n  if (renderMode != VectorTileRenderType.IMAGE) {\n    const declutterReplays = layer.getDeclutter() ? {} : null;\n    const source =\n    /** @type {module:ol/source/VectorTile} */\n    layer.getSource();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const pixelRatio = frameState.pixelRatio;\n    const rotation = frameState.viewState.rotation;\n    const size = frameState.size;\n    let offsetX, offsetY;\n\n    if (rotation) {\n      offsetX = Math.round(pixelRatio * size[0] / 2);\n      offsetY = Math.round(pixelRatio * size[1] / 2);\n      rotateAtOffset(context, -rotation, offsetX, offsetY);\n    }\n\n    if (declutterReplays) {\n      this.declutterTree_.clear();\n    }\n\n    const tiles = this.renderedTiles;\n    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    const clips = [];\n    const zs = [];\n\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile =\n      /** @type {module:ol/VectorImageTile} */\n      tiles[i];\n\n      if (tile.getState() == TileState.ABORT) {\n        continue;\n      }\n\n      const tileCoord = tile.tileCoord;\n      const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n      let transform = undefined;\n\n      for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        const sourceTile = tile.getTile(tile.tileKeys[t]);\n\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n\n        const replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());\n\n        if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n          // sourceTile was not yet loaded when this.createReplayGroup_() was\n          // called, or it has no replays of the types we want to render\n          continue;\n        }\n\n        if (!transform) {\n          transform = this.getTransform(frameState, worldOffset);\n        }\n\n        const currentZ = sourceTile.tileCoord[0];\n        const currentClip = replayGroup.getClipCoords(transform);\n        context.save();\n        context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are\n        // already filled by a higher resolution tile\n\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          const clip = clips[j];\n\n          if (currentZ < zs[j]) {\n            context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n            context.moveTo(currentClip[0], currentClip[1]);\n            context.lineTo(currentClip[2], currentClip[3]);\n            context.lineTo(currentClip[4], currentClip[5]);\n            context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n            context.moveTo(clip[6], clip[7]);\n            context.lineTo(clip[4], clip[5]);\n            context.lineTo(clip[2], clip[3]);\n            context.lineTo(clip[0], clip[1]);\n            context.clip();\n          }\n        }\n\n        replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);\n        context.restore();\n        clips.push(currentClip);\n        zs.push(currentZ);\n      }\n    }\n\n    if (declutterReplays) {\n      replayDeclutter(declutterReplays, context, rotation);\n    }\n\n    if (rotation) {\n      rotateAtOffset(context, rotation,\n      /** @type {number} */\n      offsetX,\n      /** @type {number} */\n      offsetY);\n    }\n  }\n\n  CanvasTileLayerRenderer.prototype.postCompose.apply(this, arguments);\n};\n/**\n * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.\n * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.\n * @return {boolean} `true` if an image is loading.\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, replayGroup) {\n  if (!styles) {\n    return false;\n  }\n\n  let loading = false;\n\n  if (Array.isArray(styles)) {\n    for (let i = 0, ii = styles.length; i < ii; ++i) {\n      loading = renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n    }\n  } else {\n    loading = renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n  }\n\n  return loading;\n};\n/**\n * @param {module:ol/VectorImageTile} tile Tile.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/proj/Projection} projection Projection.\n * @private\n */\n\n\nCanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, pixelRatio, projection) {\n  const layer = this.getLayer();\n  const replayState = tile.getReplayState(layer);\n  const revision = layer.getRevision();\n  const replays = IMAGE_REPLAYS[layer.getRenderMode()];\n\n  if (replays && replayState.renderedTileRevision !== revision) {\n    replayState.renderedTileRevision = revision;\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source =\n    /** @type {module:ol/source/VectorTile} */\n    layer.getSource();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n\n    for (let i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n      const sourceTile = tile.getTile(tile.tileKeys[i]);\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      const pixelScale = pixelRatio / resolution;\n      const transform = resetTransform(this.tmpTransform_);\n      scaleTransform(transform, pixelScale, -pixelScale);\n      translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n      const replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n      replayGroup.replay(context, transform, 0, {}, replays);\n    }\n  }\n};\n\nexport default CanvasVectorTileLayerRenderer;","map":null,"metadata":{},"sourceType":"module"}