{"ast":null,"code":"/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport { inherits } from '../util.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getArea, getCenter, getIntersection } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from '../reproj/Triangulation.js';\n/**\n * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n * @constructor\n * @extends {module:ol/Tile}\n * @param {module:ol/proj/Projection} sourceProj Source projection.\n * @param {module:ol/tilegrid/TileGrid} sourceTileGrid Source tile grid.\n * @param {module:ol/proj/Projection} targetProj Target projection.\n * @param {module:ol/tilegrid/TileGrid} targetTileGrid Target tile grid.\n * @param {module:ol/tilecoord~TileCoord} tileCoord Coordinate of the tile.\n * @param {module:ol/tilecoord~TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} gutter Gutter of the source tiles.\n * @param {module:ol/reproj/Tile~FunctionType} getTileFunction\n *     Function returning source tiles (z, x, y, pixelRatio).\n * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n */\n\nconst ReprojTile = function (sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n  Tile.call(this, tileCoord, TileState.IDLE);\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.pixelRatio_ = pixelRatio;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.gutter_ = gutter;\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = null;\n  /**\n   * @private\n   * @type {module:ol/tilegrid/TileGrid}\n   */\n\n  this.sourceTileGrid_ = sourceTileGrid;\n  /**\n   * @private\n   * @type {module:ol/tilegrid/TileGrid}\n   */\n\n  this.targetTileGrid_ = targetTileGrid;\n  /**\n   * @private\n   * @type {module:ol/tilecoord~TileCoord}\n   */\n\n  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n  /**\n   * @private\n   * @type {!Array.<module:ol/Tile>}\n   */\n\n  this.sourceTiles_ = [];\n  /**\n   * @private\n   * @type {Array.<module:ol/events~EventsKey>}\n   */\n\n  this.sourcesListenerKeys_ = null;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.sourceZ_ = 0;\n  const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n  const maxTargetExtent = this.targetTileGrid_.getExtent();\n  let maxSourceExtent = this.sourceTileGrid_.getExtent();\n  const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n  if (getArea(limitedTargetExtent) === 0) {\n    // Tile is completely outside range -> EMPTY\n    // TODO: is it actually correct that the source even creates the tile ?\n    this.state = TileState.EMPTY;\n    return;\n  }\n\n  const sourceProjExtent = sourceProj.getExtent();\n\n  if (sourceProjExtent) {\n    if (!maxSourceExtent) {\n      maxSourceExtent = sourceProjExtent;\n    } else {\n      maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n    }\n  }\n\n  const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n  const targetCenter = getCenter(limitedTargetExtent);\n  const sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    // invalid sourceResolution -> EMPTY\n    // probably edges of the projections when no extent is defined\n    this.state = TileState.EMPTY;\n    return;\n  }\n\n  const errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n  /**\n   * @private\n   * @type {!module:ol/reproj/Triangulation}\n   */\n\n  this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n  if (this.triangulation_.getTriangles().length === 0) {\n    // no valid triangles -> EMPTY\n    this.state = TileState.EMPTY;\n    return;\n  }\n\n  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n  let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n  if (maxSourceExtent) {\n    if (sourceProj.canWrapX()) {\n      sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n      sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n    } else {\n      sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n    }\n  }\n\n  if (!getArea(sourceExtent)) {\n    this.state = TileState.EMPTY;\n  } else {\n    const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n\n    for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n      for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n        const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n\n        if (tile) {\n          this.sourceTiles_.push(tile);\n        }\n      }\n    }\n\n    if (this.sourceTiles_.length === 0) {\n      this.state = TileState.EMPTY;\n    }\n  }\n};\n\ninherits(ReprojTile, Tile);\n/**\n * @inheritDoc\n */\n\nReprojTile.prototype.disposeInternal = function () {\n  if (this.state == TileState.LOADING) {\n    this.unlistenSources_();\n  }\n\n  Tile.prototype.disposeInternal.call(this);\n};\n/**\n * Get the HTML Canvas element for this tile.\n * @return {HTMLCanvasElement} Canvas.\n */\n\n\nReprojTile.prototype.getImage = function () {\n  return this.canvas_;\n};\n/**\n * @private\n */\n\n\nReprojTile.prototype.reproject_ = function () {\n  const sources = [];\n  this.sourceTiles_.forEach(function (tile, i, arr) {\n    if (tile && tile.getState() == TileState.LOADED) {\n      sources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        image: tile.getImage()\n      });\n    }\n  }.bind(this));\n  this.sourceTiles_.length = 0;\n\n  if (sources.length === 0) {\n    this.state = TileState.ERROR;\n  } else {\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const width = typeof size === 'number' ? size : size[0];\n    const height = typeof size === 'number' ? size : size[1];\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n    this.state = TileState.LOADED;\n  }\n\n  this.changed();\n};\n/**\n * @inheritDoc\n */\n\n\nReprojTile.prototype.load = function () {\n  if (this.state == TileState.IDLE) {\n    this.state = TileState.LOADING;\n    this.changed();\n    let leftToLoad = 0;\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      const state = tile.getState();\n\n      if (state == TileState.IDLE || state == TileState.LOADING) {\n        leftToLoad++;\n        const sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n          const state = tile.getState();\n\n          if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        }, this);\n        this.sourcesListenerKeys_.push(sourceListenKey);\n      }\n    }.bind(this));\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      const state = tile.getState();\n\n      if (state == TileState.IDLE) {\n        tile.load();\n      }\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    }\n  }\n};\n/**\n * @private\n */\n\n\nReprojTile.prototype.unlistenSources_ = function () {\n  this.sourcesListenerKeys_.forEach(unlistenByKey);\n  this.sourcesListenerKeys_ = null;\n};\n\nexport default ReprojTile;","map":null,"metadata":{},"sourceType":"module"}