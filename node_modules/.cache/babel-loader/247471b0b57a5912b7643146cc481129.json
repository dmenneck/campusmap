{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport { getUid } from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment } from '../coordinate.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport { getValues } from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Feature.js\").default} */\n\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element\n    );\n  }\n}\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\n\n\nvar Snap =\n/*@__PURE__*/\nfunction (PointerInteraction) {\n  function Snap(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    PointerInteraction.call(this, pointerOptions);\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n\n    this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    this.pendingFeatures_ = {};\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    this.pixelCoordinate_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n\n    this.sortByDistance_ = sortByDistance.bind(this);\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n\n    this.rBush_ = new RBush();\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  if (PointerInteraction) Snap.__proto__ = PointerInteraction;\n  Snap.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  Snap.prototype.constructor = Snap;\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n  Snap.prototype.addFeature = function addFeature(feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function getFeatures_() {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Snap.prototype.handleEvent = function handleEvent(evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return PointerInteraction.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n    var feature =\n    /** @type {import(\"../Feature.js\").default} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Snap.prototype.handleUpEvent = function handleUpEvent(evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function removeFeature(feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Snap.prototype.setMap = function setMap(map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features =\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    PointerInteraction.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function snapTo(pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles\n\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n\n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n          /** @type {import(\"../geom/Circle.js\").default} */\n          segments[0].feature.getGeometry());\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n\n    return (\n      /** @type {Result} */\n      {\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      }\n    );\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n    var polygon = fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData =\n      /** @type {SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData =\n      /** @type {SegmentData} */\n      {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n    var points = geometry.getCoordinates();\n\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData =\n      /** @type {SegmentData} */\n      {\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData =\n          /** @type {SegmentData} */\n          {\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData =\n    /** @type {SegmentData} */\n    {\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData =\n        /** @type {SegmentData} */\n        {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\n\n\nfunction sortByDistance(a, b) {\n  var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;","map":{"version":3,"sources":["../../../src/ol/interaction/Snap.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport {getUid} from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport {distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment} from '../coordinate.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {TRUE, FALSE} from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport {getValues} from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature;\n  } else if (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n    return /** @type {import(\"../Feature.js\").default} */ (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n  }\n\n}\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_, this);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function(node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(this.features_, CollectionEventType.ADD,\n            this.handleFeatureAdd_, this),\n          listen(this.features_, CollectionEventType.REMOVE,\n            this.handleFeatureRemove_, this)\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(this.source_, VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_, this),\n          listen(this.source_, VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_, this)\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n\n    const lowerLeft = map.getCoordinateFromPixel(\n      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    const upperRight = map.getCoordinateFromPixel(\n      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    let segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function(segment) {\n        return segment.feature.getGeometry().getType() !==\n            GeometryType.CIRCLE;\n      });\n    }\n\n    let snappedToVertex = false;\n    let snapped = false;\n    let vertex = null;\n    let vertexPixel = null;\n    let dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      const closestSegment = segments[0].segment;\n      const isCircle = segments[0].feature.getGeometry().getType() ===\n          GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (segments[0].feature.getGeometry()));\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (\n      /** @type {Result} */ ({\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      })\n    );\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const polygon = fromCircle(geometry);\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: [coordinates, coordinates]\n      });\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n          const segmentData = /** @type {SegmentData} */ ({\n            feature: feature,\n            segment: segment\n          });\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    const segmentData = /** @type {SegmentData} */ ({\n      feature: feature,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n}\n\n\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\nfunction sortByDistance(a, b) {\n  const deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  const deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;\n"]},"metadata":{},"sourceType":"module"}