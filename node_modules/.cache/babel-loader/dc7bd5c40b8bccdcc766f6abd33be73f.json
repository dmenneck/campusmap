{"ast":null,"code":"/**\n * @module ol/format/WFS\n */\nimport { assert } from '../asserts.js';\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport { and as andFilter, bbox as bboxFilter } from './filter.js';\nimport XMLFeature from './XMLFeature.js';\nimport { readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode } from './xsd.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { createElementNS, isDocument, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode, pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI } from '../xml.js';\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\nvar TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds')\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\nvar QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\nvar TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {import(\"../extent.js\").Extent} bounds\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array<string>} insertIds\n */\n\n/**\n * @type {string}\n */\n\nvar FEATURE_PREFIX = 'feature';\n/**\n * @type {string}\n */\n\nvar XMLNS = 'http://www.w3.org/2000/xmlns/';\n/**\n * @type {string}\n */\n\nvar OGCNS = 'http://www.opengis.net/ogc';\n/**\n * @type {string}\n */\n\nvar WFSNS = 'http://www.opengis.net/wfs';\n/**\n * @type {string}\n */\n\nvar FESNS = 'http://www.opengis.net/fes';\n/**\n * @type {Object<string, string>}\n */\n\nvar SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n/**\n * @const\n * @type {string}\n */\n\nvar DEFAULT_VERSION = '1.1.0';\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\n\nvar WFS =\n/*@__PURE__*/\nfunction (XMLFeature) {\n  function WFS(opt_options) {\n    XMLFeature.call(this);\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n\n    this.featureType_ = options.featureType;\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n\n    this.featureNS_ = options.featureNS;\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n\n    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML3();\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  if (XMLFeature) WFS.__proto__ = XMLFeature;\n  WFS.prototype = Object.create(XMLFeature && XMLFeature.prototype);\n  WFS.prototype.constructor = WFS;\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n\n  WFS.prototype.getFeatureType = function getFeatureType() {\n    return this.featureType_;\n  };\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n\n\n  WFS.prototype.setFeatureType = function setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readFeaturesFromNode = function readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    var context = {\n      node: node\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    var objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    var features = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, objectStack, this.gmlFormat_);\n\n    if (!features) {\n      features = [];\n    }\n\n    return features;\n  };\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n\n\n  WFS.prototype.readTransactionResponse = function readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n      /** @type {Document} */\n      source);\n    } else {\n      return this.readTransactionResponseFromNode(\n      /** @type {Element} */\n      source);\n    }\n  };\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadata = function readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      var doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n      /** @type {Document} */\n      source);\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n      /** @type {Element} */\n      source);\n    }\n  };\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadataFromDocument = function readFeatureCollectionMetadataFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */\n        n);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n\n\n  WFS.prototype.readFeatureCollectionMetadataFromNode = function readFeatureCollectionMetadataFromNode(node) {\n    var result = {};\n    var value = readNonNegativeIntegerString(node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n    /** @type {FeatureCollectionMetadata} */\n    result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  };\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n\n\n  WFS.prototype.readTransactionResponseFromDocument = function readTransactionResponseFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(\n        /** @type {Element} */\n        n);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n\n\n  WFS.prototype.readTransactionResponseFromNode = function readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n    /** @type {TransactionResponse} */\n    {}, TRANSACTION_RESPONSE_PARSERS, node, []);\n  };\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n\n\n  WFS.prototype.writeGetFeature = function writeGetFeature$1(options) {\n    var node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    var filter;\n\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', String(options.maxFeatures));\n      }\n\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', String(options.startIndex));\n      }\n\n      if (options.count !== undefined) {\n        node.setAttribute('count', String(options.count));\n      }\n\n      if (options.viewParams !== undefined) {\n        node.setAttribute('viewParams ', options.viewParams);\n      }\n\n      filter = options.filter;\n\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n\n        var bbox = bboxFilter(\n        /** @type {string} */\n        options.geometryName, options.bbox, options.srsName);\n\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n\n    var context = {\n      node: node\n    };\n    assign(context, {\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    });\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` should be an Array\n\n    writeGetFeature(node,\n    /** @type {!Array<string>} */\n    options.featureTypes, [context]);\n    return node;\n  };\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n\n\n  WFS.prototype.writeTransaction = function writeTransaction(inserts, updates, deletes, options) {\n    var objectStack = [];\n    var node = createElementNS(WFSNS, 'Transaction');\n    var version = options.version ? options.version : DEFAULT_VERSION;\n    var gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    var baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n\n    var obj;\n\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n\n    var schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n    var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n\n    if (inserts) {\n      obj = assign({\n        node: node\n      }, {\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'hasZ': options.hasZ,\n        'srsName': options.srsName\n      });\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Insert'), inserts, objectStack);\n    }\n\n    if (updates) {\n      obj = assign({\n        node: node\n      }, {\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'hasZ': options.hasZ,\n        'srsName': options.srsName\n      });\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Update'), updates, objectStack);\n    }\n\n    if (deletes) {\n      pushSerializeAndPop({\n        node: node,\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'srsName': options.srsName\n      }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Delete'), deletes, objectStack);\n    }\n\n    if (options.nativeElements) {\n      pushSerializeAndPop({\n        node: node,\n        'featureNS': options.featureNS,\n        'featureType': options.featureType,\n        'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion,\n        'srsName': options.srsName\n      }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Native'), options.nativeElements, objectStack);\n    }\n\n    return node;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readProjectionFromDocument = function readProjectionFromDocument(doc) {\n    for (var n =\n    /** @type {Node} */\n    doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  WFS.prototype.readProjectionFromNode = function readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n\n      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {\n          var objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return WFS;\n}(XMLFeature);\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\n\n\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\n\nvar OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\n\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n\n\nvar INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\n\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeFeature(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var featureType = context['featureType'];\n  var featureNS = context['featureNS'];\n  var gmlVersion = context['gmlVersion'];\n  var child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  var filter = createElementNS(OGCNS, 'Filter');\n  var child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid',\n  /** @type {string} */\n  fid);\n  node.appendChild(filter);\n}\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\n\n\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  var prefix = featurePrefix + ':'; // The featureType already contains the prefix.\n\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeDelete(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n\n  var featureType = context['featureType'];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  var fid = feature.getId();\n\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeUpdate(node, feature, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n\n  var featureType = context['featureType'];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var typeName = getTypeName(featurePrefix, featureType);\n  var geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  var fid = feature.getId();\n\n  if (fid !== undefined) {\n    var keys = feature.getKeys();\n    var values = [];\n\n    for (var i = 0, ii = keys.length; i < ii; i++) {\n      var value = feature.get(keys[i]);\n\n      if (value !== undefined) {\n        var name = keys[i];\n\n        if (value && typeof\n        /** @type {?} */\n        value.getSimplifiedGeometry === 'function') {\n          name = geometryName;\n        }\n\n        values.push({\n          name: name,\n          value: value\n        });\n      }\n    }\n\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    {\n      'gmlVersion': context['gmlVersion'],\n      node: node,\n      'hasZ': context['hasZ'],\n      'srsName': context['srsName']\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Property'), values, objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeProperty(node, pair, objectStack) {\n  var name = createElementNS(WFSNS, 'Name');\n  var context = objectStack[objectStack.length - 1];\n  var gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n\n  if (pair.value !== undefined && pair.value !== null) {\n    var value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n\n    if (pair.value && typeof\n    /** @type {?} */\n    pair.value.getSimplifiedGeometry === 'function') {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n\n\nvar GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\n\nfunction writeQuery(node, featureType, objectStack) {\n  var context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  var featurePrefix = context['featurePrefix'];\n  var featureNS = context['featureNS'];\n  var propertyNames = context['propertyNames'];\n  var srsName = context['srsName'];\n  var typeName; // If feature prefix is not defined, we must not use the default prefix.\n\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n\n  node.setAttribute('typeName', typeName);\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n\n  var item =\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory('PropertyName'), propertyNames, objectStack);\n  var filter = context['filter'];\n\n  if (filter) {\n    var child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeBboxFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Contains.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeContainsFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Intersects.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Within.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeWithinFilter(node, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeDuringFilter(node, filter, objectStack) {\n  var valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n  var timePeriod = createElementNS(GMLNS, 'TimePeriod');\n  node.appendChild(timePeriod);\n  var begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n  var end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  var conditions = filter.conditions;\n\n  for (var i = 0, ii = conditions.length; i < ii; ++i) {\n    var condition = conditions[i];\n    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n  }\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  var item = {\n    node: node\n  };\n  var condition = filter.condition;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n  var lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n  var upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\n\n\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\n\n\nfunction writeOgcExpression(tagName, node, value) {\n  var property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\n\n\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\n\n\nfunction writeTimeInstant(node, time) {\n  var timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n  var timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @return {Node} Result.\n * @api\n */\n\n\nexport function writeFilter(filter) {\n  var child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n/**\n * @param {Node} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\n\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  var context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  var item =\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory('Query'), featureTypes, objectStack);\n}\n\nexport default WFS;","map":{"version":3,"sources":["../../../src/ol/format/WFS.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/format/WFS\n */\nimport {assert} from '../asserts.js';\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {and as andFilter, bbox as bboxFilter} from './filter.js';\nimport XMLFeature from './XMLFeature.js';\nimport {readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode} from './xsd.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, isDocument, makeArrayPusher, makeChildAppender,\n  makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(\n      readInsertResults, 'insertIds')\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {import(\"../extent.js\").Extent} bounds\n */\n\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array<string>} insertIds\n */\n\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n\n/**\n * @type {string}\n */\nconst OGCNS = 'http://www.opengis.net/ogc';\n\n\n/**\n * @type {string}\n */\nconst WFSNS = 'http://www.opengis.net/wfs';\n\n\n/**\n * @type {string}\n */\nconst FESNS = 'http://www.opengis.net/fes';\n\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n\n  /**\n   * @param {Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ?\n      options.gmlFormat : new GML3();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation ?\n      options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    const objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS][\n      'featureMember'] =\n        makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    let features = pushParseAndPop([],\n      this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n      objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source));\n    } else {\n      return this.readTransactionResponseFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source));\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */({}),\n      TRANSACTION_RESPONSE_PARSERS, node, []);\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    let filter;\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', String(options.maxFeatures));\n      }\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', String(options.startIndex));\n      }\n      if (options.count !== undefined) {\n        node.setAttribute('count', String(options.count));\n      }\n      if (options.viewParams !== undefined) {\n        node.setAttribute('viewParams ', options.viewParams);\n      }\n      filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName,\n          12); // `options.geometryName` must also be provided when `options.bbox` is set\n        const bbox = bboxFilter(\n          /** @type {string} */ (options.geometryName), options.bbox, options.srsName);\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node\n    };\n    assign(context, {\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    });\n\n    assert(Array.isArray(options.featureTypes),\n      11); // `options.featureTypes` should be an Array\n    writeGetFeature(node, /** @type {!Array<string>} */ (options.featureTypes), [context]);\n    return node;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const node = createElementNS(WFSNS, 'Transaction');\n    const version = options.version ? options.version : DEFAULT_VERSION;\n    const gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    let obj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    const schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n    const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n    if (inserts) {\n      obj = assign({node: node}, {'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName});\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Insert'), inserts,\n        objectStack);\n    }\n    if (updates) {\n      obj = assign({node: node}, {'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName});\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Update'), updates,\n        objectStack);\n    }\n    if (deletes) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Delete'), deletes,\n      objectStack);\n    }\n    if (options.nativeElements) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Native'), options.nativeElements,\n      objectStack);\n    }\n    return node;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild &&\n        node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 &&\n            n.firstChild.nodeType === 3))) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop(\n    {}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function(node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop(\n    [], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (value && typeof /** @type {?} */ (value).getSimplifiedGeometry === 'function') {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */ (\n      {'gmlVersion': context['gmlVersion'], node: node,\n        'hasZ': context['hasZ'], 'srsName': context['srsName']}),\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Property'), values,\n    objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n    if (pair.value && typeof /** @type {?} */ (pair.value).getSimplifiedGeometry === 'function') {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  node.setAttribute('typeName', typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'), propertyNames,\n    objectStack);\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Contains.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Intersects.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Within.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition], objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const condition = filter.condition;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition], objectStack);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n\n\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'), featureTypes,\n    objectStack);\n}\n\n\nexport default WFS;\n"]},"metadata":{},"sourceType":"module"}