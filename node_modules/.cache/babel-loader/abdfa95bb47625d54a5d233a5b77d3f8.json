{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MapUtil = void 0;\n\nvar _Map = _interopRequireDefault(require(\"ol/Map\"));\n\nvar _TileWMS = _interopRequireDefault(require(\"ol/source/TileWMS\"));\n\nvar _ImageWMS = _interopRequireDefault(require(\"ol/source/ImageWMS\"));\n\nvar _Group = _interopRequireDefault(require(\"ol/layer/Group\"));\n\nvar _Base = _interopRequireDefault(require(\"ol/layer/Base\"));\n\nvar _GeometryCollection = _interopRequireDefault(require(\"ol/geom/GeometryCollection\"));\n\nvar _Units = require(\"ol/proj/Units\");\n\nvar _UrlUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/UrlUtil/UrlUtil\"));\n\nvar _Logger = _interopRequireDefault(require(\"@terrestris/base-util/dist/Logger\"));\n\nvar _FeatureUtil = _interopRequireDefault(require(\"../FeatureUtil/FeatureUtil\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Helper class for the OpenLayers map.\n *\n * @class\n */\n\n\nvar MapUtil =\n/*#__PURE__*/\nfunction () {\n  function MapUtil() {\n    _classCallCheck(this, MapUtil);\n  }\n\n  _createClass(MapUtil, null, [{\n    key: \"getInteractionsByName\",\n\n    /**\n     * Returns all interactions by the given name of a map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n    value: function getInteractionsByName(map, name) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction.get('name') === name) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Returns all interactions of the given class of the passed map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.interaction} clazz The class of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n\n  }, {\n    key: \"getInteractionsByClass\",\n    value: function getInteractionsByClass(map, clazz) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction instanceof clazz) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Calculates the appropriate map resolution for a given scale in the given\n     * units.\n     *\n     * See: https://gis.stackexchange.com/questions/158435/\n     * how-to-get-current-scale-in-openlayers-3\n     *\n     * @method\n     * @param {number} scale The input scale to calculate the appropriate\n     *                       resolution for.\n     * @param {string} units The units to use for calculation (m or degrees).\n     * @return {number} The calculated resolution.\n     */\n\n  }, {\n    key: \"getResolutionForScale\",\n    value: function getResolutionForScale(scale, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);\n    }\n    /**\n     * Returns the appropriate scale for the given resolution and units.\n     *\n     * @method\n     * @param {number} resolution The resolutions to calculate the scale for.\n     * @param {string} units The units the resolution is based on, typically\n     *                       either 'm' or 'degrees'.\n     * @return {number} The appropriate scale.\n     */\n\n  }, {\n    key: \"getScaleForResolution\",\n    value: function getScaleForResolution(resolution, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;\n    }\n    /**\n     * Returns all layers of a collection. Even the hidden ones.\n     *\n     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers\n     *                                           from. This can be an ol.layer.Group\n     *                                           or an ol.Map.\n     * @param {Function} [filter] A filter function that receives the layer.\n     *                            If it returns true it will be included in the\n     *                            returned layers.\n     * @return {Array} An array of all Layers.\n     */\n\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers(collection) {\n      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      if (!(collection instanceof _Map[\"default\"]) && !(collection instanceof _Group[\"default\"])) {\n        _Logger[\"default\"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');\n\n        return [];\n      }\n\n      var layers = collection.getLayers().getArray();\n      var allLayers = [];\n      layers.forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          MapUtil.getAllLayers(layer).forEach(function (layeri) {\n            if (filter(layeri)) {\n              allLayers.push(layeri);\n            }\n          });\n        }\n\n        if (filter(layer)) {\n          allLayers.push(layer);\n        }\n      });\n      return allLayers;\n    }\n    /**\n     * Get a layer by its key (ol_uid).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} ol_uid The ol_uid of a layer.\n     * @return {ol.layer.Layer} The layer.\n     */\n\n  }, {\n    key: \"getLayerByName\",\n\n    /**\n     * Returns the layer from the provided map by the given name.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n    value: function getLayerByName(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      return layers.filter(function (layer) {\n        return layer.get('name') === name;\n      })[0];\n    }\n    /**\n     * Returns the layer from the provided map by the given name\n     * (parameter LAYERS).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByNameParam\",\n    value: function getLayerByNameParam(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      var layerCandidate;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n\n          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns the layer from the provided map by the given feature.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Feature} feature The feature to get the layer by.\n     * @param {Array} namespaces list of supported GeoServer namespaces.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByFeature\",\n    value: function getLayerByFeature(map, feature, namespaces) {\n      var featureTypeName = _FeatureUtil[\"default\"].getFeatureTypeName(feature);\n\n      var layerCandidate;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = namespaces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var namespace = _step2.value;\n          var qualifiedFeatureTypeName = \"\".concat(namespace, \":\").concat(featureTypeName);\n          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);\n\n          if (layer) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns all layers of the specified layer group recursively.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Layer.Group} layerGroup The group to flatten.\n     * @return {Array} The (flattened) layers from the group\n     */\n\n  }, {\n    key: \"getLayersByGroup\",\n    value: function getLayersByGroup(map, layerGroup) {\n      var layerCandidates = [];\n      layerGroup.getLayers().forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          layerCandidates.push.apply(layerCandidates, _toConsumableArray(MapUtil.getLayersByGroup(map, layer)));\n        } else {\n          layerCandidates.push(layer);\n        }\n      });\n      return layerCandidates;\n    }\n    /**\n     * Returns the list of layers matching the given pair of properties.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} key The property key.\n     * @param {Object} value The property value.\n     *\n     * @return {ol.layer.Base[]} The array of matching layers.\n     */\n\n  }, {\n    key: \"getLayersByProperty\",\n    value: function getLayersByProperty(map, key, value) {\n      if (!map || !key) {\n        return;\n      }\n\n      var mapLayers = MapUtil.getAllLayers(map);\n      return mapLayers.filter(function (l) {\n        return l.get(key) === value;\n      });\n    }\n    /**\n     * Get information about the LayerPosition in the tree.\n     *\n     * @param {ol.layer.Layer} layer The layer to get the information.\n     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map\n     *                                                  containing the layer.\n     * @return {Object} An object with these keys:\n     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.\n     *    {Integer} position The position of the layer in the collection.\n     */\n\n  }, {\n    key: \"getLayerPositionInfo\",\n    value: function getLayerPositionInfo(layer, groupLayerOrMap) {\n      var groupLayer = groupLayerOrMap instanceof _Group[\"default\"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();\n      var layers = groupLayer.getLayers().getArray();\n      var info = {};\n\n      if (layers.indexOf(layer) < 0) {\n        layers.forEach(function (childLayer) {\n          if (childLayer instanceof _Group[\"default\"] && !info.groupLayer) {\n            info = MapUtil.getLayerPositionInfo(layer, childLayer);\n          }\n        });\n      } else {\n        info.position = layers.indexOf(layer);\n        info.groupLayer = groupLayer;\n      }\n\n      return info;\n    }\n    /**\n     * Get the getlegendGraphic url of a layer. Designed for geoserver.\n     * Currently supported Sources:\n     *  - ol.source.TileWms (with url configured)\n     *  - ol.source.ImageWms (with url configured)\n     *\n     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.\n     * @return {string|undefined} The getLegendGraphicUrl.\n     */\n\n  }, {\n    key: \"getLegendGraphicUrl\",\n    value: function getLegendGraphicUrl(layer, extraParams) {\n      if (!layer) {\n        _Logger[\"default\"].error('No layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var source = layer.getSource();\n\n      if (!(layer instanceof _Base[\"default\"]) || !source) {\n        _Logger[\"default\"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var isTiledWMS = source instanceof _TileWMS[\"default\"];\n      var isImageWMS = source instanceof _ImageWMS[\"default\"];\n\n      if (isTiledWMS || isImageWMS) {\n        var _source = layer.getSource();\n\n        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();\n        var params = {\n          LAYER: _source.getParams().LAYERS,\n          VERSION: '1.3.0',\n          SERVICE: 'WMS',\n          REQUEST: 'getLegendGraphic',\n          FORMAT: 'image/png'\n        };\n\n        var queryString = _UrlUtil[\"default\"].objectToRequestString(Object.assign(params, extraParams));\n\n        return /\\?/.test(url) ? \"\".concat(url, \"&\").concat(queryString) : \"\".concat(url, \"?\").concat(queryString);\n      } else {\n        _Logger[\"default\"].warn(\"Source of \\\"\".concat(layer.get('name'), \"\\\" is currently not supported \") + \"by MapUtil.getLegendGraphicUrl.\");\n\n        return;\n      }\n    }\n    /**\n     * Checks whether the resolution of the passed map's view lies inside of the\n     * min- and max-resolution of the passed layer, e.g. whether the layer should\n     * be displayed at the current map view resolution.\n     *\n     * @param {ol.layer.Layer} layer The layer to check.\n     * @param {ol.Map} map The map to get the view resolution for comparison\n     *     from.\n     * @return {boolean} Whether the resolution of the passed map's view lies\n     *     inside of the min- and max-resolution of the passed layer, e.g. whether\n     *     the layer should be displayed at the current map view resolution. Will\n     *     be `false` when no `layer` or no `map` is passed or if the view of the\n     *     map is falsy or does not have a resolution (yet).\n     */\n\n  }, {\n    key: \"layerInResolutionRange\",\n    value: function layerInResolutionRange(layer, map) {\n      var mapView = map && map.getView();\n      var currentRes = mapView && mapView.getResolution();\n\n      if (!layer || !mapView || !currentRes) {\n        // It is questionable what we should return in this case, I opted for\n        // false, since we cannot sanely determine a correct answer.\n        return false;\n      }\n\n      var layerMinRes = layer.getMinResolution(); // default: 0 if unset\n\n      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset\n      // minimum resolution is inclusive, maximum resolution exclusive\n\n      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;\n      return within;\n    }\n    /**\n     * Rounds a scalenumber in dependency to its size.\n     *\n     * @param  {number} scale The exact scale\n     * @return {number} The roundedScale\n     */\n\n  }, {\n    key: \"roundScale\",\n    value: function roundScale(scale) {\n      var roundScale;\n\n      if (scale < 100) {\n        roundScale = Math.round(scale, 10);\n      }\n\n      if (scale >= 100 && scale < 10000) {\n        roundScale = Math.round(scale / 10) * 10;\n      }\n\n      if (scale >= 10000 && scale < 1000000) {\n        roundScale = Math.round(scale / 100) * 100;\n      }\n\n      if (scale >= 1000000) {\n        roundScale = Math.round(scale / 1000) * 1000;\n      }\n\n      return roundScale;\n    }\n    /**\n     * Returns the appropriate zoom level for the given scale and units.\n      * @method\n     * @param {number} scale Map scale to get the zoom for.\n     * @param {Array} resolutions Resolutions array.\n     * @param {string} units The units the resolutions are based on, typically\n     *                       either 'm' or 'degrees'. Default is 'm'.\n     *\n     * @return {number} Determined zoom level for the given scale.\n     */\n\n  }, {\n    key: \"getZoomForScale\",\n    value: function getZoomForScale(scale, resolutions) {\n      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';\n\n      if (Number.isNaN(Number(scale))) {\n        return 0;\n      }\n\n      if (scale < 0) {\n        return 0;\n      }\n\n      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);\n      var closestVal = resolutions.reduce(function (prev, curr) {\n        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;\n        return res;\n      });\n      var zoom = (0, _findIndex[\"default\"])(resolutions, function (o) {\n        return Math.abs(o - closestVal) <= 1e-10;\n      });\n      return zoom;\n    }\n    /**\n     * Fits the map's view to the extent of the passed features.\n     *\n     * @param {ol.Map} map The map to get the view from.\n     * @param {ol.Feature[]} features The features to zoom to.\n     */\n\n  }, {\n    key: \"zoomToFeatures\",\n    value: function zoomToFeatures(map, features) {\n      if (!(map instanceof _Map[\"default\"])) {\n        return;\n      }\n\n      var featGeometries = [];\n      features.forEach(function (feature) {\n        if (feature.getGeometry() !== null) {\n          featGeometries.push(feature.getGeometry());\n        }\n      });\n\n      if (featGeometries.length > 0) {\n        var geomCollection = new _GeometryCollection[\"default\"](featGeometries);\n        map.getView().fit(geomCollection.getExtent());\n      }\n    }\n    /**\n     * Checks if the given layer is visible for the given resolution.\n     *\n     * @param {ol.layer.Base} layer The layer.\n     * @param {number} resolution The resolution of the map\n     */\n\n  }, {\n    key: \"isInScaleRange\",\n    value: function isInScaleRange(layer, resolution) {\n      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');\n    }\n  }]);\n\n  return MapUtil;\n}();\n\nexports.MapUtil = MapUtil;\n\n_defineProperty(MapUtil, \"getLayerByOlUid\", function (map, ol_uid) {\n  var layers = MapUtil.getAllLayers(map);\n  var layer = layers.find(function (l) {\n    return ol_uid === l.ol_uid.toString();\n  });\n  return layer;\n});\n\nvar _default = MapUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/@terrestris/react-geo/node_modules/@terrestris/ol-util/dist/MapUtil/MapUtil.js"],"names":["Object","defineProperty","exports","value","MapUtil","_Map","_interopRequireDefault","require","_TileWMS","_ImageWMS","_Group","_Base","_GeometryCollection","_Units","_UrlUtil","_Logger","_FeatureUtil","_findIndex","obj","__esModule","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","_defineProperty","getInteractionsByName","map","name","interactionCandidates","debug","interactions","getInteractions","forEach","interaction","get","push","getInteractionsByClass","clazz","getResolutionForScale","scale","units","dpi","mpu","METERS_PER_UNIT","inchesPerMeter","parseFloat","getScaleForResolution","resolution","getAllLayers","collection","filter","arguments","undefined","error","layers","getLayers","getArray","allLayers","layer","layeri","getLayerByName","getLayerByNameParam","layerCandidate","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","getSource","getParams","err","getLayerByFeature","feature","namespaces","featureTypeName","getFeatureTypeName","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","namespace","qualifiedFeatureTypeName","concat","getLayersByGroup","layerGroup","layerCandidates","apply","getLayersByProperty","mapLayers","l","getLayerPositionInfo","groupLayerOrMap","groupLayer","getLayerGroup","info","indexOf","childLayer","position","getLegendGraphicUrl","extraParams","source","isTiledWMS","isImageWMS","_source","url","getUrls","getUrl","params","LAYER","LAYERS","VERSION","SERVICE","REQUEST","FORMAT","queryString","objectToRequestString","assign","test","warn","layerInResolutionRange","mapView","getView","currentRes","getResolution","layerMinRes","getMinResolution","layerMaxRes","getMaxResolution","within","roundScale","Math","round","getZoomForScale","resolutions","Number","isNaN","calculatedResolution","closestVal","reduce","prev","curr","res","abs","zoom","o","zoomToFeatures","features","featGeometries","getGeometry","geomCollection","fit","getExtent","isInScaleRange","ol_uid","find","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MapUtil = void 0;\n\nvar _Map = _interopRequireDefault(require(\"ol/Map\"));\n\nvar _TileWMS = _interopRequireDefault(require(\"ol/source/TileWMS\"));\n\nvar _ImageWMS = _interopRequireDefault(require(\"ol/source/ImageWMS\"));\n\nvar _Group = _interopRequireDefault(require(\"ol/layer/Group\"));\n\nvar _Base = _interopRequireDefault(require(\"ol/layer/Base\"));\n\nvar _GeometryCollection = _interopRequireDefault(require(\"ol/geom/GeometryCollection\"));\n\nvar _Units = require(\"ol/proj/Units\");\n\nvar _UrlUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/UrlUtil/UrlUtil\"));\n\nvar _Logger = _interopRequireDefault(require(\"@terrestris/base-util/dist/Logger\"));\n\nvar _FeatureUtil = _interopRequireDefault(require(\"../FeatureUtil/FeatureUtil\"));\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Helper class for the OpenLayers map.\n *\n * @class\n */\nvar MapUtil =\n/*#__PURE__*/\nfunction () {\n  function MapUtil() {\n    _classCallCheck(this, MapUtil);\n  }\n\n  _createClass(MapUtil, null, [{\n    key: \"getInteractionsByName\",\n\n    /**\n     * Returns all interactions by the given name of a map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n    value: function getInteractionsByName(map, name) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction.get('name') === name) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Returns all interactions of the given class of the passed map.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.interaction} clazz The class of the interaction to look for.\n     * @return {ol.interaction[]} The list of result interactions.\n     */\n\n  }, {\n    key: \"getInteractionsByClass\",\n    value: function getInteractionsByClass(map, clazz) {\n      var interactionCandidates = [];\n\n      if (!(map instanceof _Map[\"default\"])) {\n        _Logger[\"default\"].debug('Input parameter map must be from type `ol.Map`.');\n\n        return interactionCandidates;\n      }\n\n      var interactions = map.getInteractions();\n      interactions.forEach(function (interaction) {\n        if (interaction instanceof clazz) {\n          interactionCandidates.push(interaction);\n        }\n      });\n      return interactionCandidates;\n    }\n    /**\n     * Calculates the appropriate map resolution for a given scale in the given\n     * units.\n     *\n     * See: https://gis.stackexchange.com/questions/158435/\n     * how-to-get-current-scale-in-openlayers-3\n     *\n     * @method\n     * @param {number} scale The input scale to calculate the appropriate\n     *                       resolution for.\n     * @param {string} units The units to use for calculation (m or degrees).\n     * @return {number} The calculated resolution.\n     */\n\n  }, {\n    key: \"getResolutionForScale\",\n    value: function getResolutionForScale(scale, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(scale) / (mpu * inchesPerMeter * dpi);\n    }\n    /**\n     * Returns the appropriate scale for the given resolution and units.\n     *\n     * @method\n     * @param {number} resolution The resolutions to calculate the scale for.\n     * @param {string} units The units the resolution is based on, typically\n     *                       either 'm' or 'degrees'.\n     * @return {number} The appropriate scale.\n     */\n\n  }, {\n    key: \"getScaleForResolution\",\n    value: function getScaleForResolution(resolution, units) {\n      var dpi = 25.4 / 0.28;\n      var mpu = _Units.METERS_PER_UNIT[units];\n      var inchesPerMeter = 39.37;\n      return parseFloat(resolution) * mpu * inchesPerMeter * dpi;\n    }\n    /**\n     * Returns all layers of a collection. Even the hidden ones.\n     *\n     * @param {ol.Map|ol.layer.Group} collection The collection to get the layers\n     *                                           from. This can be an ol.layer.Group\n     *                                           or an ol.Map.\n     * @param {Function} [filter] A filter function that receives the layer.\n     *                            If it returns true it will be included in the\n     *                            returned layers.\n     * @return {Array} An array of all Layers.\n     */\n\n  }, {\n    key: \"getAllLayers\",\n    value: function getAllLayers(collection) {\n      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      if (!(collection instanceof _Map[\"default\"]) && !(collection instanceof _Group[\"default\"])) {\n        _Logger[\"default\"].error('Input parameter collection must be from type `ol.Map`' + 'or `ol.layer.Group`.');\n\n        return [];\n      }\n\n      var layers = collection.getLayers().getArray();\n      var allLayers = [];\n      layers.forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          MapUtil.getAllLayers(layer).forEach(function (layeri) {\n            if (filter(layeri)) {\n              allLayers.push(layeri);\n            }\n          });\n        }\n\n        if (filter(layer)) {\n          allLayers.push(layer);\n        }\n      });\n      return allLayers;\n    }\n    /**\n     * Get a layer by its key (ol_uid).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} ol_uid The ol_uid of a layer.\n     * @return {ol.layer.Layer} The layer.\n     */\n\n  }, {\n    key: \"getLayerByName\",\n\n    /**\n     * Returns the layer from the provided map by the given name.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n    value: function getLayerByName(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      return layers.filter(function (layer) {\n        return layer.get('name') === name;\n      })[0];\n    }\n    /**\n     * Returns the layer from the provided map by the given name\n     * (parameter LAYERS).\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} name The name to get the layer by.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByNameParam\",\n    value: function getLayerByNameParam(map, name) {\n      var layers = MapUtil.getAllLayers(map);\n      var layerCandidate;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n\n          if (layer.getSource && layer.getSource().getParams && layer.getSource().getParams()['LAYERS'] === name) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns the layer from the provided map by the given feature.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Feature} feature The feature to get the layer by.\n     * @param {Array} namespaces list of supported GeoServer namespaces.\n     * @return {ol.Layer} The result layer or undefined if the layer could not\n     *                    be found.\n     */\n\n  }, {\n    key: \"getLayerByFeature\",\n    value: function getLayerByFeature(map, feature, namespaces) {\n      var featureTypeName = _FeatureUtil[\"default\"].getFeatureTypeName(feature);\n\n      var layerCandidate;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = namespaces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var namespace = _step2.value;\n          var qualifiedFeatureTypeName = \"\".concat(namespace, \":\").concat(featureTypeName);\n          var layer = MapUtil.getLayerByNameParam(map, qualifiedFeatureTypeName);\n\n          if (layer) {\n            layerCandidate = layer;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return layerCandidate;\n    }\n    /**\n     * Returns all layers of the specified layer group recursively.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {ol.Layer.Group} layerGroup The group to flatten.\n     * @return {Array} The (flattened) layers from the group\n     */\n\n  }, {\n    key: \"getLayersByGroup\",\n    value: function getLayersByGroup(map, layerGroup) {\n      var layerCandidates = [];\n      layerGroup.getLayers().forEach(function (layer) {\n        if (layer instanceof _Group[\"default\"]) {\n          layerCandidates.push.apply(layerCandidates, _toConsumableArray(MapUtil.getLayersByGroup(map, layer)));\n        } else {\n          layerCandidates.push(layer);\n        }\n      });\n      return layerCandidates;\n    }\n    /**\n     * Returns the list of layers matching the given pair of properties.\n     *\n     * @param {ol.Map} map The map to use for lookup.\n     * @param {string} key The property key.\n     * @param {Object} value The property value.\n     *\n     * @return {ol.layer.Base[]} The array of matching layers.\n     */\n\n  }, {\n    key: \"getLayersByProperty\",\n    value: function getLayersByProperty(map, key, value) {\n      if (!map || !key) {\n        return;\n      }\n\n      var mapLayers = MapUtil.getAllLayers(map);\n      return mapLayers.filter(function (l) {\n        return l.get(key) === value;\n      });\n    }\n    /**\n     * Get information about the LayerPosition in the tree.\n     *\n     * @param {ol.layer.Layer} layer The layer to get the information.\n     * @param {ol.layer.Group|ol.Map} [groupLayerOrMap] The groupLayer or map\n     *                                                  containing the layer.\n     * @return {Object} An object with these keys:\n     *    {ol.layer.Group} groupLayer The groupLayer containing the layer.\n     *    {Integer} position The position of the layer in the collection.\n     */\n\n  }, {\n    key: \"getLayerPositionInfo\",\n    value: function getLayerPositionInfo(layer, groupLayerOrMap) {\n      var groupLayer = groupLayerOrMap instanceof _Group[\"default\"] ? groupLayerOrMap : groupLayerOrMap.getLayerGroup();\n      var layers = groupLayer.getLayers().getArray();\n      var info = {};\n\n      if (layers.indexOf(layer) < 0) {\n        layers.forEach(function (childLayer) {\n          if (childLayer instanceof _Group[\"default\"] && !info.groupLayer) {\n            info = MapUtil.getLayerPositionInfo(layer, childLayer);\n          }\n        });\n      } else {\n        info.position = layers.indexOf(layer);\n        info.groupLayer = groupLayer;\n      }\n\n      return info;\n    }\n    /**\n     * Get the getlegendGraphic url of a layer. Designed for geoserver.\n     * Currently supported Sources:\n     *  - ol.source.TileWms (with url configured)\n     *  - ol.source.ImageWms (with url configured)\n     *\n     * @param {ol.layer.Layer} layer The layer that you want to have a legendUrlfor.\n     * @return {string|undefined} The getLegendGraphicUrl.\n     */\n\n  }, {\n    key: \"getLegendGraphicUrl\",\n    value: function getLegendGraphicUrl(layer, extraParams) {\n      if (!layer) {\n        _Logger[\"default\"].error('No layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var source = layer.getSource();\n\n      if (!(layer instanceof _Base[\"default\"]) || !source) {\n        _Logger[\"default\"].error('Invalid layer passed to MapUtil.getLegendGraphicUrl.');\n\n        return;\n      }\n\n      var isTiledWMS = source instanceof _TileWMS[\"default\"];\n      var isImageWMS = source instanceof _ImageWMS[\"default\"];\n\n      if (isTiledWMS || isImageWMS) {\n        var _source = layer.getSource();\n\n        var url = isTiledWMS ? _source.getUrls() ? _source.getUrls()[0] : '' : _source.getUrl();\n        var params = {\n          LAYER: _source.getParams().LAYERS,\n          VERSION: '1.3.0',\n          SERVICE: 'WMS',\n          REQUEST: 'getLegendGraphic',\n          FORMAT: 'image/png'\n        };\n\n        var queryString = _UrlUtil[\"default\"].objectToRequestString(Object.assign(params, extraParams));\n\n        return /\\?/.test(url) ? \"\".concat(url, \"&\").concat(queryString) : \"\".concat(url, \"?\").concat(queryString);\n      } else {\n        _Logger[\"default\"].warn(\"Source of \\\"\".concat(layer.get('name'), \"\\\" is currently not supported \") + \"by MapUtil.getLegendGraphicUrl.\");\n\n        return;\n      }\n    }\n    /**\n     * Checks whether the resolution of the passed map's view lies inside of the\n     * min- and max-resolution of the passed layer, e.g. whether the layer should\n     * be displayed at the current map view resolution.\n     *\n     * @param {ol.layer.Layer} layer The layer to check.\n     * @param {ol.Map} map The map to get the view resolution for comparison\n     *     from.\n     * @return {boolean} Whether the resolution of the passed map's view lies\n     *     inside of the min- and max-resolution of the passed layer, e.g. whether\n     *     the layer should be displayed at the current map view resolution. Will\n     *     be `false` when no `layer` or no `map` is passed or if the view of the\n     *     map is falsy or does not have a resolution (yet).\n     */\n\n  }, {\n    key: \"layerInResolutionRange\",\n    value: function layerInResolutionRange(layer, map) {\n      var mapView = map && map.getView();\n      var currentRes = mapView && mapView.getResolution();\n\n      if (!layer || !mapView || !currentRes) {\n        // It is questionable what we should return in this case, I opted for\n        // false, since we cannot sanely determine a correct answer.\n        return false;\n      }\n\n      var layerMinRes = layer.getMinResolution(); // default: 0 if unset\n\n      var layerMaxRes = layer.getMaxResolution(); // default: Infinity if unset\n      // minimum resolution is inclusive, maximum resolution exclusive\n\n      var within = currentRes >= layerMinRes && currentRes < layerMaxRes;\n      return within;\n    }\n    /**\n     * Rounds a scalenumber in dependency to its size.\n     *\n     * @param  {number} scale The exact scale\n     * @return {number} The roundedScale\n     */\n\n  }, {\n    key: \"roundScale\",\n    value: function roundScale(scale) {\n      var roundScale;\n\n      if (scale < 100) {\n        roundScale = Math.round(scale, 10);\n      }\n\n      if (scale >= 100 && scale < 10000) {\n        roundScale = Math.round(scale / 10) * 10;\n      }\n\n      if (scale >= 10000 && scale < 1000000) {\n        roundScale = Math.round(scale / 100) * 100;\n      }\n\n      if (scale >= 1000000) {\n        roundScale = Math.round(scale / 1000) * 1000;\n      }\n\n      return roundScale;\n    }\n    /**\n     * Returns the appropriate zoom level for the given scale and units.\n      * @method\n     * @param {number} scale Map scale to get the zoom for.\n     * @param {Array} resolutions Resolutions array.\n     * @param {string} units The units the resolutions are based on, typically\n     *                       either 'm' or 'degrees'. Default is 'm'.\n     *\n     * @return {number} Determined zoom level for the given scale.\n     */\n\n  }, {\n    key: \"getZoomForScale\",\n    value: function getZoomForScale(scale, resolutions) {\n      var units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm';\n\n      if (Number.isNaN(Number(scale))) {\n        return 0;\n      }\n\n      if (scale < 0) {\n        return 0;\n      }\n\n      var calculatedResolution = MapUtil.getResolutionForScale(scale, units);\n      var closestVal = resolutions.reduce(function (prev, curr) {\n        var res = Math.abs(curr - calculatedResolution) < Math.abs(prev - calculatedResolution) ? curr : prev;\n        return res;\n      });\n      var zoom = (0, _findIndex[\"default\"])(resolutions, function (o) {\n        return Math.abs(o - closestVal) <= 1e-10;\n      });\n      return zoom;\n    }\n    /**\n     * Fits the map's view to the extent of the passed features.\n     *\n     * @param {ol.Map} map The map to get the view from.\n     * @param {ol.Feature[]} features The features to zoom to.\n     */\n\n  }, {\n    key: \"zoomToFeatures\",\n    value: function zoomToFeatures(map, features) {\n      if (!(map instanceof _Map[\"default\"])) {\n        return;\n      }\n\n      var featGeometries = [];\n      features.forEach(function (feature) {\n        if (feature.getGeometry() !== null) {\n          featGeometries.push(feature.getGeometry());\n        }\n      });\n\n      if (featGeometries.length > 0) {\n        var geomCollection = new _GeometryCollection[\"default\"](featGeometries);\n        map.getView().fit(geomCollection.getExtent());\n      }\n    }\n    /**\n     * Checks if the given layer is visible for the given resolution.\n     *\n     * @param {ol.layer.Base} layer The layer.\n     * @param {number} resolution The resolution of the map\n     */\n\n  }, {\n    key: \"isInScaleRange\",\n    value: function isInScaleRange(layer, resolution) {\n      return resolution >= layer.get('minResolution') && resolution < layer.get('maxResolution');\n    }\n  }]);\n\n  return MapUtil;\n}();\n\nexports.MapUtil = MapUtil;\n\n_defineProperty(MapUtil, \"getLayerByOlUid\", function (map, ol_uid) {\n  var layers = MapUtil.getAllLayers(map);\n  var layer = layers.find(function (l) {\n    return ol_uid === l.ol_uid.toString();\n  });\n  return layer;\n});\n\nvar _default = MapUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}