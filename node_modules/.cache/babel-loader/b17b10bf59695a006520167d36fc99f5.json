{"ast":null,"code":"/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport { inherits } from '../util.js';\nimport { extend } from '../array.js';\nimport Feature from '../Feature.js';\nimport { transformWithOptions } from '../format/Feature.js';\nimport XMLFeature from '../format/XMLFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\n/**\n * @const\n * @type {string}\n */\n\nexport const GMLNS = 'http://www.opengis.net/gml';\n/**\n * @typedef {Object} Options\n * @property {Object.<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array.<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} srsName srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @constructor\n * @abstract\n * @param {module:ol/format/GMLBase~Options=} opt_options\n *     Optional configuration object.\n * @extends {module:ol/format/XMLFeature}\n */\n\nconst GMLBase = function (opt_options) {\n  const options =\n  /** @type {module:ol/format/GMLBase~Options} */\n  opt_options ? opt_options : {};\n  /**\n   * @protected\n   * @type {Array.<string>|string|undefined}\n   */\n\n  this.featureType = options.featureType;\n  /**\n   * @protected\n   * @type {Object.<string, string>|string|undefined}\n   */\n\n  this.featureNS = options.featureNS;\n  /**\n   * @protected\n   * @type {string}\n   */\n\n  this.srsName = options.srsName;\n  /**\n   * @protected\n   * @type {string}\n   */\n\n  this.schemaLocation = '';\n  /**\n   * @type {Object.<string, Object.<string, Object>>}\n   */\n\n  this.FEATURE_COLLECTION_PARSERS = {};\n  this.FEATURE_COLLECTION_PARSERS[GMLNS] = {\n    'featureMember': makeReplacer(GMLBase.prototype.readFeaturesInternal),\n    'featureMembers': makeReplacer(GMLBase.prototype.readFeaturesInternal)\n  };\n  XMLFeature.call(this);\n};\n\ninherits(GMLBase, XMLFeature);\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc. The non-breaking\n * space (0xa0) is explicitly included as IE doesn't include it in its\n * definition of `\\s`.\n *\n * Information from `goog.string.isEmptyOrWhitespace`: https://github.com/google/closure-library/blob/e877b1e/closure/goog/string/string.js#L156-L160\n *\n * @const\n * @type {RegExp}\n */\n\nconst ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Array.<module:ol/Feature> | undefined} Features.\n */\n\nGMLBase.prototype.readFeaturesInternal = function (node, objectStack) {\n  const localName = node.localName;\n  let features = null;\n\n  if (localName == 'FeatureCollection') {\n    if (node.namespaceURI === 'http://www.opengis.net/wfs') {\n      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n    } else {\n      features = pushParseAndPop(null, this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n    }\n  } else if (localName == 'featureMembers' || localName == 'featureMember') {\n    const context = objectStack[0];\n    let featureType = context['featureType'];\n    let featureNS = context['featureNS'];\n    const prefix = 'p';\n    const defaultPrefix = 'p0';\n\n    if (!featureType && node.childNodes) {\n      featureType = [], featureNS = {};\n\n      for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n        const child = node.childNodes[i];\n\n        if (child.nodeType === 1) {\n          const ft = child.nodeName.split(':').pop();\n\n          if (featureType.indexOf(ft) === -1) {\n            let key = '';\n            let count = 0;\n            const uri = child.namespaceURI;\n\n            for (const candidate in featureNS) {\n              if (featureNS[candidate] === uri) {\n                key = candidate;\n                break;\n              }\n\n              ++count;\n            }\n\n            if (!key) {\n              key = prefix + count;\n              featureNS[key] = uri;\n            }\n\n            featureType.push(key + ':' + ft);\n          }\n        }\n      }\n\n      if (localName != 'featureMember') {\n        // recheck featureType for each featureMember\n        context['featureType'] = featureType;\n        context['featureNS'] = featureNS;\n      }\n    }\n\n    if (typeof featureNS === 'string') {\n      const ns = featureNS;\n      featureNS = {};\n      featureNS[defaultPrefix] = ns;\n    }\n\n    const parsersNS = {};\n    const featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n\n    for (const p in featureNS) {\n      const parsers = {};\n\n      for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n        const featurePrefix = featureTypes[i].indexOf(':') === -1 ? defaultPrefix : featureTypes[i].split(':')[0];\n\n        if (featurePrefix === p) {\n          parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n        }\n      }\n\n      parsersNS[featureNS[p]] = parsers;\n    }\n\n    if (localName == 'featureMember') {\n      features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n    } else {\n      features = pushParseAndPop([], parsersNS, node, objectStack);\n    }\n  }\n\n  if (features === null) {\n    features = [];\n  }\n\n  return features;\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/Geometry|undefined} Geometry.\n */\n\n\nGMLBase.prototype.readGeometryElement = function (node, objectStack) {\n  const context =\n  /** @type {Object} */\n  objectStack[0];\n  context['srsName'] = node.firstElementChild.getAttribute('srsName');\n  context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n  /** @type {module:ol/geom/Geometry} */\n\n  const geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS_, node, objectStack, this);\n\n  if (geometry) {\n    return (\n      /** @type {module:ol/geom/Geometry} */\n      transformWithOptions(geometry, false, context)\n    );\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/Feature} Feature.\n */\n\n\nGMLBase.prototype.readFeatureElement = function (node, objectStack) {\n  let n;\n  const fid = node.getAttribute('fid') || getAttributeNS(node, GMLNS, 'id');\n  const values = {};\n  let geometryName;\n\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const localName = n.localName; // Assume attribute elements have one child node and that the child\n    // is a text or CDATA node (to be treated as text).\n    // Otherwise assume it is a geometry node.\n\n    if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {\n      let value = getAllTextContent(n, false);\n\n      if (ONLY_WHITESPACE_RE.test(value)) {\n        value = undefined;\n      }\n\n      values[localName] = value;\n    } else {\n      // boundedBy is an extent and must not be considered as a geometry\n      if (localName !== 'boundedBy') {\n        geometryName = localName;\n      }\n\n      values[localName] = this.readGeometryElement(n, objectStack);\n    }\n  }\n\n  const feature = new Feature(values);\n\n  if (geometryName) {\n    feature.setGeometryName(geometryName);\n  }\n\n  if (fid) {\n    feature.setId(fid);\n  }\n\n  return feature;\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/Point|undefined} Point.\n */\n\n\nGMLBase.prototype.readPoint = function (node, objectStack) {\n  const flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n  if (flatCoordinates) {\n    const point = new Point(null);\n    point.setFlatCoordinates(GeometryLayout.XYZ, flatCoordinates);\n    return point;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/MultiPoint|undefined} MultiPoint.\n */\n\n\nGMLBase.prototype.readMultiPoint = function (node, objectStack) {\n  /** @type {Array.<Array.<number>>} */\n  const coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS_, node, objectStack, this);\n\n  if (coordinates) {\n    return new MultiPoint(coordinates);\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/MultiLineString|undefined} MultiLineString.\n */\n\n\nGMLBase.prototype.readMultiLineString = function (node, objectStack) {\n  /** @type {Array.<module:ol/geom/LineString>} */\n  const lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS_, node, objectStack, this);\n\n  if (lineStrings) {\n    const multiLineString = new MultiLineString(null);\n    multiLineString.setLineStrings(lineStrings);\n    return multiLineString;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/MultiPolygon|undefined} MultiPolygon.\n */\n\n\nGMLBase.prototype.readMultiPolygon = function (node, objectStack) {\n  /** @type {Array.<module:ol/geom/Polygon>} */\n  const polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, node, objectStack, this);\n\n  if (polygons) {\n    const multiPolygon = new MultiPolygon(null);\n    multiPolygon.setPolygons(polygons);\n    return multiPolygon;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\n\n\nGMLBase.prototype.pointMemberParser_ = function (node, objectStack) {\n  parseNode(this.POINTMEMBER_PARSERS_, node, objectStack, this);\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\n\n\nGMLBase.prototype.lineStringMemberParser_ = function (node, objectStack) {\n  parseNode(this.LINESTRINGMEMBER_PARSERS_, node, objectStack, this);\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\n\n\nGMLBase.prototype.polygonMemberParser_ = function (node, objectStack) {\n  parseNode(this.POLYGONMEMBER_PARSERS_, node, objectStack, this);\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/LineString|undefined} LineString.\n */\n\n\nGMLBase.prototype.readLineString = function (node, objectStack) {\n  const flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n  if (flatCoordinates) {\n    const lineString = new LineString(null);\n    lineString.setFlatCoordinates(GeometryLayout.XYZ, flatCoordinates);\n    return lineString;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} LinearRing flat coordinates.\n */\n\n\nGMLBase.prototype.readFlatLinearRing_ = function (node, objectStack) {\n  const ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);\n\n  if (ring) {\n    return ring;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/LinearRing|undefined} LinearRing.\n */\n\n\nGMLBase.prototype.readLinearRing = function (node, objectStack) {\n  const flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);\n\n  if (flatCoordinates) {\n    const ring = new LinearRing(null);\n    ring.setFlatCoordinates(GeometryLayout.XYZ, flatCoordinates);\n    return ring;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {module:ol/geom/Polygon|undefined} Polygon.\n */\n\n\nGMLBase.prototype.readPolygon = function (node, objectStack) {\n  /** @type {Array.<Array.<number>>} */\n  const flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);\n\n  if (flatLinearRings && flatLinearRings[0]) {\n    const polygon = new Polygon(null);\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    let i, ii;\n\n    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n\n    polygon.setFlatCoordinates(GeometryLayout.XYZ, flatCoordinates, ends);\n    return polygon;\n  } else {\n    return undefined;\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>} Flat coordinates.\n */\n\n\nGMLBase.prototype.readFlatCoordinatesFromNode_ = function (node, objectStack) {\n  return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\n\nGMLBase.prototype.MULTIPOINT_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser_),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGMLBase.prototype.MULTILINESTRING_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_),\n    'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGMLBase.prototype.MULTIPOLYGON_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser_),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGMLBase.prototype.POINTMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGMLBase.prototype.POLYGONMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @protected\n */\n\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing_)\n  }\n};\n/**\n * @inheritDoc\n */\n\nGMLBase.prototype.readGeometryFromNode = function (node, opt_options) {\n  const geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);\n  return geometry ? geometry : null;\n};\n/**\n * Read all features from a GML FeatureCollection.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Options.\n * @return {Array.<module:ol/Feature>} Features.\n * @api\n */\n\n\nGMLBase.prototype.readFeatures;\n/**\n * @inheritDoc\n */\n\nGMLBase.prototype.readFeaturesFromNode = function (node, opt_options) {\n  const options = {\n    featureType: this.featureType,\n    featureNS: this.featureNS\n  };\n\n  if (opt_options) {\n    assign(options, this.getReadOptions(node, opt_options));\n  }\n\n  const features = this.readFeaturesInternal(node, [options]);\n  return features || [];\n};\n/**\n * @inheritDoc\n */\n\n\nGMLBase.prototype.readProjectionFromNode = function (node) {\n  return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n};\n\nexport default GMLBase;","map":null,"metadata":{},"sourceType":"module"}