{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport derefLayers from '@mapbox/mapbox-gl-style-spec/deref';\nimport { expression, Color, function as fn, latest as spec, featureFilter as createFilter } from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport { deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing } from './util';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nconst isFunction = fn.isFunction;\nconst convertFunction = fn.convertFunction;\nconst isExpression = expression.isExpression;\nconst createPropertyExpression = expression.createPropertyExpression;\nconst types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nconst anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nconst expressionData = function (rawExpression, propertySpec) {\n  const compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n  }\n\n  return compiledExpression.value;\n};\n\nconst emptyObj = {};\nconst zoomObj = {\n  zoom: 0\n};\n/** @private */\n\nconst functionCache = {};\nlet renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\n\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  const layerId = layer.id;\n\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n\n  const functions = functionCache[layerId];\n\n  if (!functions[property]) {\n    let value = (layer[layoutOrPaint] || emptyObj)[property];\n    const propertySpec = spec[`${layoutOrPaint}_${layer.type}`][property];\n\n    if (value === undefined) {\n      value = propertySpec.default;\n    }\n\n    let isExpr = isExpression(value);\n\n    if (!isExpr && isFunction(value)) {\n      value = convertFunction(value, propertySpec);\n      isExpr = true;\n    }\n\n    if (isExpr) {\n      const compiledExpression = expressionData(value, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value = Color.parse(value);\n      }\n\n      functions[property] = function () {\n        return value;\n      };\n    }\n  }\n\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/** @private */\n\nconst filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\n\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter);\n  }\n\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\n\n\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n\n    const a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n\n  return color;\n}\n\nconst templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\n\nfunction fromTemplate(text, properties) {\n  let parts;\n\n  do {\n    parts = text.match(templateRegEx);\n\n    if (parts) {\n      const value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n\n  return text;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\n\n\nexport default function (olLayer, glStyle, source, resolutions = defaultResolutions, spriteData, spriteImageUrl, getFonts) {\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  let spriteImage, spriteImgSize;\n\n  if (spriteImageUrl) {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n\n    img.onload = function () {\n      spriteImage = img;\n      spriteImgSize = [img.width, img.height];\n      olLayer.changed();\n      img.onload = null;\n    };\n\n    img.src = spriteImageUrl;\n  }\n\n  const allLayers = derefLayers(glStyle.layers);\n  const layersBySourceLayer = {};\n  const mapboxLayers = [];\n  let mapboxSource;\n\n  for (let i = 0, ii = allLayers.length; i < ii; ++i) {\n    const layer = allLayers[i];\n    const layerId = layer.id;\n\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      const sourceLayer = layer['source-layer'];\n\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        const source = glStyle.sources[mapboxSource];\n\n        if (!source) {\n          throw new Error(`Source \"${mapboxSource}\" is not defined`);\n        }\n\n        const type = source.type;\n\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(`Source \"${mapboxSource}\" is not of type \"vector\" or \"geojson\", but \"${type}\"`);\n        }\n      }\n\n      let layers = layersBySourceLayer[sourceLayer];\n\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    } // TODO revisit when diffing gets added\n\n\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  const textHalo = new Stroke();\n  const textColor = new Fill();\n  const iconImageCache = {};\n  const patternCache = {};\n  const styles = [];\n\n  const styleFunction = function (feature, resolution) {\n    const properties = feature.getProperties();\n    const layers = layersBySourceLayer[properties.layer];\n\n    if (!layers) {\n      return;\n    }\n\n    let zoom = resolutions.indexOf(resolution);\n\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n\n    const type = types[feature.getGeometry().getType()];\n    const f = {\n      properties: properties,\n      type: type\n    };\n    let stylesLength = -1;\n\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      const layerData = layers[i];\n      const layer = layerData.layer;\n      const layerId = layer.id;\n      const layout = layer.layout || emptyObj;\n      const paint = layer.paint || emptyObj;\n\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        continue;\n      }\n\n      const filter = layer.filter;\n\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        let color, opacity, fill, stroke, strokeColor, style;\n        const index = layerData.index;\n\n        if (type == 3 && layer.type == 'fill') {\n          opacity = getValue(layer, 'paint', 'fill-opacity', zoom, f);\n\n          if ('fill-pattern' in paint) {\n            const fillIcon = getValue(layer, 'paint', 'fill-pattern', zoom, f);\n\n            if (fillIcon) {\n              const icon = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n\n              if (spriteImage && spriteData && spriteData[icon]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new Style({\n                    fill: new Fill()\n                  });\n                }\n\n                fill = style.getFill();\n                style.setZIndex(index);\n                const icon_cache_key = icon + '.' + opacity;\n                let pattern = patternCache[icon_cache_key];\n\n                if (!pattern) {\n                  const spriteImageData = spriteData[icon];\n                  const canvas = document.createElement('canvas');\n                  canvas.width = spriteImageData.width;\n                  canvas.height = spriteImageData.height;\n                  const ctx = canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', 'fill-color', zoom, f), opacity);\n\n            if (color) {\n              if ('fill-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', 'fill-outline-color', zoom, f), opacity);\n              }\n\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n\n              ++stylesLength;\n              style = styles[stylesLength];\n\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = styles[stylesLength] = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n              }\n\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) : undefined;\n          const width = getValue(layer, 'paint', 'line-width', zoom, f);\n\n          if (color && width > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = styles[stylesLength] = new Style({\n                stroke: new Stroke()\n              });\n            }\n\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n              return x * width;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        let hasImage = false;\n        let text = null;\n        let placementAngle = 0;\n        let icon, iconImg, skipLabel;\n\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          const iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            let styleGeom = undefined;\n\n            if (spriteImage && spriteData && spriteData[icon]) {\n              const iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n\n              if (type == 2) {\n                const geom = feature.getGeometry(); // ol package and ol-debug.js only\n\n                if (geom.getFlatMidpoint) {\n                  const extent = geom.getExtent();\n                  const size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    const midpoint = geom.getFlatMidpoint();\n\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    const placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      const stride = geom.getStride();\n                      const coordinates = geom.getFlatCoordinates();\n\n                      for (let i = 0, ii = coordinates.length - stride; i < ii; i += stride) {\n                        const x1 = coordinates[i];\n                        const y1 = coordinates[i + 1];\n                        const x2 = coordinates[i + stride];\n                        const y2 = coordinates[i + stride + 1];\n                        const minX = Math.min(x1, x2);\n                        const minY = Math.min(y1, y2);\n                        const maxX = Math.max(x1, x2);\n                        const maxY = Math.max(y1, y2);\n\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (type !== 2 || styleGeom) {\n                ++stylesLength;\n                style = styles[stylesLength];\n\n                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                  style = styles[stylesLength] = new Style();\n                }\n\n                style.setGeometry(styleGeom);\n                const iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                const iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n                let icon_cache_key = icon + '.' + iconSize;\n\n                if (iconColor !== null) {\n                  icon_cache_key += '.' + iconColor;\n                }\n\n                iconImg = iconImageCache[icon_cache_key];\n\n                if (!iconImg) {\n                  const spriteImageData = spriteData[icon];\n\n                  if (iconColor !== null) {\n                    // cut out the sprite and color it\n                    const canvas = document.createElement('canvas');\n                    canvas.width = spriteImageData.width;\n                    canvas.height = spriteImageData.height;\n                    const ctx = canvas.getContext('2d');\n                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n                    for (let c = 0, cc = data.data.length; c < cc; c += 4) {\n                      const a = iconColor.a;\n\n                      if (a !== 0) {\n                        data.data[c] = iconColor.r * 255 / a;\n                        data.data[c + 1] = iconColor.g * 255 / a;\n                        data.data[c + 2] = iconColor.b * 255 / a;\n                      }\n\n                      data.data[c + 3] = a;\n                    }\n\n                    ctx.putImageData(data, 0, 0);\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: canvas,\n                      imgSize: [canvas.width, canvas.height],\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  } else {\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [spriteImageData.width, spriteImageData.height],\n                      offset: [spriteImageData.x, spriteImageData.y],\n                      rotateWithView: iconRotationAlignment === 'map',\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  }\n                }\n\n                iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                style.setImage(iconImg);\n                text = style.getText();\n                style.setText(undefined);\n                style.setZIndex(index);\n                hasImage = true;\n                skipLabel = false;\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new Style();\n          }\n\n          const circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          const circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          const circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          const circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          const cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n\n          if (!iconImg) {\n            iconImg = iconImageCache[cache_key] = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n          }\n\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        let label;\n\n        if ('text-field' in layout) {\n          const textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new Style();\n            }\n\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n\n          text = style.getText();\n          const textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          const fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          const textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          const font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          const textTransform = layout['text-transform'];\n\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n\n          const maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          const letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          const wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          const textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          const placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          let textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          const textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          const textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f); // Text offset has to take halo width and line height into account\n\n          let vOffset = 0;\n          let hOffset = 0;\n\n          if (placement == 'point') {\n            let textAlign = 'center';\n\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n\n            text.setTextAlign(textAlign);\n            const textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n\n          let textBaseline = 'middle';\n\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          const haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n\n          if (haloColor) {\n            textHalo.setColor(haloColor); // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n\n            textHaloWidth *= 2; // 1/4 of text size (spec) x 2\n\n            const halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n\n          const textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          const padding = text.getPadding();\n\n          if (textPadding !== padding[0]) {\n            padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n          }\n\n          style.setZIndex(index);\n        }\n      }\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ol-mapbox-style/stylefunction.js"],"names":["Style","Fill","Stroke","Icon","Text","Circle","RenderFeature","derefLayers","expression","Color","function","fn","latest","spec","featureFilter","createFilter","mb2css","deg2rad","defaultResolutions","getZoomForResolution","wrapText","applyLetterSpacing","isFunction","convertFunction","isExpression","createPropertyExpression","types","anchor","expressionData","rawExpression","propertySpec","compiledExpression","result","Error","value","map","err","key","message","join","emptyObj","zoomObj","zoom","functionCache","renderFeatureCoordinates","renderFeature","getValue","layer","layoutOrPaint","property","feature","layerId","id","functions","type","undefined","default","isExpr","evaluate","bind","parse","filterCache","evaluateFilter","filter","colorWithOpacity","color","opacity","a","Math","round","r","g","b","templateRegEx","fromTemplate","text","properties","parts","match","olLayer","glStyle","source","resolutions","spriteData","spriteImageUrl","getFonts","JSON","version","spriteImage","spriteImgSize","img","Image","crossOrigin","onload","width","height","changed","src","allLayers","layers","layersBySourceLayer","mapboxLayers","mapboxSource","i","ii","length","indexOf","sourceLayer","sources","push","index","textHalo","textColor","iconImageCache","patternCache","styles","styleFunction","resolution","getProperties","getGeometry","getType","f","stylesLength","layerData","layout","paint","visibility","minzoom","maxzoom","fill","stroke","strokeColor","style","fillIcon","icon","toString","getFill","getStroke","getText","setZIndex","icon_cache_key","pattern","spriteImageData","canvas","document","createElement","ctx","getContext","globalAlpha","drawImage","x","y","createPattern","setColor","setWidth","setLineCap","setLineJoin","setMiterLimit","setLineDash","hasImage","placementAngle","iconImg","skipLabel","iconImage","styleGeom","iconRotationAlignment","geom","getFlatMidpoint","extent","getExtent","size","sqrt","max","pow","midpoint","NaN","placement","stride","getStride","coordinates","getFlatCoordinates","x1","y1","x2","y2","minX","min","minY","maxX","maxY","atan2","getImage","setGeometry","iconSize","iconColor","data","getImageData","c","cc","putImageData","imgSize","scale","pixelRatio","offset","rotateWithView","setRotation","setOpacity","setAnchor","setImage","setText","circleRadius","circleStrokeColor","circleColor","circleStrokeWidth","cache_key","radius","label","textField","trim","padding","textSize","fontArray","textLineHeight","font","textTransform","toUpperCase","toLowerCase","maxTextWidth","letterSpacing","wrappedLabel","setFont","textAnchor","setPlacement","textHaloWidth","textOffset","textTranslate","vOffset","hOffset","textAlign","setTextAlign","textRotationAlignment","setRotateWithView","setMaxAngle","textBaseline","setTextBaseline","setOffsetX","setOffsetY","setFill","haloColor","halfTextSize","setStroke","textPadding","getPadding","setStyle","set","_colorWithOpacity","_filterCache","_evaluateFilter","_fromTemplate","_getValue","_functionCache"],"mappings":"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","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport derefLayers from '@mapbox/mapbox-gl-style-spec/deref';\nimport {\n  expression, Color,\n  function as fn,\n  latest as spec,\n  featureFilter as createFilter\n} from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport {deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing} from './util';\n\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nconst isFunction = fn.isFunction;\nconst convertFunction = fn.convertFunction;\nconst isExpression = expression.isExpression;\nconst createPropertyExpression = expression.createPropertyExpression;\n\nconst types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nconst anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nconst expressionData = function(rawExpression, propertySpec) {\n  const compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n  }\n  return compiledExpression.value;\n};\n\nconst emptyObj = {};\nconst zoomObj = {zoom: 0};\n/** @private */\nconst functionCache = {};\nlet renderFeatureCoordinates, renderFeature;\n\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  const layerId = layer.id;\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  const functions = functionCache[layerId];\n  if (!functions[property]) {\n    let value = (layer[layoutOrPaint] || emptyObj)[property];\n    const propertySpec = spec[`${layoutOrPaint}_${layer.type}`][property];\n    if (value === undefined) {\n      value = propertySpec.default;\n    }\n    let isExpr = isExpression((value));\n    if (!isExpr && isFunction(value)) {\n      value = convertFunction(value, propertySpec);\n      isExpr = true;\n    }\n    if (isExpr) {\n      const compiledExpression = expressionData(value, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value = Color.parse(value);\n      }\n      functions[property] = function() {\n        return value;\n      };\n    }\n  }\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n\n/** @private */\nconst filterCache = {};\n\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter);\n  }\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n    const a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) +\n      ',' + Math.round(color.b * 255 / a) + ',' + (a * opacity) + ')';\n  }\n  return color;\n}\n\nconst templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n  let parts;\n  do {\n    parts = text.match(templateRegEx);\n    if (parts) {\n      const value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n  return text;\n}\n\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function(olLayer, glStyle, source, resolutions = defaultResolutions, spriteData, spriteImageUrl, getFonts) {\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  let spriteImage, spriteImgSize;\n  if (spriteImageUrl) {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = function() {\n      spriteImage = img;\n      spriteImgSize = [img.width, img.height];\n      olLayer.changed();\n      img.onload = null;\n    };\n    img.src = spriteImageUrl;\n  }\n\n\n  const allLayers = derefLayers(glStyle.layers);\n\n  const layersBySourceLayer = {};\n  const mapboxLayers = [];\n  let mapboxSource;\n  for (let i = 0, ii = allLayers.length; i < ii; ++i) {\n    const layer = allLayers[i];\n    const layerId = layer.id;\n    if (typeof source == 'string' && layer.source == source ||\n        source.indexOf(layerId) !== -1) {\n      const sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        const source = glStyle.sources[mapboxSource];\n        if (!source) {\n          throw new Error(`Source \"${mapboxSource}\" is not defined`);\n        }\n        const type = source.type;\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(`Source \"${mapboxSource}\" is not of type \"vector\" or \"geojson\", but \"${type}\"`);\n        }\n      }\n      let layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n    // TODO revisit when diffing gets added\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  const textHalo = new Stroke();\n  const textColor = new Fill();\n\n  const iconImageCache = {};\n  const patternCache = {};\n  const styles = [];\n\n  const styleFunction = function(feature, resolution) {\n    const properties = feature.getProperties();\n    const layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    let zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n    const type = types[feature.getGeometry().getType()];\n    const f = {\n      properties: properties,\n      type: type\n    };\n    let stylesLength = -1;\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      const layerData = layers[i];\n      const layer = layerData.layer;\n      const layerId = layer.id;\n\n      const layout = layer.layout || emptyObj;\n      const paint = layer.paint || emptyObj;\n      if (layout.visibility === 'none' || ('minzoom' in layer && zoom < layer.minzoom) ||\n          ('maxzoom' in layer && zoom >= layer.maxzoom)) {\n        continue;\n      }\n      const filter = layer.filter;\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        let color, opacity, fill, stroke, strokeColor, style;\n        const index = layerData.index;\n        if (type == 3 && layer.type == 'fill') {\n          opacity = getValue(layer, 'paint', 'fill-opacity', zoom, f);\n          if ('fill-pattern' in paint) {\n            const fillIcon = getValue(layer, 'paint', 'fill-pattern', zoom, f);\n            if (fillIcon) {\n              const icon = typeof fillIcon === 'string'\n                ? fromTemplate(fillIcon, properties)\n                : fillIcon.toString();\n              if (spriteImage && spriteData && spriteData[icon]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new Style({\n                    fill: new Fill()\n                  });\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                const icon_cache_key = icon + '.' + opacity;\n                let pattern = patternCache[icon_cache_key];\n                if (!pattern) {\n                  const spriteImageData = spriteData[icon];\n                  const canvas = document.createElement('canvas');\n                  canvas.width = spriteImageData.width;\n                  canvas.height = spriteImageData.height;\n                  const ctx = canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(\n                    spriteImage,\n                    spriteImageData.x,\n                    spriteImageData.y,\n                    spriteImageData.width,\n                    spriteImageData.height,\n                    0,\n                    0,\n                    spriteImageData.width,\n                    spriteImageData.height\n                  );\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', 'fill-color', zoom, f), opacity);\n            if (color) {\n              if ('fill-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', 'fill-outline-color', zoom, f), opacity);\n              }\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n              ++stylesLength;\n              style = styles[stylesLength];\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = styles[stylesLength] = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n              }\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ?\n            colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) :\n            undefined;\n          const width = getValue(layer, 'paint', 'line-width', zoom, f);\n          if (color && width > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = styles[stylesLength] = new Style({\n                stroke: new Stroke()\n              });\n            }\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width);\n            stroke.setLineDash(paint['line-dasharray'] ?\n              getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function(x) {\n                return x * width;\n              }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        let hasImage = false;\n        let text = null;\n        let placementAngle = 0;\n        let icon, iconImg, skipLabel;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          const iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n          if (iconImage) {\n            icon = typeof iconImage === 'string'\n              ? fromTemplate(iconImage, properties)\n              : iconImage.toString();\n            let styleGeom = undefined;\n            if (spriteImage && spriteData && spriteData[icon]) {\n              const iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n              if (type == 2) {\n                const geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint) {\n                  const extent = geom.getExtent();\n                  const size = Math.sqrt(Math.max(\n                    Math.pow((extent[2] - extent[0]) / resolution, 2),\n                    Math.pow((extent[3] - extent[1]) / resolution, 2))\n                  );\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    const midpoint = geom.getFlatMidpoint();\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    const placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      const stride = geom.getStride();\n                      const coordinates = geom.getFlatCoordinates();\n                      for (let i = 0, ii = coordinates.length - stride; i < ii; i += stride) {\n                        const x1 = coordinates[i];\n                        const y1 = coordinates[i + 1];\n                        const x2 = coordinates[i + stride];\n                        const y2 = coordinates[i + stride + 1];\n                        const minX = Math.min(x1, x2);\n                        const minY = Math.min(y1, y2);\n                        const maxX = Math.max(x1, x2);\n                        const maxY = Math.max(y1, y2);\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX &&\n                            midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                  style = styles[stylesLength] = new Style();\n                }\n                style.setGeometry(styleGeom);\n                const iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                const iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n                let icon_cache_key = icon + '.' + iconSize;\n                if (iconColor !== null) {\n                  icon_cache_key += '.' + iconColor;\n                }\n                iconImg = iconImageCache[icon_cache_key];\n                if (!iconImg) {\n                  const spriteImageData = spriteData[icon];\n                  if (iconColor !== null) {\n                    // cut out the sprite and color it\n                    const canvas = document.createElement('canvas');\n                    canvas.width = spriteImageData.width;\n                    canvas.height = spriteImageData.height;\n                    const ctx = canvas.getContext('2d');\n                    ctx.drawImage(\n                      spriteImage,\n                      spriteImageData.x,\n                      spriteImageData.y,\n                      spriteImageData.width,\n                      spriteImageData.height,\n                      0,\n                      0,\n                      spriteImageData.width,\n                      spriteImageData.height\n                    );\n                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                    for (let c = 0, cc = data.data.length; c < cc; c += 4) {\n                      const a = iconColor.a;\n                      if (a !== 0) {\n                        data.data[c] = iconColor.r * 255 / a;\n                        data.data[c + 1] = iconColor.g * 255 / a;\n                        data.data[c + 2] = iconColor.b * 255 / a;\n                      }\n                      data.data[c + 3] = a;\n                    }\n                    ctx.putImageData(data, 0, 0);\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: canvas,\n                      imgSize: [canvas.width, canvas.height],\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  } else {\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [spriteImageData.width, spriteImageData.height],\n                      offset: [spriteImageData.x, spriteImageData.y],\n                      rotateWithView: iconRotationAlignment === 'map',\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  }\n                }\n                iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                style.setImage(iconImg);\n                text = style.getText();\n                style.setText(undefined);\n                style.setZIndex(index);\n                hasImage = true;\n                skipLabel = false;\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new Style();\n          }\n          const circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          const circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          const circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          const circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          const cache_key = circleRadius + '.' + circleStrokeColor + '.' +\n            circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = iconImageCache[cache_key] = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        let label;\n        if ('text-field' in layout) {\n          const textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new Style();\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n          text = style.getText();\n          const textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          const fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          const textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          const font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          const textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n          const maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          const letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          const wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          const textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          const placement = (hasImage || type == 1) ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          let textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          const textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          const textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n          // Text offset has to take halo width and line height into account\n          let vOffset = 0;\n          let hOffset = 0;\n          if (placement == 'point') {\n            let textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n            text.setTextAlign(textAlign);\n            const textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n          let textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - (0.5 * (textLineHeight - 1)) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + (0.5 * (textLineHeight - 1)) * textSize;\n          }\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          const haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n          if (haloColor) {\n            textHalo.setColor(haloColor);\n            // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n            textHaloWidth *= 2;\n            // 1/4 of text size (spec) x 2\n            const halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          const textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          const padding = text.getPadding();\n          if (textPadding !== padding[0]) {\n            padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n          }\n          style.setZIndex(index);\n        }\n      }\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\n\nexport {\n  colorWithOpacity as _colorWithOpacity,\n  filterCache as _filterCache,\n  evaluateFilter as _evaluateFilter,\n  fromTemplate as _fromTemplate,\n  getValue as _getValue,\n  functionCache as _functionCache\n};\n"]},"metadata":{},"sourceType":"module"}