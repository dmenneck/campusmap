{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport { inherits } from '../../util.js';\nimport { asString } from '../../color.js';\nimport { snap } from '../../geom/flat/simplify.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport CanvasInstruction, { fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction } from '../canvas/Instruction.js';\nimport CanvasReplay from '../canvas/Replay.js';\n/**\n * @constructor\n * @extends {module:ol/render/canvas/Replay}\n * @param {number} tolerance Tolerance.\n * @param {module:ol/extent~Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\n\nconst CanvasPolygonReplay = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n};\n\ninherits(CanvasPolygonReplay, CanvasReplay);\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @private\n * @return {number} End.\n */\n\nCanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n  const state = this.state;\n  const fill = state.fillStyle !== undefined;\n  const stroke = state.strokeStyle != undefined;\n  const numEnds = ends.length;\n  this.instructions.push(beginPathInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction);\n\n  for (let i = 0; i < numEnds; ++i) {\n    const end = ends[i];\n    const myBegin = this.coordinates.length;\n    const myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n    const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n    if (stroke) {\n      // Performance optimization: only call closePath() when we have a stroke.\n      // Otherwise the ring is closed already (see appendFlatCoordinates above).\n      this.instructions.push(closePathInstruction);\n      this.hitDetectionInstructions.push(closePathInstruction);\n    }\n\n    offset = end;\n  }\n\n  if (fill) {\n    this.instructions.push(fillInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n  }\n\n  if (stroke) {\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n\n  return offset;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasPolygonReplay.prototype.drawCircle = function (circleGeometry, feature) {\n  const state = this.state;\n  const fillStyle = state.fillStyle;\n  const strokeStyle = state.strokeStyle;\n\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n\n  this.setFillStrokeStyles_(circleGeometry);\n  this.beginGeometry(circleGeometry, feature);\n\n  if (state.fillStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  const flatCoordinates = circleGeometry.getFlatCoordinates();\n  const stride = circleGeometry.getStride();\n  const myBegin = this.coordinates.length;\n  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n  const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n  this.instructions.push(beginPathInstruction, circleInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n  this.hitDetectionInstructions.push(fillInstruction);\n\n  if (state.fillStyle !== undefined) {\n    this.instructions.push(fillInstruction);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n\n  this.endGeometry(circleGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasPolygonReplay.prototype.drawPolygon = function (polygonGeometry, feature) {\n  const state = this.state;\n  const fillStyle = state.fillStyle;\n  const strokeStyle = state.strokeStyle;\n\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n\n  this.setFillStrokeStyles_(polygonGeometry);\n  this.beginGeometry(polygonGeometry, feature);\n\n  if (state.fillStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  const ends = polygonGeometry.getEnds();\n  const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n  const stride = polygonGeometry.getStride();\n  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n  this.endGeometry(polygonGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasPolygonReplay.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n  const state = this.state;\n  const fillStyle = state.fillStyle;\n  const strokeStyle = state.strokeStyle;\n\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n\n  this.setFillStrokeStyles_(multiPolygonGeometry);\n  this.beginGeometry(multiPolygonGeometry, feature);\n\n  if (state.fillStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  const endss = multiPolygonGeometry.getEndss();\n  const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n  const stride = multiPolygonGeometry.getStride();\n  let offset = 0;\n\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n  }\n\n  this.endGeometry(multiPolygonGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasPolygonReplay.prototype.finish = function () {\n  this.reverseHitDetectionInstructions();\n  this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n  // simplified using quantization and point elimination. However, we might\n  // have received a mix of quantized and non-quantized geometries, so ensure\n  // that all are quantized by quantizing all coordinates in the batch.\n\n  const tolerance = this.tolerance;\n\n  if (tolerance !== 0) {\n    const coordinates = this.coordinates;\n\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      coordinates[i] = snap(coordinates[i], tolerance);\n    }\n  }\n};\n/**\n * @private\n * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.\n */\n\n\nCanvasPolygonReplay.prototype.setFillStrokeStyles_ = function (geometry) {\n  const state = this.state;\n  const fillStyle = state.fillStyle;\n\n  if (fillStyle !== undefined) {\n    this.updateFillStyle(state, this.createFill, geometry);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.updateStrokeStyle(state, this.applyStroke);\n  }\n};\n\nexport default CanvasPolygonReplay;","map":null,"metadata":{},"sourceType":"module"}