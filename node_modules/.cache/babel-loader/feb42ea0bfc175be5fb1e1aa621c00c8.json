{"ast":null,"code":"/**\n * @module ol/structs/PriorityQueue\n */\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\n/**\n * @type {number}\n */\n\nexport var DROP = Infinity;\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library's Heap class and\n * Python's heapq module.\n *\n * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\n\nvar PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {\n  /**\n   * @type {function(T): number}\n   * @private\n   */\n  this.priorityFunction_ = priorityFunction;\n  /**\n   * @type {function(T): string}\n   * @private\n   */\n\n  this.keyFunction_ = keyFunction;\n  /**\n   * @type {Array<T>}\n   * @private\n   */\n\n  this.elements_ = [];\n  /**\n   * @type {Array<number>}\n   * @private\n   */\n\n  this.priorities_ = [];\n  /**\n   * @type {!Object<string, boolean>}\n   * @private\n   */\n\n  this.queuedElements_ = {};\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\nPriorityQueue.prototype.clear = function clear$1() {\n  this.elements_.length = 0;\n  this.priorities_.length = 0;\n  clear(this.queuedElements_);\n};\n/**\n * Remove and return the highest-priority element. O(log N).\n * @return {T} Element.\n */\n\n\nPriorityQueue.prototype.dequeue = function dequeue() {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var element = elements[0];\n\n  if (elements.length == 1) {\n    elements.length = 0;\n    priorities.length = 0;\n  } else {\n    elements[0] = elements.pop();\n    priorities[0] = priorities.pop();\n    this.siftUp_(0);\n  }\n\n  var elementKey = this.keyFunction_(element);\n  delete this.queuedElements_[elementKey];\n  return element;\n};\n/**\n * Enqueue an element. O(log N).\n * @param {T} element Element.\n * @return {boolean} The element was added to the queue.\n */\n\n\nPriorityQueue.prototype.enqueue = function enqueue(element) {\n  assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n\n  var priority = this.priorityFunction_(element);\n\n  if (priority != DROP) {\n    this.elements_.push(element);\n    this.priorities_.push(priority);\n    this.queuedElements_[this.keyFunction_(element)] = true;\n    this.siftDown_(0, this.elements_.length - 1);\n    return true;\n  }\n\n  return false;\n};\n/**\n * @return {number} Count.\n */\n\n\nPriorityQueue.prototype.getCount = function getCount() {\n  return this.elements_.length;\n};\n/**\n * Gets the index of the left child of the node at the given index.\n * @param {number} index The index of the node to get the left child for.\n * @return {number} The index of the left child.\n * @private\n */\n\n\nPriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_(index) {\n  return index * 2 + 1;\n};\n/**\n * Gets the index of the right child of the node at the given index.\n * @param {number} index The index of the node to get the right child for.\n * @return {number} The index of the right child.\n * @private\n */\n\n\nPriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_(index) {\n  return index * 2 + 2;\n};\n/**\n * Gets the index of the parent of the node at the given index.\n * @param {number} index The index of the node to get the parent for.\n * @return {number} The index of the parent.\n * @private\n */\n\n\nPriorityQueue.prototype.getParentIndex_ = function getParentIndex_(index) {\n  return index - 1 >> 1;\n};\n/**\n * Make this a heap. O(N).\n * @private\n */\n\n\nPriorityQueue.prototype.heapify_ = function heapify_() {\n  var i;\n\n  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n    this.siftUp_(i);\n  }\n};\n/**\n * @return {boolean} Is empty.\n */\n\n\nPriorityQueue.prototype.isEmpty = function isEmpty() {\n  return this.elements_.length === 0;\n};\n/**\n * @param {string} key Key.\n * @return {boolean} Is key queued.\n */\n\n\nPriorityQueue.prototype.isKeyQueued = function isKeyQueued(key) {\n  return key in this.queuedElements_;\n};\n/**\n * @param {T} element Element.\n * @return {boolean} Is queued.\n */\n\n\nPriorityQueue.prototype.isQueued = function isQueued(element) {\n  return this.isKeyQueued(this.keyFunction_(element));\n};\n/**\n * @param {number} index The index of the node to move down.\n * @private\n */\n\n\nPriorityQueue.prototype.siftUp_ = function siftUp_(index) {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var count = elements.length;\n  var element = elements[index];\n  var priority = priorities[index];\n  var startIndex = index;\n\n  while (index < count >> 1) {\n    var lIndex = this.getLeftChildIndex_(index);\n    var rIndex = this.getRightChildIndex_(index);\n    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n    elements[index] = elements[smallerChildIndex];\n    priorities[index] = priorities[smallerChildIndex];\n    index = smallerChildIndex;\n  }\n\n  elements[index] = element;\n  priorities[index] = priority;\n  this.siftDown_(startIndex, index);\n};\n/**\n * @param {number} startIndex The index of the root.\n * @param {number} index The index of the node to move up.\n * @private\n */\n\n\nPriorityQueue.prototype.siftDown_ = function siftDown_(startIndex, index) {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var element = elements[index];\n  var priority = priorities[index];\n\n  while (index > startIndex) {\n    var parentIndex = this.getParentIndex_(index);\n\n    if (priorities[parentIndex] > priority) {\n      elements[index] = elements[parentIndex];\n      priorities[index] = priorities[parentIndex];\n      index = parentIndex;\n    } else {\n      break;\n    }\n  }\n\n  elements[index] = element;\n  priorities[index] = priority;\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\nPriorityQueue.prototype.reprioritize = function reprioritize() {\n  var priorityFunction = this.priorityFunction_;\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var index = 0;\n  var n = elements.length;\n  var element, i, priority;\n\n  for (i = 0; i < n; ++i) {\n    element = elements[i];\n    priority = priorityFunction(element);\n\n    if (priority == DROP) {\n      delete this.queuedElements_[this.keyFunction_(element)];\n    } else {\n      priorities[index] = priority;\n      elements[index++] = element;\n    }\n  }\n\n  elements.length = index;\n  priorities.length = index;\n  this.heapify_();\n};\n\nexport default PriorityQueue;","map":{"version":3,"sources":["../../../src/ol/structs/PriorityQueue.js"],"names":["const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/structs/PriorityQueue\n */\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\n\n\n/**\n * @type {number}\n */\nexport const DROP = Infinity;\n\n\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library's Heap class and\n * Python's heapq module.\n *\n * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\nclass PriorityQueue {\n\n  /**\n   * @param {function(T): number} priorityFunction Priority function.\n   * @param {function(T): string} keyFunction Key function.\n   */\n  constructor(priorityFunction, keyFunction) {\n\n    /**\n     * @type {function(T): number}\n     * @private\n     */\n    this.priorityFunction_ = priorityFunction;\n\n    /**\n     * @type {function(T): string}\n     * @private\n     */\n    this.keyFunction_ = keyFunction;\n\n    /**\n     * @type {Array<T>}\n     * @private\n     */\n    this.elements_ = [];\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.priorities_ = [];\n\n    /**\n     * @type {!Object<string, boolean>}\n     * @private\n     */\n    this.queuedElements_ = {};\n\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.elements_.length = 0;\n    this.priorities_.length = 0;\n    clear(this.queuedElements_);\n  }\n\n\n  /**\n   * Remove and return the highest-priority element. O(log N).\n   * @return {T} Element.\n   */\n  dequeue() {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[0];\n    if (elements.length == 1) {\n      elements.length = 0;\n      priorities.length = 0;\n    } else {\n      elements[0] = elements.pop();\n      priorities[0] = priorities.pop();\n      this.siftUp_(0);\n    }\n    const elementKey = this.keyFunction_(element);\n    delete this.queuedElements_[elementKey];\n    return element;\n  }\n\n\n  /**\n   * Enqueue an element. O(log N).\n   * @param {T} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  enqueue(element) {\n    assert(!(this.keyFunction_(element) in this.queuedElements_),\n      31); // Tried to enqueue an `element` that was already added to the queue\n    const priority = this.priorityFunction_(element);\n    if (priority != DROP) {\n      this.elements_.push(element);\n      this.priorities_.push(priority);\n      this.queuedElements_[this.keyFunction_(element)] = true;\n      this.siftDown_(0, this.elements_.length - 1);\n      return true;\n    }\n    return false;\n  }\n\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.elements_.length;\n  }\n\n\n  /**\n   * Gets the index of the left child of the node at the given index.\n   * @param {number} index The index of the node to get the left child for.\n   * @return {number} The index of the left child.\n   * @private\n   */\n  getLeftChildIndex_(index) {\n    return index * 2 + 1;\n  }\n\n\n  /**\n   * Gets the index of the right child of the node at the given index.\n   * @param {number} index The index of the node to get the right child for.\n   * @return {number} The index of the right child.\n   * @private\n   */\n  getRightChildIndex_(index) {\n    return index * 2 + 2;\n  }\n\n\n  /**\n   * Gets the index of the parent of the node at the given index.\n   * @param {number} index The index of the node to get the parent for.\n   * @return {number} The index of the parent.\n   * @private\n   */\n  getParentIndex_(index) {\n    return (index - 1) >> 1;\n  }\n\n\n  /**\n   * Make this a heap. O(N).\n   * @private\n   */\n  heapify_() {\n    let i;\n    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n      this.siftUp_(i);\n    }\n  }\n\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.elements_.length === 0;\n  }\n\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Is key queued.\n   */\n  isKeyQueued(key) {\n    return key in this.queuedElements_;\n  }\n\n\n  /**\n   * @param {T} element Element.\n   * @return {boolean} Is queued.\n   */\n  isQueued(element) {\n    return this.isKeyQueued(this.keyFunction_(element));\n  }\n\n\n  /**\n   * @param {number} index The index of the node to move down.\n   * @private\n   */\n  siftUp_(index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const count = elements.length;\n    const element = elements[index];\n    const priority = priorities[index];\n    const startIndex = index;\n\n    while (index < (count >> 1)) {\n      const lIndex = this.getLeftChildIndex_(index);\n      const rIndex = this.getRightChildIndex_(index);\n\n      const smallerChildIndex = rIndex < count &&\n          priorities[rIndex] < priorities[lIndex] ?\n        rIndex : lIndex;\n\n      elements[index] = elements[smallerChildIndex];\n      priorities[index] = priorities[smallerChildIndex];\n      index = smallerChildIndex;\n    }\n\n    elements[index] = element;\n    priorities[index] = priority;\n    this.siftDown_(startIndex, index);\n  }\n\n\n  /**\n   * @param {number} startIndex The index of the root.\n   * @param {number} index The index of the node to move up.\n   * @private\n   */\n  siftDown_(startIndex, index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[index];\n    const priority = priorities[index];\n\n    while (index > startIndex) {\n      const parentIndex = this.getParentIndex_(index);\n      if (priorities[parentIndex] > priority) {\n        elements[index] = elements[parentIndex];\n        priorities[index] = priorities[parentIndex];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n    elements[index] = element;\n    priorities[index] = priority;\n  }\n\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  reprioritize() {\n    const priorityFunction = this.priorityFunction_;\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    let index = 0;\n    const n = elements.length;\n    let element, i, priority;\n    for (i = 0; i < n; ++i) {\n      element = elements[i];\n      priority = priorityFunction(element);\n      if (priority == DROP) {\n        delete this.queuedElements_[this.keyFunction_(element)];\n      } else {\n        priorities[index] = priority;\n        elements[index++] = element;\n      }\n    }\n    elements.length = index;\n    priorities.length = index;\n    this.heapify_();\n  }\n\n}\n\n\nexport default PriorityQueue;\n"]},"metadata":{},"sourceType":"module"}