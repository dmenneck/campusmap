{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport mb2css from 'mapbox-to-css-font';\nimport applyStyleFunction, { getValue } from './stylefunction';\nimport googleFonts from 'webfont-matcher/lib/fonts/google';\nimport { fromLonLat } from 'ol/proj';\nimport { createXYZ } from 'ol/tilegrid';\nimport TileGrid from 'ol/tilegrid/TileGrid';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport MVT from 'ol/format/MVT';\nimport { unByKey } from 'ol/Observable';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorTileLayer from 'ol/layer/VectorTile';\nimport TileJSON from 'ol/source/TileJSON';\nimport VectorSource from 'ol/source/Vector';\nimport VectorTileSource from 'ol/source/VectorTile';\nimport { Color } from '@mapbox/mapbox-gl-style-spec';\nimport { defaultResolutions } from './util';\n/**\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/PluggableMap\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\n\nconst tilejsonCache = {};\nconst fontFamilyRegEx = /font-family: ?([^;]*);/;\nconst stripQuotesRegEx = /(\"|')/g;\nlet loadedFontFamilies;\n\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    const styleSheets = document.styleSheets;\n\n    for (let i = 0, ii = styleSheets.length; i < ii; ++i) {\n      const styleSheet =\n      /** @type {CSSStyleSheet} */\n      styleSheets[i];\n\n      try {\n        const cssRules = styleSheet.rules || styleSheet.cssRules;\n\n        if (cssRules) {\n          for (let j = 0, jj = cssRules.length; j < jj; ++j) {\n            const cssRule = cssRules[j];\n\n            if (cssRule.type == 5) {\n              const match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {// empty catch block\n      }\n    }\n  }\n\n  return family in loadedFontFamilies;\n}\n\nconst processedFontFamilies = {};\nconst googleFamilies = googleFonts.getNames();\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\n\nfunction getFonts(fonts) {\n  const fontsKey = fonts.toString();\n\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n\n  const googleFontDescriptions = fonts.map(function (font) {\n    const parts = mb2css(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n\n  for (let i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    const googleFontDescription = googleFontDescriptions[i];\n    const family = googleFontDescription[0];\n\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      const fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        const markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\n\nconst spriteRegEx = /^(.*)(\\?.*)$/;\n\nfunction withPath(url, path) {\n  if (path && url.startsWith('.')) {\n    url = path + url;\n  }\n\n  return url;\n}\n\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  const parts = url.match(spriteRegEx);\n  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;\n}\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\n\n\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function (resolve, reject) {\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n\n    if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n\n    let spriteScale, spriteData, spriteImageUrl, style;\n\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n\n        if (!layer.getStyle()) {\n          reject(new Error(`Nothing to show for source [${source}]`));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      const sizeFactor = spriteScale == 0.5 ? '@2x' : '';\n      let spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');\n      fetch(spriteUrl, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        if (!response.ok && sizeFactor !== '') {\n          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');\n          return fetch(spriteUrl, {\n            credentials: 'same-origin'\n          });\n        } else {\n          return response;\n        }\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          reject(new Error(`Problem fetching sprite from ${spriteUrl}: ${response.statusText}`));\n        }\n      }).then(function (spritesJson) {\n        if (spritesJson === undefined || Object.keys(spritesJson).length === 0) {\n          return reject(new Error('No sprites found.'));\n        }\n\n        spriteData = spritesJson;\n        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');\n        onChange();\n      }).catch(function (err) {\n        reject(new Error(`Sprites cannot be loaded: ${spriteUrl}: ${err.message}`));\n      });\n    } else {\n      onChange();\n    }\n  });\n}\nconst emptyObj = {};\n\nfunction setBackground(map, layer) {\n  const background = {\n    type: layer.type\n  };\n\n  function updateStyle() {\n    const element = map.getTargetElement();\n\n    if (!element) {\n      return;\n    }\n\n    const layout = layer.layout || {};\n    const paint = layer.paint || {};\n    background['paint'] = paint;\n    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n    const zoom = map.getView().getZoom();\n\n    if (paint['background-color'] !== undefined) {\n      const bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n      element.style.backgroundColor = Color.parse(bg).toString();\n    }\n\n    if (paint['background-opacity'] !== undefined) {\n      element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n    }\n\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.opacity = '';\n    }\n  }\n\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\n\n\nexport function applyBackground(map, glStyle) {\n  glStyle.layers.some(function (l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\n\nfunction getSourceIdByRef(layers, ref) {\n  let sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\n\nfunction extentFromTileJSON(tileJSON) {\n  const bounds = tileJSON.bounds;\n\n  if (bounds) {\n    const ll = fromLonLat([bounds[0], bounds[1]]);\n    const tr = fromLonLat([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\n\nfunction setupVectorLayer(glSource, accessToken, url) {\n  glSource = Object.assign({}, glSource);\n\n  if (url) {\n    if (url.indexOf('mapbox://') == 0) {\n      const mapid = url.replace('mapbox://', '');\n      glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n        return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;\n      });\n    }\n  }\n\n  const layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  const cacheKey = JSON.stringify(glSource);\n  let tilejson = tilejsonCache[cacheKey];\n\n  if (!tilejson) {\n    tilejson = tilejsonCache[cacheKey] = new TileJSON({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n  }\n\n  const key = tilejson.on('change', function () {\n    const state = tilejson.getState();\n\n    if (state === 'ready') {\n      const tileJSONDoc = tilejson.getTileJSON();\n      const tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n\n      if (glSource.url) {\n        for (let i = 0, ii = tiles.length; i < ii; ++i) {\n          const tile = tiles[i];\n\n          if (tile.indexOf('http') != 0) {\n            tiles[i] = glSource.url + tile;\n          }\n        }\n      }\n\n      const tileGrid = tilejson.getTileGrid();\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22;\n      let source = tilejson.get('ol-source');\n\n      if (source === undefined) {\n        source = new VectorTileSource({\n          attributions: tilejson.getAttributions(),\n          format: new MVT(),\n          tileGrid: new TileGrid({\n            origin: tileGrid.getOrigin(0),\n            extent: extent || tileGrid.getExtent(),\n            minZoom: minZoom,\n            resolutions: defaultResolutions.slice(0, maxZoom + 1),\n            tileSize: 512\n          }),\n          urls: tiles\n        });\n        tilejson.set('ol-source', source);\n      }\n\n      unByKey(key);\n      layer.setSource(source);\n    } else if (state === 'error') {\n      tilejson.set('ol-source', null);\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n\n  if (tilejson.getState() === 'ready') {\n    tilejson.changed();\n  }\n\n  return layer;\n}\n\nfunction setupRasterLayer(glSource, url) {\n  const layer = new TileLayer();\n  const source = new TileJSON({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  const key = source.on('change', function () {\n    const state = source.getState();\n\n    if (state === 'ready') {\n      unByKey(key);\n      const tileJSONDoc =\n      /** @type {Object} */\n      source.getTileJSON();\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const tileGrid = source.getTileGrid();\n      const tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22; // Only works when using ES modules\n\n      source.tileGrid = new TileGrid({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: createXYZ({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function (tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      const bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n\n    const img =\n    /** @type {import(\"ol/ImageTile\").default} */\n    tile.getImage();\n    /** @type {HTMLImageElement} */\n\n    img.src = src;\n  });\n  return layer;\n}\n\nconst geoJsonFormat = new GeoJSON();\n\nfunction setupGeoJSONLayer(glSource, path) {\n  const data = glSource.data;\n  let features, geoJsonUrl;\n\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {\n      featureProjection: 'EPSG:3857'\n    });\n  }\n\n  return new VectorLayer({\n    source: new VectorSource({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\n\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n  const zoom = view.getZoom();\n  const opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n  layer.setOpacity(opacity);\n}\n\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  const promises = [];\n  let view = map.getView();\n\n  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new View({\n      maxResolution: defaultResolutions[0]\n    });\n    map.setView(view);\n  }\n\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter(fromLonLat(glStyle.center));\n  }\n\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n    }\n  }\n\n  const glLayers = glStyle.layers;\n  let layerIds = [];\n  let glLayer, glSource, glSourceId, id, layer, url;\n\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    glLayer = glLayers[i];\n    const type = glLayer.type;\n\n    if (type == 'heatmap' || type == 'fill-extrusion' || type == 'hillshade') {//FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref); // this technique assumes gl layers will be in a particular order\n\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n\n        if (url && path && url.startsWith('.')) {\n          url = path + url;\n        }\n\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, accessToken, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          view.on('change:resolution', updateRasterLayerProperties.bind(this, glLayer, layer, view));\n          updateRasterLayerProperties(glLayer, layer, view);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n\n        glSourceId = id;\n\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n\n      layerIds.push(glLayer.id);\n    }\n  }\n\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\n\n\nexport default function olms(map, style) {\n  let accessToken, baseUrl, host, path, promise;\n  accessToken = baseUrl = host = path = '';\n\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  if (typeof style === 'string') {\n    const parts = style.match(spriteRegEx);\n\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n\n    promise = new Promise(function (resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        return response.json();\n      }).then(function (glStyle) {\n        const a =\n        /** @type {HTMLAnchorElement} */\n        document.createElement('A');\n        a.href = style;\n        const href = a.href;\n        path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n        host = href.substr(0, href.indexOf(path));\n        processStyle(glStyle, map, baseUrl, host, path, accessToken).then(function () {\n          resolve(map);\n        }).catch(reject);\n      }).catch(function (err) {\n        reject(new Error(`Could not load ${style}: ${err.message}`));\n      });\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      processStyle(style, map).then(function () {\n        resolve(map);\n      }).catch(reject);\n    });\n  }\n\n  return promise;\n}\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\n\nexport function apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  setTimeout(function () {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n/**\n * @private\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n */\n\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  let minZoom = 24;\n  let maxZoom = 0;\n  const glLayers = glStyle.layers;\n\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    const glLayer = glLayers[i];\n\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    const setStyle = function () {\n      const source = layer.getSource();\n\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n\n      if (typeof source.getTileGrid === 'function') {\n        const tileGrid = source.getTileGrid();\n\n        if (tileGrid) {\n          const sourceMinZoom = tileGrid.getMinZoom();\n\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle(\n        /** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */\n        layer, glStyle, layerIds, path).then(function () {\n          layer.setVisible(true);\n          resolve();\n        }, function (e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n\n    layer.set('mapbox-layers', layerIds);\n\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\n\n\nexport function getLayer(map, layerId) {\n  const layers = map.getLayers().getArray();\n\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const mapboxLayers = layers[i].get('mapbox-layers');\n\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return (\n        /** @type {Layer} */\n        layers[i]\n      );\n    }\n  }\n}\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\n\nexport function getLayers(map, sourceId) {\n  const result = [];\n  const layers = map.getLayers().getArray();\n\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(\n      /** @type {Layer} */\n      layers[i]);\n    }\n  }\n\n  return result;\n}\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\n\nexport function getSource(map, sourceId) {\n  const layers = map.getLayers().getArray();\n\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const source =\n    /** @type {Layer} */\n    layers[i].getSource();\n\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\nexport { finalizeLayer as _finalizeLayer, getFonts as _getFonts };","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ol-mapbox-style/index.js"],"names":["mb2css","applyStyleFunction","getValue","googleFonts","fromLonLat","createXYZ","TileGrid","Map","View","GeoJSON","MVT","unByKey","TileLayer","VectorLayer","VectorTileLayer","TileJSON","VectorSource","VectorTileSource","Color","defaultResolutions","tilejsonCache","fontFamilyRegEx","stripQuotesRegEx","loadedFontFamilies","hasFontFamily","family","styleSheets","document","i","ii","length","styleSheet","cssRules","rules","j","jj","cssRule","type","match","cssText","replace","e","processedFontFamilies","googleFamilies","getNames","getFonts","fonts","fontsKey","toString","googleFontDescriptions","map","font","parts","split","slice","join","googleFontDescription","indexOf","fontUrl","querySelector","markup","createElement","href","rel","head","appendChild","spriteRegEx","withPath","url","path","startsWith","toSpriteUrl","extension","applyStyle","layer","glStyle","source","resolutions","Promise","resolve","reject","JSON","parse","version","Error","spriteScale","spriteData","spriteImageUrl","style","onChange","sprite","getStyle","setStyle","window","devicePixelRatio","sizeFactor","spriteUrl","fetch","credentials","then","response","ok","json","statusText","spritesJson","undefined","Object","keys","catch","err","message","emptyObj","setBackground","background","updateStyle","element","getTargetElement","layout","paint","id","zoom","getView","getZoom","bg","backgroundColor","opacity","visibility","on","applyBackground","layers","some","l","getSourceIdByRef","ref","sourceId","extentFromTileJSON","tileJSON","bounds","ll","tr","setupVectorLayer","glSource","accessToken","assign","mapid","tiles","host","declutter","visible","cacheKey","stringify","tilejson","key","state","getState","tileJSONDoc","getTileJSON","Array","isArray","tile","tileGrid","getTileGrid","extent","minZoom","minzoom","maxZoom","maxzoom","get","attributions","getAttributions","format","origin","getOrigin","getExtent","tileSize","urls","set","setSource","changed","setupRasterLayer","transition","crossOrigin","getResolutions","setTileLoadFunction","src","bbox","getTileCoordExtent","getTileCoord","img","getImage","geoJsonFormat","setupGeoJSONLayer","data","features","geoJsonUrl","readFeatures","featureProjection","attribution","updateRasterLayerProperties","glLayer","view","setOpacity","processStyle","baseUrl","promises","isDef","getRotation","maxResolution","setView","getCenter","setCenter","center","setResolution","Math","pow","fit","getProjection","nearest","size","getSize","glLayers","layerIds","glSourceId","push","finalizeLayer","sources","setVisible","bind","all","olms","promise","HTMLElement","target","a","pathname","substr","apply","setTimeout","min","max","getSource","sourceMinZoom","getMinZoom","setMaxResolution","getResolution","setMinResolution","getLayers","getArray","addLayer","once","getLayer","layerId","mapboxLayers","result","_finalizeLayer","_getFonts"],"mappings":"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","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\nimport mb2css from 'mapbox-to-css-font';\nimport applyStyleFunction, {getValue} from './stylefunction';\nimport googleFonts from 'webfont-matcher/lib/fonts/google';\nimport {fromLonLat} from 'ol/proj';\nimport {createXYZ} from 'ol/tilegrid';\nimport TileGrid from 'ol/tilegrid/TileGrid';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport MVT from 'ol/format/MVT';\nimport {unByKey} from 'ol/Observable';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorTileLayer from 'ol/layer/VectorTile';\nimport TileJSON from 'ol/source/TileJSON';\nimport VectorSource from 'ol/source/Vector';\nimport VectorTileSource from 'ol/source/VectorTile';\nimport {Color} from '@mapbox/mapbox-gl-style-spec';\nimport {defaultResolutions} from './util';\n\n/**\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/PluggableMap\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\n\nconst tilejsonCache = {};\n\nconst fontFamilyRegEx = /font-family: ?([^;]*);/;\nconst stripQuotesRegEx = /(\"|')/g;\nlet loadedFontFamilies;\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    const styleSheets = document.styleSheets;\n    for (let i = 0, ii = styleSheets.length; i < ii; ++i) {\n      const styleSheet = /** @type {CSSStyleSheet} */ (styleSheets[i]);\n      try {\n        const cssRules = styleSheet.rules || styleSheet.cssRules;\n        if (cssRules) {\n          for (let j = 0, jj = cssRules.length; j < jj; ++j) {\n            const cssRule = cssRules[j];\n            if (cssRule.type == 5) {\n              const match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // empty catch block\n      }\n    }\n  }\n  return family in loadedFontFamilies;\n}\n\nconst processedFontFamilies = {};\nconst googleFamilies = googleFonts.getNames();\n\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\nfunction getFonts(fonts) {\n  const fontsKey = fonts.toString();\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n  const googleFontDescriptions = fonts.map(function(font) {\n    const parts = mb2css(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n  for (let i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    const googleFontDescription = googleFontDescriptions[i];\n    const family = googleFontDescription[0];\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      const fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        const markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\n\nconst spriteRegEx = /^(.*)(\\?.*)$/;\n\nfunction withPath(url, path) {\n  if (path && url.startsWith('.')) {\n    url = path + url;\n  }\n  return url;\n}\n\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  const parts = url.match(spriteRegEx);\n  return parts ?\n    parts[1] + extension + (parts.length > 2 ? parts[2] : '') :\n    url + extension;\n}\n\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function(resolve, reject) {\n\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n    if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n\n    let spriteScale, spriteData, spriteImageUrl, style;\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n        if (!layer.getStyle()) {\n          reject(new Error(`Nothing to show for source [${source}]`));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      const sizeFactor = spriteScale == 0.5 ? '@2x' : '';\n      let spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');\n\n      fetch(spriteUrl, {credentials: 'same-origin'})\n        .then(function(response) {\n          if (!response.ok && (sizeFactor !== '')) {\n            spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');\n            return fetch(spriteUrl, {credentials: 'same-origin'});\n          } else {\n            return response;\n          }\n        })\n        .then(function(response) {\n          if (response.ok) {\n            return response.json();\n          } else {\n            reject(new Error(`Problem fetching sprite from ${spriteUrl}: ${response.statusText}`));\n          }\n        })\n        .then(function(spritesJson) {\n          if ((spritesJson === undefined) || (Object.keys(spritesJson).length === 0)) {\n            return reject(new Error('No sprites found.'));\n          }\n          spriteData = spritesJson;\n          spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');\n          onChange();\n        })\n        .catch(function(err) {\n          reject(new Error(`Sprites cannot be loaded: ${spriteUrl}: ${err.message}`));\n        });\n    } else {\n      onChange();\n    }\n\n  });\n}\n\nconst emptyObj = {};\n\nfunction setBackground(map, layer) {\n  const background = {\n    type: layer.type\n  };\n  function updateStyle() {\n    const element = map.getTargetElement();\n    if (!element) {\n      return;\n    }\n    const layout = layer.layout || {};\n    const paint = layer.paint || {};\n    background['paint'] = paint;\n    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n    const zoom = map.getView().getZoom();\n    if (paint['background-color'] !== undefined) {\n      const bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n      element.style.backgroundColor = Color.parse(bg).toString();\n    }\n    if (paint['background-opacity'] !== undefined) {\n      element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n    }\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.opacity = '';\n    }\n  }\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\nexport function applyBackground(map, glStyle) {\n  glStyle.layers.some(function(l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\n\nfunction getSourceIdByRef(layers, ref) {\n  let sourceId;\n  layers.some(function(layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\n\nfunction extentFromTileJSON(tileJSON) {\n  const bounds = tileJSON.bounds;\n  if (bounds) {\n    const ll = fromLonLat([bounds[0], bounds[1]]);\n    const tr = fromLonLat([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\n\nfunction setupVectorLayer(glSource, accessToken, url) {\n  glSource = Object.assign({}, glSource);\n  if (url) {\n    if (url.indexOf('mapbox://') == 0) {\n      const mapid = url.replace('mapbox://', '');\n      glSource.tiles = ['a', 'b', 'c', 'd'].map(function(host) {\n        return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid +\n            '/{z}/{x}/{y}.' +\n            (glSource.type == 'vector' ? 'vector.pbf' : 'png') +\n            accessToken;\n      });\n    }\n  }\n  const layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  const cacheKey = JSON.stringify(glSource);\n  let tilejson = tilejsonCache[cacheKey];\n  if (!tilejson) {\n    tilejson = tilejsonCache[cacheKey] = new TileJSON({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n  }\n  const key = tilejson.on('change', function() {\n    const state = tilejson.getState();\n    if (state === 'ready') {\n      const tileJSONDoc = tilejson.getTileJSON();\n      const tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n      if (glSource.url) {\n        for (let i = 0, ii = tiles.length; i < ii; ++i) {\n          const tile = tiles[i];\n          if (tile.indexOf('http') != 0) {\n            tiles[i] = glSource.url + tile;\n          }\n        }\n      }\n      const tileGrid = tilejson.getTileGrid();\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22;\n      let source = tilejson.get('ol-source');\n      if (source === undefined) {\n        source = new VectorTileSource({\n          attributions: tilejson.getAttributions(),\n          format: new MVT(),\n          tileGrid: new TileGrid({\n            origin: tileGrid.getOrigin(0),\n            extent: extent || tileGrid.getExtent(),\n            minZoom: minZoom,\n            resolutions: defaultResolutions.slice(0, maxZoom + 1),\n            tileSize: 512\n          }),\n          urls: tiles\n        });\n        tilejson.set('ol-source', source);\n      }\n      unByKey(key);\n      layer.setSource(source);\n    } else if (state === 'error') {\n      tilejson.set('ol-source', null);\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  if (tilejson.getState() === 'ready') {\n    tilejson.changed();\n  }\n  return layer;\n}\n\nfunction setupRasterLayer(glSource, url) {\n  const layer = new TileLayer();\n  const source = new TileJSON({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  const key = source.on('change', function() {\n    const state = source.getState();\n    if (state === 'ready') {\n      unByKey(key);\n      const tileJSONDoc = /** @type {Object} */ (source.getTileJSON());\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const tileGrid = source.getTileGrid();\n      const tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22;\n      // Only works when using ES modules\n      source.tileGrid = new TileGrid({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: createXYZ({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function(tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      const bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n    const img = /** @type {import(\"ol/ImageTile\").default} */ (tile).getImage();\n    /** @type {HTMLImageElement} */ (img).src = src;\n  });\n  return layer;\n}\n\nconst geoJsonFormat = new GeoJSON();\nfunction setupGeoJSONLayer(glSource, path) {\n  const data = glSource.data;\n  let features, geoJsonUrl;\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {featureProjection: 'EPSG:3857'});\n  }\n  return new VectorLayer({\n    source: new VectorSource({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\n\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n  const zoom = view.getZoom();\n  const opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n  layer.setOpacity(opacity);\n}\n\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  const promises = [];\n  let view = map.getView();\n  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new View({\n      maxResolution: defaultResolutions[0]\n    });\n    map.setView(view);\n  }\n\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter(fromLonLat(glStyle.center));\n  }\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? (host + path) : '') + glStyle.sprite + accessToken;\n    }\n  }\n\n  const glLayers = glStyle.layers;\n  let layerIds = [];\n\n  let glLayer, glSource, glSourceId, id, layer, url;\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    glLayer = glLayers[i];\n    const type = glLayer.type;\n    if (type == 'heatmap' || type == 'fill-extrusion' || type == 'hillshade') {\n      //FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      // this technique assumes gl layers will be in a particular order\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n        if (url && path && url.startsWith('.')) {\n          url = path + url;\n        }\n\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, accessToken, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          view.on('change:resolution', updateRasterLayerProperties.bind(this, glLayer, layer, view));\n          updateRasterLayerProperties(glLayer, layer, view);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n        glSourceId = id;\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n      layerIds.push(glLayer.id);\n    }\n  }\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\nexport default function olms(map, style) {\n\n  let accessToken, baseUrl, host, path, promise;\n  accessToken = baseUrl = host = path = '';\n\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  if (typeof style === 'string') {\n    const parts = style.match(spriteRegEx);\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n    promise = new Promise(function(resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      })\n        .then(function(response) {\n          return response.json();\n        })\n        .then(function(glStyle) {\n          const a = /** @type {HTMLAnchorElement} */ (document.createElement('A'));\n          a.href = style;\n          const href = a.href;\n          path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n          host = href.substr(0, href.indexOf(path));\n\n          processStyle(glStyle, map, baseUrl, host, path, accessToken)\n            .then(function() {\n              resolve(map);\n            })\n            .catch(reject);\n        })\n        .catch(function(err) {\n          reject(new Error(`Could not load ${style}: ${err.message}`));\n        });\n    });\n  } else {\n    promise = new Promise(function(resolve, reject) {\n      processStyle(style, map)\n        .then(function() {\n          resolve(map);\n        })\n        .catch(reject);\n    });\n  }\n\n  return promise;\n}\n\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\nexport function apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n  setTimeout(function() {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n\n\n/**\n * @private\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n */\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  let minZoom = 24;\n  let maxZoom = 0;\n  const glLayers = glStyle.layers;\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    const glLayer = glLayers[i];\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n  return new Promise(function(resolve, reject) {\n    const setStyle = function() {\n      const source = layer.getSource();\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n      if (typeof source.getTileGrid === 'function') {\n        const tileGrid = source.getTileGrid();\n        if (tileGrid) {\n          const sourceMinZoom = tileGrid.getMinZoom();\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle(/** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */ (layer), glStyle, layerIds, path).then(function() {\n          layer.setVisible(true);\n          resolve();\n        }, function(e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n\n    layer.set('mapbox-layers', layerIds);\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n\n\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nexport function getLayer(map, layerId) {\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const mapboxLayers = layers[i].get('mapbox-layers');\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return /** @type {Layer} */ (layers[i]);\n    }\n  }\n}\n\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nexport function getLayers(map, sourceId) {\n  const result = [];\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(/** @type {Layer} */ (layers[i]));\n    }\n  }\n  return result;\n}\n\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nexport function getSource(map, sourceId) {\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const source = /** @type {Layer} */ (layers[i]).getSource();\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\n\nexport {\n  finalizeLayer as _finalizeLayer,\n  getFonts as _getFonts\n};\n"]},"metadata":{},"sourceType":"module"}