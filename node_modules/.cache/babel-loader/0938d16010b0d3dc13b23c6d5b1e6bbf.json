{"ast":null,"code":"/**\n * @module ol/reproj/Image\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport { inherits } from '../util.js';\nimport ImageBase from '../ImageBase.js';\nimport ImageState from '../ImageState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getCenter, getIntersection, getHeight, getWidth } from '../extent.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from '../reproj/Triangulation.js';\n/**\n * @typedef {function(module:ol/extent~Extent, number, number) : module:ol/ImageBase} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n *\n * @constructor\n * @extends {module:ol/ImageBase}\n * @param {module:ol/proj/Projection} sourceProj Source projection (of the data).\n * @param {module:ol/proj/Projection} targetProj Target projection.\n * @param {module:ol/extent~Extent} targetExtent Target extent.\n * @param {number} targetResolution Target resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {module:ol/reproj/Image~FunctionType} getImageFunction\n *     Function returning source images (extent, resolution, pixelRatio).\n */\n\nconst ReprojImage = function (sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {\n  /**\n   * @private\n   * @type {module:ol/proj/Projection}\n   */\n  this.targetProj_ = targetProj;\n  /**\n   * @private\n   * @type {module:ol/extent~Extent}\n   */\n\n  this.maxSourceExtent_ = sourceProj.getExtent();\n  const maxTargetExtent = targetProj.getExtent();\n  const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n  const targetCenter = getCenter(limitedTargetExtent);\n  const sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n  const errorThresholdInPixels = ERROR_THRESHOLD;\n  /**\n   * @private\n   * @type {!module:ol/reproj/Triangulation}\n   */\n\n  this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, this.maxSourceExtent_, sourceResolution * errorThresholdInPixels);\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.targetResolution_ = targetResolution;\n  /**\n   * @private\n   * @type {module:ol/extent~Extent}\n   */\n\n  this.targetExtent_ = targetExtent;\n  const sourceExtent = this.triangulation_.calculateSourceExtent();\n  /**\n   * @private\n   * @type {module:ol/ImageBase}\n   */\n\n  this.sourceImage_ = getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.sourcePixelRatio_ = this.sourceImage_ ? this.sourceImage_.getPixelRatio() : 1;\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = null;\n  /**\n   * @private\n   * @type {?module:ol/events~EventsKey}\n   */\n\n  this.sourceListenerKey_ = null;\n  let state = ImageState.LOADED;\n\n  if (this.sourceImage_) {\n    state = ImageState.IDLE;\n  }\n\n  ImageBase.call(this, targetExtent, targetResolution, this.sourcePixelRatio_, state);\n};\n\ninherits(ReprojImage, ImageBase);\n/**\n * @inheritDoc\n */\n\nReprojImage.prototype.disposeInternal = function () {\n  if (this.state == ImageState.LOADING) {\n    this.unlistenSource_();\n  }\n\n  ImageBase.prototype.disposeInternal.call(this);\n};\n/**\n * @inheritDoc\n */\n\n\nReprojImage.prototype.getImage = function () {\n  return this.canvas_;\n};\n/**\n * @return {module:ol/proj/Projection} Projection.\n */\n\n\nReprojImage.prototype.getProjection = function () {\n  return this.targetProj_;\n};\n/**\n * @private\n */\n\n\nReprojImage.prototype.reproject_ = function () {\n  const sourceState = this.sourceImage_.getState();\n\n  if (sourceState == ImageState.LOADED) {\n    const width = getWidth(this.targetExtent_) / this.targetResolution_;\n    const height = getHeight(this.targetExtent_) / this.targetResolution_;\n    this.canvas_ = renderReprojected(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{\n      extent: this.sourceImage_.getExtent(),\n      image: this.sourceImage_.getImage()\n    }], 0);\n  }\n\n  this.state = sourceState;\n  this.changed();\n};\n/**\n * @inheritDoc\n */\n\n\nReprojImage.prototype.load = function () {\n  if (this.state == ImageState.IDLE) {\n    this.state = ImageState.LOADING;\n    this.changed();\n    const sourceState = this.sourceImage_.getState();\n\n    if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n      this.reproject_();\n    } else {\n      this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function (e) {\n        const sourceState = this.sourceImage_.getState();\n\n        if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n          this.unlistenSource_();\n          this.reproject_();\n        }\n      }, this);\n      this.sourceImage_.load();\n    }\n  }\n};\n/**\n * @private\n */\n\n\nReprojImage.prototype.unlistenSource_ = function () {\n  unlistenByKey(\n  /** @type {!module:ol/events~EventsKey} */\n  this.sourceListenerKey_);\n  this.sourceListenerKey_ = null;\n};\n\nexport default ReprojImage;","map":null,"metadata":{},"sourceType":"module"}