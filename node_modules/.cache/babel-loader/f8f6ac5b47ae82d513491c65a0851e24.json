{"ast":null,"code":"/**\n * @module ol/interaction/PinchRotate\n */\nimport ViewHint from '../ViewHint.js';\nimport { FALSE } from '../functions.js';\nimport { rotate, rotateWithoutConstraints } from './Interaction.js';\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { disable } from '../rotationconstraint.js';\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\n\nvar PinchRotate =\n/*@__PURE__*/\nfunction (PointerInteraction) {\n  function PinchRotate(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    PointerInteraction.call(this, pointerOptions);\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n\n    this.anchor_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.lastAngle_ = undefined;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.rotating_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.rotationDelta_ = 0.0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  if (PointerInteraction) PinchRotate.__proto__ = PointerInteraction;\n  PinchRotate.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  PinchRotate.prototype.constructor = PinchRotate;\n  /**\n   * @inheritDoc\n   */\n\n  PinchRotate.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n    var rotationDelta = 0.0;\n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1]; // angle between touches\n\n    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n\n    if (this.lastAngle_ !== undefined) {\n      var delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n\n      rotationDelta = delta;\n    }\n\n    this.lastAngle_ = angle;\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n\n    if (view.getConstraints().rotation === disable) {\n      return;\n    } // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n\n\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid = centroidFromPointers(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixel(centroid); // rotate\n\n    if (this.rotating_) {\n      var rotation = view.getRotation();\n      map.render();\n      rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PinchRotate.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.setHint(ViewHint.INTERACTING, -1);\n\n      if (this.rotating_) {\n        var rotation = view.getRotation();\n        rotate(view, rotation, this.anchor_, this.duration_);\n      }\n\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PinchRotate.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n\n      if (!this.handlingDownUpSequence) {\n        map.getView().setHint(ViewHint.INTERACTING, 1);\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return PinchRotate;\n}(PointerInteraction);\n\nexport default PinchRotate;","map":{"version":3,"sources":["../../../src/ol/interaction/PinchRotate.js"],"names":["const","super","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/interaction/PinchRotate\n */\nimport ViewHint from '../ViewHint.js';\nimport {FALSE} from '../functions.js';\nimport {rotate, rotateWithoutConstraints} from './Interaction.js';\nimport PointerInteraction, {centroid as centroidFromPointers} from './Pointer.js';\nimport {disable} from '../rotationconstraint.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchRotate extends PointerInteraction {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(\n      touch1.clientY - touch0.clientY,\n      touch1.clientX - touch0.clientX);\n\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ &&\n          Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    const viewportPosition = map.getViewport().getBoundingClientRect();\n    const centroid = centroidFromPointers(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixel(centroid);\n\n    // rotate\n    if (this.rotating_) {\n      const rotation = view.getRotation();\n      map.render();\n      rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.setHint(ViewHint.INTERACTING, -1);\n      if (this.rotating_) {\n        const rotation = view.getRotation();\n        rotate(view, rotation, this.anchor_, this.duration_);\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().setHint(ViewHint.INTERACTING, 1);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nexport default PinchRotate;\n"]},"metadata":{},"sourceType":"module"}