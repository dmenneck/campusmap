{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Point = _interopRequireDefault(require(\"ol/geom/Point\"));\n\nvar _LineString = _interopRequireDefault(require(\"ol/geom/LineString\"));\n\nvar _Observable = require(\"ol/Observable\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * This class provides some static methods which might be helpful when working\n * with digitize functions to animate features.\n *\n * @class AnimateUtil\n */\n\n\nvar AnimateUtil =\n/*#__PURE__*/\nfunction () {\n  function AnimateUtil() {\n    _classCallCheck(this, AnimateUtil);\n  }\n\n  _createClass(AnimateUtil, null, [{\n    key: \"moveFeature\",\n\n    /**\n     * Moves / translates an `OlFeature` to the given `pixel` delta in\n     * in the end with given `duration` in ms, using the given style.\n     *\n     * @param {ol.Map} map An OlMap.\n     * @param {ol.Feature} featureToMove The feature to move.\n     * @param {number} duration The duration in ms for the moving to complete.\n     * @param {Array<number>} pixel Delta of pixels to move the feature.\n     * @param {ol.style.Style} style The style to use when moving the feature.\n     *\n     * @return {string} A listener key from a postcompose event.\n     */\n    value: function moveFeature(map, featureToMove, duration, pixel, style) {\n      return new Promise(function (resolve) {\n        var listenerKey;\n        var geometry = featureToMove.getGeometry();\n        var start = new Date().getTime();\n        var resolution = map.getView().getResolution();\n        var totalDisplacement = pixel * resolution;\n        var expectedFrames = duration / 1000 * 60;\n        var actualFrames = 0;\n        var deltaX = totalDisplacement / expectedFrames;\n        var deltaY = totalDisplacement / expectedFrames;\n        /**\n         * Moves the feature `pixel` right and `pixel` up.\n         * @ignore\n         */\n\n        var animate = function animate(event) {\n          var vectorContext = event.vectorContext;\n          var frameState = event.frameState;\n          var elapsed = frameState.time - start;\n          geometry.translate(deltaX, deltaY);\n\n          if (vectorContext.setFillStrokeStyle && vectorContext.setImageStyle && vectorContext.drawPointGeometry) {\n            if (style) {\n              vectorContext.setFillStrokeStyle(style.getFill(), style.getStroke());\n              vectorContext.setImageStyle(style.getImage());\n            }\n\n            if (geometry instanceof _Point[\"default\"]) {\n              vectorContext.drawPointGeometry(geometry, null);\n            } else if (geometry instanceof _LineString[\"default\"]) {\n              vectorContext.drawLineStringGeometry(geometry, null);\n            } else {\n              vectorContext.drawPolygonGeometry(geometry, null);\n            }\n          } else {\n            if (style) {\n              vectorContext.setStyle(style);\n            }\n\n            vectorContext.drawGeometry(geometry);\n          }\n\n          if (elapsed > duration || actualFrames >= expectedFrames) {\n            (0, _Observable.unByKey)(listenerKey);\n            resolve(featureToMove);\n          } // tell OpenLayers to continue postcompose animation\n\n\n          frameState.animate = true;\n          actualFrames++;\n        };\n\n        listenerKey = map.on('postcompose', animate);\n        map.render();\n      });\n    }\n  }]);\n\n  return AnimateUtil;\n}();\n\nvar _default = AnimateUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/@terrestris/react-geo/node_modules/@terrestris/ol-util/dist/AnimateUtil/AnimateUtil.js"],"names":["Object","defineProperty","exports","value","_Point","_interopRequireDefault","require","_LineString","_Observable","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","AnimateUtil","moveFeature","map","featureToMove","duration","pixel","style","Promise","resolve","listenerKey","geometry","getGeometry","start","Date","getTime","resolution","getView","getResolution","totalDisplacement","expectedFrames","actualFrames","deltaX","deltaY","animate","event","vectorContext","frameState","elapsed","time","translate","setFillStrokeStyle","setImageStyle","drawPointGeometry","getFill","getStroke","getImage","drawLineStringGeometry","drawPolygonGeometry","setStyle","drawGeometry","unByKey","on","render","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Point = _interopRequireDefault(require(\"ol/geom/Point\"));\n\nvar _LineString = _interopRequireDefault(require(\"ol/geom/LineString\"));\n\nvar _Observable = require(\"ol/Observable\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * This class provides some static methods which might be helpful when working\n * with digitize functions to animate features.\n *\n * @class AnimateUtil\n */\nvar AnimateUtil =\n/*#__PURE__*/\nfunction () {\n  function AnimateUtil() {\n    _classCallCheck(this, AnimateUtil);\n  }\n\n  _createClass(AnimateUtil, null, [{\n    key: \"moveFeature\",\n\n    /**\n     * Moves / translates an `OlFeature` to the given `pixel` delta in\n     * in the end with given `duration` in ms, using the given style.\n     *\n     * @param {ol.Map} map An OlMap.\n     * @param {ol.Feature} featureToMove The feature to move.\n     * @param {number} duration The duration in ms for the moving to complete.\n     * @param {Array<number>} pixel Delta of pixels to move the feature.\n     * @param {ol.style.Style} style The style to use when moving the feature.\n     *\n     * @return {string} A listener key from a postcompose event.\n     */\n    value: function moveFeature(map, featureToMove, duration, pixel, style) {\n      return new Promise(function (resolve) {\n        var listenerKey;\n        var geometry = featureToMove.getGeometry();\n        var start = new Date().getTime();\n        var resolution = map.getView().getResolution();\n        var totalDisplacement = pixel * resolution;\n        var expectedFrames = duration / 1000 * 60;\n        var actualFrames = 0;\n        var deltaX = totalDisplacement / expectedFrames;\n        var deltaY = totalDisplacement / expectedFrames;\n        /**\n         * Moves the feature `pixel` right and `pixel` up.\n         * @ignore\n         */\n\n        var animate = function animate(event) {\n          var vectorContext = event.vectorContext;\n          var frameState = event.frameState;\n          var elapsed = frameState.time - start;\n          geometry.translate(deltaX, deltaY);\n\n          if (vectorContext.setFillStrokeStyle && vectorContext.setImageStyle && vectorContext.drawPointGeometry) {\n            if (style) {\n              vectorContext.setFillStrokeStyle(style.getFill(), style.getStroke());\n              vectorContext.setImageStyle(style.getImage());\n            }\n\n            if (geometry instanceof _Point[\"default\"]) {\n              vectorContext.drawPointGeometry(geometry, null);\n            } else if (geometry instanceof _LineString[\"default\"]) {\n              vectorContext.drawLineStringGeometry(geometry, null);\n            } else {\n              vectorContext.drawPolygonGeometry(geometry, null);\n            }\n          } else {\n            if (style) {\n              vectorContext.setStyle(style);\n            }\n\n            vectorContext.drawGeometry(geometry);\n          }\n\n          if (elapsed > duration || actualFrames >= expectedFrames) {\n            (0, _Observable.unByKey)(listenerKey);\n            resolve(featureToMove);\n          } // tell OpenLayers to continue postcompose animation\n\n\n          frameState.animate = true;\n          actualFrames++;\n        };\n\n        listenerKey = map.on('postcompose', animate);\n        map.render();\n      });\n    }\n  }]);\n\n  return AnimateUtil;\n}();\n\nvar _default = AnimateUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}