{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar columnUtils_1 = require(\"./columnUtils\");\n\nvar columnGroup_1 = require(\"../entities/columnGroup\");\n\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\n\nvar context_2 = require(\"../context/context\");\n\nvar utils_1 = require(\"../utils\"); // takes in a list of columns, as specified by the column definitions, and returns column groups\n\n\nvar DisplayedGroupCreator =\n/** @class */\nfunction () {\n  function DisplayedGroupCreator() {}\n\n  DisplayedGroupCreator.prototype.createDisplayedGroups = function ( // all displayed columns sorted - this is the columns the grid should show\n  sortedVisibleColumns, // the tree of columns, as provided by the users, used to know what groups columns roll up into\n  balancedColumnTree, // creates unique id's for the group\n  groupInstanceIdCreator, // whether it's left, right or center col\n  pinned, // we try to reuse old groups if we can, to allow gui to do animation\n  oldDisplayedGroups) {\n    var _this = this;\n\n    var result = [];\n    var previousRealPath;\n    var previousOriginalPath;\n    var oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups); // go through each column, then do a bottom up comparison to the previous column, and start\n    // to share groups if they converge at any point.\n\n    sortedVisibleColumns.forEach(function (currentColumn) {\n      var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);\n\n      var currentRealPath = [];\n      var firstColumn = !previousOriginalPath;\n\n      for (var i = 0; i < currentOriginalPath.length; i++) {\n        if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {\n          // new group needed\n          var newGroup = _this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped, pinned);\n\n          currentRealPath[i] = newGroup; // if top level, add to result, otherwise add to parent\n\n          if (i == 0) {\n            result.push(newGroup);\n          } else {\n            currentRealPath[i - 1].addChild(newGroup);\n          }\n        } else {\n          // reuse old group\n          currentRealPath[i] = previousRealPath[i];\n        }\n      }\n\n      var noColumnGroups = currentRealPath.length === 0;\n\n      if (noColumnGroups) {\n        // if we are not grouping, then the result of the above is an empty\n        // path (no groups), and we just add the column to the root list.\n        result.push(currentColumn);\n      } else {\n        var leafGroup = utils_1._.last(currentRealPath);\n\n        leafGroup.addChild(currentColumn);\n      }\n\n      previousRealPath = currentRealPath;\n      previousOriginalPath = currentOriginalPath;\n    });\n    this.setupParentsIntoColumns(result, null);\n    return result;\n  };\n\n  DisplayedGroupCreator.prototype.createColumnGroup = function (originalGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {\n    var groupId = originalGroup.getGroupId();\n    var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);\n    var uniqueId = columnGroup_1.ColumnGroup.createUniqueId(groupId, instanceId);\n    var columnGroup = oldColumnsMapped[uniqueId]; // if the user is setting new colDefs, it is possible that the id's overlap, and we\n    // would have a false match from above. so we double check we are talking about the\n    // same original column group.\n\n    if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {\n      columnGroup = null;\n    }\n\n    if (utils_1._.exists(columnGroup)) {\n      // clean out the old column group here, as we will be adding children into it again\n      columnGroup.reset();\n    } else {\n      columnGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId, pinned);\n      this.context.wireBean(columnGroup);\n    }\n\n    return columnGroup;\n  }; // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup\n\n\n  DisplayedGroupCreator.prototype.mapOldGroupsById = function (displayedGroups) {\n    var result = {};\n\n    var recursive = function (columnsOrGroups) {\n      columnsOrGroups.forEach(function (columnOrGroup) {\n        if (columnOrGroup instanceof columnGroup_1.ColumnGroup) {\n          var columnGroup = columnOrGroup;\n          result[columnOrGroup.getUniqueId()] = columnGroup;\n          recursive(columnGroup.getChildren());\n        }\n      });\n    };\n\n    if (displayedGroups) {\n      recursive(displayedGroups);\n    }\n\n    return result;\n  };\n\n  DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {\n    var _this = this;\n\n    columnsOrGroups.forEach(function (columnsOrGroup) {\n      columnsOrGroup.setParent(parent);\n\n      if (columnsOrGroup instanceof columnGroup_1.ColumnGroup) {\n        var columnGroup = columnsOrGroup;\n\n        _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);\n      }\n    });\n  }; // private createFakePath(balancedColumnTree: OriginalColumnGroupChild[], column: Column): OriginalColumnGroup[] {\n  //     let fakePath: OriginalColumnGroup[] = [];\n  //     let currentChildren = balancedColumnTree;\n  //     // this while loop does search on the balanced tree, so our result is the right length\n  //     let index = 0;\n  //     while (currentChildren && currentChildren[0] && currentChildren[0] instanceof OriginalColumnGroup) {\n  //         // putting in a deterministic fake id, in case the API in the future needs to reference the col\n  //         let fakeGroup = new OriginalColumnGroup(null, 'FAKE_PATH_' + index, true);\n  //         this.context.wireBean(fakeGroup);\n  //\n  //         // fakePath.setChildren(children);\n  //\n  //         fakePath.push(fakeGroup);\n  //         currentChildren = (<OriginalColumnGroup>currentChildren[0]).getChildren();\n  //         index++;\n  //     }\n  //\n  //     fakePath.forEach( (fakePathGroup: OriginalColumnGroup, i: number) => {\n  //         let lastItemInList = i === fakePath.length-1;\n  //         let child = lastItemInList ? column : fakePath[i+1];\n  //         fakePathGroup.setChildren([child]);\n  //     });\n  //\n  //     return fakePath;\n  // }\n\n\n  DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {\n    var result = [];\n    var found = false;\n    recursePath(balancedColumnTree, 0); // it's possible we didn't find a path. this happens if the column is generated\n    // by the grid (auto-group), in that the definition didn't come from the client. in this case,\n    // we create a fake original path.\n\n    if (found) {\n      return result;\n    } else {\n      console.warn('could not get path');\n      return null; // return this.createFakePath(balancedColumnTree, column);\n    }\n\n    function recursePath(balancedColumnTree, dept) {\n      for (var i = 0; i < balancedColumnTree.length; i++) {\n        if (found) {\n          // quit the search, so 'result' is kept with the found result\n          return;\n        }\n\n        var node = balancedColumnTree[i];\n\n        if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n          var nextNode = node;\n          recursePath(nextNode.getChildren(), dept + 1);\n          result[dept] = node;\n        } else {\n          if (node === column) {\n            found = true;\n          }\n        }\n      }\n    }\n  };\n\n  __decorate([context_1.Autowired('columnUtils'), __metadata(\"design:type\", columnUtils_1.ColumnUtils)], DisplayedGroupCreator.prototype, \"columnUtils\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_2.Context)], DisplayedGroupCreator.prototype, \"context\", void 0);\n\n  DisplayedGroupCreator = __decorate([context_2.Bean('displayedGroupCreator')], DisplayedGroupCreator);\n  return DisplayedGroupCreator;\n}();\n\nexports.DisplayedGroupCreator = DisplayedGroupCreator;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/columnController/displayedGroupCreator.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","exports","value","context_1","require","columnUtils_1","columnGroup_1","originalColumnGroup_1","context_2","utils_1","DisplayedGroupCreator","prototype","createDisplayedGroups","sortedVisibleColumns","balancedColumnTree","groupInstanceIdCreator","pinned","oldDisplayedGroups","_this","result","previousRealPath","previousOriginalPath","oldColumnsMapped","mapOldGroupsById","forEach","currentColumn","currentOriginalPath","getOriginalPathForColumn","currentRealPath","firstColumn","newGroup","createColumnGroup","push","addChild","noColumnGroups","leafGroup","_","last","setupParentsIntoColumns","originalGroup","groupId","getGroupId","instanceId","getInstanceIdForKey","uniqueId","ColumnGroup","createUniqueId","columnGroup","getOriginalColumnGroup","exists","reset","context","wireBean","displayedGroups","recursive","columnsOrGroups","columnOrGroup","getUniqueId","getChildren","parent","columnsOrGroup","setParent","column","found","recursePath","console","warn","dept","node","OriginalColumnGroup","nextNode","Autowired","ColumnUtils","Context","Bean"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"../context/context\");\nvar columnUtils_1 = require(\"./columnUtils\");\nvar columnGroup_1 = require(\"../entities/columnGroup\");\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\nvar context_2 = require(\"../context/context\");\nvar utils_1 = require(\"../utils\");\n// takes in a list of columns, as specified by the column definitions, and returns column groups\nvar DisplayedGroupCreator = /** @class */ (function () {\n    function DisplayedGroupCreator() {\n    }\n    DisplayedGroupCreator.prototype.createDisplayedGroups = function (\n    // all displayed columns sorted - this is the columns the grid should show\n    sortedVisibleColumns, \n    // the tree of columns, as provided by the users, used to know what groups columns roll up into\n    balancedColumnTree, \n    // creates unique id's for the group\n    groupInstanceIdCreator, \n    // whether it's left, right or center col\n    pinned, \n    // we try to reuse old groups if we can, to allow gui to do animation\n    oldDisplayedGroups) {\n        var _this = this;\n        var result = [];\n        var previousRealPath;\n        var previousOriginalPath;\n        var oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);\n        // go through each column, then do a bottom up comparison to the previous column, and start\n        // to share groups if they converge at any point.\n        sortedVisibleColumns.forEach(function (currentColumn) {\n            var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);\n            var currentRealPath = [];\n            var firstColumn = !previousOriginalPath;\n            for (var i = 0; i < currentOriginalPath.length; i++) {\n                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {\n                    // new group needed\n                    var newGroup = _this.createColumnGroup(currentOriginalPath[i], groupInstanceIdCreator, oldColumnsMapped, pinned);\n                    currentRealPath[i] = newGroup;\n                    // if top level, add to result, otherwise add to parent\n                    if (i == 0) {\n                        result.push(newGroup);\n                    }\n                    else {\n                        currentRealPath[i - 1].addChild(newGroup);\n                    }\n                }\n                else {\n                    // reuse old group\n                    currentRealPath[i] = previousRealPath[i];\n                }\n            }\n            var noColumnGroups = currentRealPath.length === 0;\n            if (noColumnGroups) {\n                // if we are not grouping, then the result of the above is an empty\n                // path (no groups), and we just add the column to the root list.\n                result.push(currentColumn);\n            }\n            else {\n                var leafGroup = utils_1._.last(currentRealPath);\n                leafGroup.addChild(currentColumn);\n            }\n            previousRealPath = currentRealPath;\n            previousOriginalPath = currentOriginalPath;\n        });\n        this.setupParentsIntoColumns(result, null);\n        return result;\n    };\n    DisplayedGroupCreator.prototype.createColumnGroup = function (originalGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {\n        var groupId = originalGroup.getGroupId();\n        var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);\n        var uniqueId = columnGroup_1.ColumnGroup.createUniqueId(groupId, instanceId);\n        var columnGroup = oldColumnsMapped[uniqueId];\n        // if the user is setting new colDefs, it is possible that the id's overlap, and we\n        // would have a false match from above. so we double check we are talking about the\n        // same original column group.\n        if (columnGroup && columnGroup.getOriginalColumnGroup() !== originalGroup) {\n            columnGroup = null;\n        }\n        if (utils_1._.exists(columnGroup)) {\n            // clean out the old column group here, as we will be adding children into it again\n            columnGroup.reset();\n        }\n        else {\n            columnGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId, pinned);\n            this.context.wireBean(columnGroup);\n        }\n        return columnGroup;\n    };\n    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup\n    DisplayedGroupCreator.prototype.mapOldGroupsById = function (displayedGroups) {\n        var result = {};\n        var recursive = function (columnsOrGroups) {\n            columnsOrGroups.forEach(function (columnOrGroup) {\n                if (columnOrGroup instanceof columnGroup_1.ColumnGroup) {\n                    var columnGroup = columnOrGroup;\n                    result[columnOrGroup.getUniqueId()] = columnGroup;\n                    recursive(columnGroup.getChildren());\n                }\n            });\n        };\n        if (displayedGroups) {\n            recursive(displayedGroups);\n        }\n        return result;\n    };\n    DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {\n        var _this = this;\n        columnsOrGroups.forEach(function (columnsOrGroup) {\n            columnsOrGroup.setParent(parent);\n            if (columnsOrGroup instanceof columnGroup_1.ColumnGroup) {\n                var columnGroup = columnsOrGroup;\n                _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);\n            }\n        });\n    };\n    // private createFakePath(balancedColumnTree: OriginalColumnGroupChild[], column: Column): OriginalColumnGroup[] {\n    //     let fakePath: OriginalColumnGroup[] = [];\n    //     let currentChildren = balancedColumnTree;\n    //     // this while loop does search on the balanced tree, so our result is the right length\n    //     let index = 0;\n    //     while (currentChildren && currentChildren[0] && currentChildren[0] instanceof OriginalColumnGroup) {\n    //         // putting in a deterministic fake id, in case the API in the future needs to reference the col\n    //         let fakeGroup = new OriginalColumnGroup(null, 'FAKE_PATH_' + index, true);\n    //         this.context.wireBean(fakeGroup);\n    //\n    //         // fakePath.setChildren(children);\n    //\n    //         fakePath.push(fakeGroup);\n    //         currentChildren = (<OriginalColumnGroup>currentChildren[0]).getChildren();\n    //         index++;\n    //     }\n    //\n    //     fakePath.forEach( (fakePathGroup: OriginalColumnGroup, i: number) => {\n    //         let lastItemInList = i === fakePath.length-1;\n    //         let child = lastItemInList ? column : fakePath[i+1];\n    //         fakePathGroup.setChildren([child]);\n    //     });\n    //\n    //     return fakePath;\n    // }\n    DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {\n        var result = [];\n        var found = false;\n        recursePath(balancedColumnTree, 0);\n        // it's possible we didn't find a path. this happens if the column is generated\n        // by the grid (auto-group), in that the definition didn't come from the client. in this case,\n        // we create a fake original path.\n        if (found) {\n            return result;\n        }\n        else {\n            console.warn('could not get path');\n            return null;\n            // return this.createFakePath(balancedColumnTree, column);\n        }\n        function recursePath(balancedColumnTree, dept) {\n            for (var i = 0; i < balancedColumnTree.length; i++) {\n                if (found) {\n                    // quit the search, so 'result' is kept with the found result\n                    return;\n                }\n                var node = balancedColumnTree[i];\n                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                    var nextNode = node;\n                    recursePath(nextNode.getChildren(), dept + 1);\n                    result[dept] = node;\n                }\n                else {\n                    if (node === column) {\n                        found = true;\n                    }\n                }\n            }\n        }\n    };\n    __decorate([\n        context_1.Autowired('columnUtils'),\n        __metadata(\"design:type\", columnUtils_1.ColumnUtils)\n    ], DisplayedGroupCreator.prototype, \"columnUtils\", void 0);\n    __decorate([\n        context_1.Autowired('context'),\n        __metadata(\"design:type\", context_2.Context)\n    ], DisplayedGroupCreator.prototype, \"context\", void 0);\n    DisplayedGroupCreator = __decorate([\n        context_2.Bean('displayedGroupCreator')\n    ], DisplayedGroupCreator);\n    return DisplayedGroupCreator;\n}());\nexports.DisplayedGroupCreator = DisplayedGroupCreator;\n"]},"metadata":{},"sourceType":"script"}