{"ast":null,"code":"/**\n * @module ol/geom/LineString\n */\nimport { inherits } from '../util.js';\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from '../geom/flat/closest.js';\nimport { deflateCoordinates } from '../geom/flat/deflate.js';\nimport { inflateCoordinates } from '../geom/flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from '../geom/flat/interpolate.js';\nimport { intersectsLineString } from '../geom/flat/intersectsextent.js';\nimport { lineStringLength } from '../geom/flat/length.js';\nimport { forEach as forEachSegment } from '../geom/flat/segments.js';\nimport { douglasPeucker } from '../geom/flat/simplify.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @constructor\n * @extends {module:ol/geom/SimpleGeometry}\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @api\n */\n\nconst LineString = function (coordinates, opt_layout) {\n  SimpleGeometry.call(this);\n  /**\n   * @private\n   * @type {module:ol/coordinate~Coordinate}\n   */\n\n  this.flatMidpoint_ = null;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.flatMidpointRevision_ = -1;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.maxDelta_ = -1;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.maxDeltaRevision_ = -1;\n  this.setCoordinates(coordinates, opt_layout);\n};\n\ninherits(LineString, SimpleGeometry);\n/**\n * Append the passed coordinate to the coordinates of the linestring.\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @api\n */\n\nLineString.prototype.appendCoordinate = function (coordinate) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = coordinate.slice();\n  } else {\n    extend(this.flatCoordinates, coordinate);\n  }\n\n  this.changed();\n};\n/**\n * Make a complete copy of the geometry.\n * @return {!module:ol/geom/LineString} Clone.\n * @override\n * @api\n */\n\n\nLineString.prototype.clone = function () {\n  const lineString = new LineString(null);\n  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());\n  return lineString;\n};\n/**\n * @inheritDoc\n */\n\n\nLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n\n  return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n};\n/**\n * Iterate over each segment, calling the provided callback.\n * If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n *\n * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T,S\n * @api\n */\n\n\nLineString.prototype.forEachSegment = function (callback) {\n  return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n};\n/**\n * Returns the coordinate at `m` using linear interpolation, or `null` if no\n * such coordinate exists.\n *\n * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n * M will return the first coordinate and Ms greater than the last M will\n * return the last coordinate.\n *\n * @param {number} m M.\n * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n * @return {module:ol/coordinate~Coordinate} Coordinate.\n * @api\n */\n\n\nLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n  if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {\n    return null;\n  }\n\n  const extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n  return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n};\n/**\n * Return the coordinates of the linestring.\n * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.\n * @override\n * @api\n */\n\n\nLineString.prototype.getCoordinates = function () {\n  return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n/**\n * Return the coordinate at the provided fraction along the linestring.\n * The `fraction` is a number between 0 and 1, where 0 is the start of the\n * linestring and 1 is the end.\n * @param {number} fraction Fraction.\n * @param {module:ol/coordinate~Coordinate=} opt_dest Optional coordinate whose values will\n *     be modified. If not provided, a new coordinate will be returned.\n * @return {module:ol/coordinate~Coordinate} Coordinate of the interpolated point.\n * @api\n */\n\n\nLineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n  return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);\n};\n/**\n * Return the length of the linestring on projected plane.\n * @return {number} Length (on projected plane).\n * @api\n */\n\n\nLineString.prototype.getLength = function () {\n  return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n};\n/**\n * @return {Array.<number>} Flat midpoint.\n */\n\n\nLineString.prototype.getFlatMidpoint = function () {\n  if (this.flatMidpointRevision_ != this.getRevision()) {\n    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n    this.flatMidpointRevision_ = this.getRevision();\n  }\n\n  return this.flatMidpoint_;\n};\n/**\n * @inheritDoc\n */\n\n\nLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n  const simplifiedFlatCoordinates = [];\n  simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  const simplifiedLineString = new LineString(null);\n  simplifiedLineString.setFlatCoordinates(GeometryLayout.XY, simplifiedFlatCoordinates);\n  return simplifiedLineString;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nLineString.prototype.getType = function () {\n  return GeometryType.LINE_STRING;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nLineString.prototype.intersectsExtent = function (extent) {\n  return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n};\n/**\n * Set the coordinates of the linestring.\n * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.\n * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n\n\nLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(GeometryLayout.XY, null);\n  } else {\n    this.setLayout(opt_layout, coordinates, 1);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n};\n/**\n * @param {module:ol/geom/GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n */\n\n\nLineString.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.changed();\n};\n\nexport default LineString;","map":null,"metadata":{},"sourceType":"module"}