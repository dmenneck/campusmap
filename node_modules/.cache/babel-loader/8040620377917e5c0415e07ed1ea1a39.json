{"ast":null,"code":"import { listen } from 'ol/events';\nimport EventType from 'ol/events/EventType';\nimport { labelCache } from 'ol/render/canvas';\nexport function deg2rad(degrees) {\n  return degrees * Math.PI / 180;\n}\nexport const defaultResolutions = function () {\n  const resolutions = [];\n\n  for (let res = 78271.51696402048; resolutions.length <= 24; res /= 2) {\n    resolutions.push(res);\n  }\n\n  return resolutions;\n}();\nexport function getZoomForResolution(resolution, resolutions) {\n  let i = 0;\n  const ii = resolutions.length;\n\n  for (; i < ii; ++i) {\n    const candidate = resolutions[i];\n\n    if (candidate < resolution && i + 1 < ii) {\n      const zoomFactor = resolutions[i] / resolutions[i + 1];\n      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);\n    }\n  }\n\n  return ii - 1;\n}\nconst hairSpacePool = Array(256).join('\\u200A');\nexport function applyLetterSpacing(text, letterSpacing) {\n  if (letterSpacing >= 0.05) {\n    let textWithLetterSpacing = '';\n    const lines = text.split('\\n');\n    const joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));\n\n    for (let l = 0, ll = lines.length; l < ll; ++l) {\n      if (l > 0) {\n        textWithLetterSpacing += '\\n';\n      }\n\n      textWithLetterSpacing += lines[l].split('').join(joinSpaceString);\n    }\n\n    return textWithLetterSpacing;\n  }\n\n  return text;\n}\nconst ctx =\n/** @type {HTMLCanvasElement} */\ndocument.createElement('CANVAS').getContext('2d');\n\nfunction measureText(text, letterSpacing) {\n  return ctx.measureText(text).width + (text.length - 1) * letterSpacing;\n}\n\nlet measureCache = {};\n\nif (labelCache) {\n  // Only available when using ES modules\n  listen(labelCache, EventType.CLEAR, function () {\n    measureCache = {};\n  });\n}\n\nexport function wrapText(text, font, em, letterSpacing) {\n  const key = em + ',' + font + ',' + text + ',' + letterSpacing;\n  let wrappedText = measureCache[key];\n\n  if (!wrappedText) {\n    const words = text.split(' ');\n\n    if (words.length > 1) {\n      ctx.font = font;\n      const oneEm = ctx.measureText('M').width;\n      const maxWidth = oneEm * em;\n      let line = '';\n      const lines = []; // Pass 1 - wrap lines to not exceed maxWidth\n\n      for (let i = 0, ii = words.length; i < ii; ++i) {\n        const word = words[i];\n        const testLine = line + (line ? ' ' : '') + word;\n\n        if (measureText(testLine, letterSpacing) <= maxWidth) {\n          line = testLine;\n        } else {\n          if (line) {\n            lines.push(line);\n          }\n\n          line = word;\n        }\n      }\n\n      if (line) {\n        lines.push(line);\n      } // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line\n\n\n      for (let i = 0, ii = lines.length; i < ii; ++i) {\n        const line = lines[i];\n\n        if (measureText(line, letterSpacing) < maxWidth * 0.35) {\n          const prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;\n          const nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;\n          lines.splice(i, 1);\n\n          if (prevWidth < nextWidth) {\n            lines[i - 1] += ' ' + line;\n            i -= 1;\n          } else {\n            lines[i] = line + ' ' + lines[i];\n          }\n\n          ii -= 1;\n        }\n      } // Pass 3 - try to fill 80% of maxWidth for each line\n\n\n      for (let i = 0, ii = lines.length - 1; i < ii; ++i) {\n        const line = lines[i];\n        const next = lines[i + 1];\n\n        if (measureText(line, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {\n          const lineWords = line.split(' ');\n          const lastWord = lineWords.pop();\n\n          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {\n            lines[i] = lineWords.join(' ');\n            lines[i + 1] = lastWord + ' ' + next;\n          }\n\n          ii -= 1;\n        }\n      }\n\n      wrappedText = lines.join('\\n');\n    } else {\n      wrappedText = text;\n    }\n\n    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);\n    measureCache[key] = wrappedText;\n  }\n\n  return wrappedText;\n}","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ol-mapbox-style/util.js"],"names":["listen","EventType","labelCache","deg2rad","degrees","Math","PI","defaultResolutions","resolutions","res","length","push","getZoomForResolution","resolution","i","ii","candidate","zoomFactor","log","hairSpacePool","Array","join","applyLetterSpacing","text","letterSpacing","textWithLetterSpacing","lines","split","joinSpaceString","slice","round","l","ll","ctx","document","createElement","getContext","measureText","width","measureCache","CLEAR","wrapText","font","em","key","wrappedText","words","oneEm","maxWidth","line","word","testLine","prevWidth","Infinity","nextWidth","splice","next","lineWords","lastWord","pop"],"mappings":"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","sourcesContent":["import {listen} from 'ol/events';\nimport EventType from 'ol/events/EventType';\nimport {labelCache} from 'ol/render/canvas';\n\nexport function deg2rad(degrees) {\n  return degrees * Math.PI / 180;\n}\n\nexport const defaultResolutions = (function() {\n  const resolutions = [];\n  for (let res = 78271.51696402048; resolutions.length <= 24; res /= 2) {\n    resolutions.push(res);\n  }\n  return resolutions;\n})();\n\nexport function getZoomForResolution(resolution, resolutions) {\n  let i = 0;\n  const ii = resolutions.length;\n  for (; i < ii; ++i) {\n    const candidate = resolutions[i];\n    if (candidate < resolution && i + 1 < ii) {\n      const zoomFactor = resolutions[i] / resolutions[i + 1];\n      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);\n    }\n  }\n  return ii - 1;\n}\n\nconst hairSpacePool = Array(256).join('\\u200A');\nexport function applyLetterSpacing(text, letterSpacing) {\n  if (letterSpacing >= 0.05) {\n    let textWithLetterSpacing = '';\n    const lines = text.split('\\n');\n    const joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));\n    for (let l = 0, ll = lines.length; l < ll; ++l) {\n      if (l > 0) {\n        textWithLetterSpacing += '\\n';\n      }\n      textWithLetterSpacing += lines[l].split('').join(joinSpaceString);\n    }\n    return textWithLetterSpacing;\n  }\n  return text;\n}\n\nconst ctx = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS')).getContext('2d');\nfunction measureText(text, letterSpacing) {\n  return ctx.measureText(text).width + (text.length - 1) * letterSpacing;\n}\n\nlet measureCache = {};\nif (labelCache) {\n  // Only available when using ES modules\n  listen(labelCache, EventType.CLEAR, function() {\n    measureCache = {};\n  });\n}\nexport function wrapText(text, font, em, letterSpacing) {\n  const key = em + ',' + font + ',' + text + ',' + letterSpacing;\n  let wrappedText = measureCache[key];\n  if (!wrappedText) {\n    const words = text.split(' ');\n    if (words.length > 1) {\n      ctx.font = font;\n      const oneEm = ctx.measureText('M').width;\n      const maxWidth = oneEm * em;\n      let line = '';\n      const lines = [];\n      // Pass 1 - wrap lines to not exceed maxWidth\n      for (let i = 0, ii = words.length; i < ii; ++i) {\n        const word = words[i];\n        const testLine = line + (line ? ' ' : '') + word;\n        if (measureText(testLine, letterSpacing) <= maxWidth) {\n          line = testLine;\n        } else {\n          if (line) {\n            lines.push(line);\n          }\n          line = word;\n        }\n      }\n      if (line) {\n        lines.push(line);\n      }\n      // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line\n      for (let i = 0, ii = lines.length; i < ii; ++i) {\n        const line = lines[i];\n        if (measureText(line, letterSpacing) < maxWidth * 0.35) {\n          const prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;\n          const nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;\n          lines.splice(i, 1);\n          if (prevWidth < nextWidth) {\n            lines[i - 1] += ' ' + line;\n            i -= 1;\n          } else {\n            lines[i] = line + ' ' + lines[i];\n          }\n          ii -= 1;\n        }\n      }\n      // Pass 3 - try to fill 80% of maxWidth for each line\n      for (let i = 0, ii = lines.length - 1; i < ii; ++i) {\n        const line = lines[i];\n        const next = lines[i + 1];\n        if (measureText(line, letterSpacing) > maxWidth * 0.7 &&\n            measureText(next, letterSpacing) < maxWidth * 0.6) {\n          const lineWords = line.split(' ');\n          const lastWord = lineWords.pop();\n          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {\n            lines[i] = lineWords.join(' ');\n            lines[i + 1] = lastWord + ' ' + next;\n          }\n          ii -= 1;\n        }\n      }\n      wrappedText = lines.join('\\n');\n    } else {\n      wrappedText = text;\n    }\n    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);\n    measureCache[key] = wrappedText;\n  }\n  return wrappedText;\n}\n\n"]},"metadata":{},"sourceType":"module"}