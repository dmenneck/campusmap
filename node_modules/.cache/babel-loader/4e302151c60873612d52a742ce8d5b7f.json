{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport { inherits } from './util.js';\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\n/**\n * @constructor\n * @extends {module:ol/structs/LRUCache.<module:ol/Tile>}\n * @param {number=} opt_highWaterMark High water mark.\n * @struct\n */\n\nconst TileCache = function (opt_highWaterMark) {\n  LRUCache.call(this, opt_highWaterMark);\n};\n\ninherits(TileCache, LRUCache);\n/**\n * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.\n */\n\nTileCache.prototype.expireCache = function (usedTiles) {\n  while (this.canExpireCache()) {\n    const tile = this.peekLast();\n    const zKey = tile.tileCoord[0].toString();\n\n    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n      break;\n    } else {\n      this.pop().dispose();\n    }\n  }\n};\n/**\n * Prune all tiles from the cache that don't have the same z as the newest tile.\n */\n\n\nTileCache.prototype.pruneExceptNewestZ = function () {\n  if (this.getCount() === 0) {\n    return;\n  }\n\n  const key = this.peekFirstKey();\n  const tileCoord = fromKey(key);\n  const z = tileCoord[0];\n  this.forEach(function (tile) {\n    if (tile.tileCoord[0] !== z) {\n      this.remove(getKey(tile.tileCoord));\n      tile.dispose();\n    }\n  }, this);\n};\n\nexport default TileCache;","map":null,"metadata":{},"sourceType":"module"}