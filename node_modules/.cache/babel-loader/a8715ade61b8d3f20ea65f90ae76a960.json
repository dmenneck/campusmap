{"ast":null,"code":"/**\n * @module ol/TileQueue\n */\nimport { inherits } from './util.js';\nimport TileState from './TileState.js';\nimport { listen, unlisten } from './events.js';\nimport EventType from './events/EventType.js';\nimport PriorityQueue from './structs/PriorityQueue.js';\n/**\n * @typedef {function(module:ol/Tile, string, module:ol/coordinate~Coordinate, number): number} PriorityFunction\n */\n\n/**\n * @constructor\n * @extends {module:ol/structs/PriorityQueue.<Array>}\n * @param {module:ol/TileQueue~PriorityFunction} tilePriorityFunction\n *     Tile priority function.\n * @param {function(): ?} tileChangeCallback\n *     Function called on each tile change event.\n * @struct\n */\n\nconst TileQueue = function (tilePriorityFunction, tileChangeCallback) {\n  PriorityQueue.call(this,\n  /**\n   * @param {Array} element Element.\n   * @return {number} Priority.\n   */\n  function (element) {\n    return tilePriorityFunction.apply(null, element);\n  },\n  /**\n   * @param {Array} element Element.\n   * @return {string} Key.\n   */\n  function (element) {\n    return (\n      /** @type {module:ol/Tile} */\n      element[0].getKey()\n    );\n  });\n  /**\n   * @private\n   * @type {function(): ?}\n   */\n\n  this.tileChangeCallback_ = tileChangeCallback;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.tilesLoading_ = 0;\n  /**\n   * @private\n   * @type {!Object.<string,boolean>}\n   */\n\n  this.tilesLoadingKeys_ = {};\n};\n\ninherits(TileQueue, PriorityQueue);\n/**\n * @inheritDoc\n */\n\nTileQueue.prototype.enqueue = function (element) {\n  const added = PriorityQueue.prototype.enqueue.call(this, element);\n\n  if (added) {\n    const tile = element[0];\n    listen(tile, EventType.CHANGE, this.handleTileChange, this);\n  }\n\n  return added;\n};\n/**\n * @return {number} Number of tiles loading.\n */\n\n\nTileQueue.prototype.getTilesLoading = function () {\n  return this.tilesLoading_;\n};\n/**\n * @param {module:ol/events/Event} event Event.\n * @protected\n */\n\n\nTileQueue.prototype.handleTileChange = function (event) {\n  const tile =\n  /** @type {module:ol/Tile} */\n  event.target;\n  const state = tile.getState();\n\n  if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY || state === TileState.ABORT) {\n    unlisten(tile, EventType.CHANGE, this.handleTileChange, this);\n    const tileKey = tile.getKey();\n\n    if (tileKey in this.tilesLoadingKeys_) {\n      delete this.tilesLoadingKeys_[tileKey];\n      --this.tilesLoading_;\n    }\n\n    this.tileChangeCallback_();\n  }\n};\n/**\n * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n * @param {number} maxNewLoads Maximum number of new tiles to load.\n */\n\n\nTileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {\n  let newLoads = 0;\n  let abortedTiles = false;\n  let state, tile, tileKey;\n\n  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n    tile =\n    /** @type {module:ol/Tile} */\n    this.dequeue()[0];\n    tileKey = tile.getKey();\n    state = tile.getState();\n\n    if (state === TileState.ABORT) {\n      abortedTiles = true;\n    } else if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n      this.tilesLoadingKeys_[tileKey] = true;\n      ++this.tilesLoading_;\n      ++newLoads;\n      tile.load();\n    }\n  }\n\n  if (newLoads === 0 && abortedTiles) {\n    // Do not stop the render loop when all wanted tiles were aborted due to\n    // a small, saturated tile cache.\n    this.tileChangeCallback_();\n  }\n};\n\nexport default TileQueue;","map":null,"metadata":{},"sourceType":"module"}