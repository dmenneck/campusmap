{"ast":null,"code":"/**\n * @module ol/renderer/canvas/Map\n */\nimport { create as createTransform, apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { inherits } from '../../util.js';\nimport { includes, stableSort } from '../../array.js';\nimport { CLASS_UNSELECTABLE } from '../../css.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { visibleAtResolution } from '../../layer/Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport { rotateAtOffset } from '../../render/canvas.js';\nimport CanvasImmediateRenderer from '../../render/canvas/Immediate.js';\nimport MapRenderer, { sortByZIndex } from '../Map.js';\nimport SourceState from '../../source/State.js';\n/**\n * @type {Array.<module:ol/renderer/Layer>}\n */\n\nexport const layerRendererConstructors = [];\n/**\n * @constructor\n * @extends {module:ol/renderer/Map}\n * @param {module:ol/PluggableMap} map Map.\n * @api\n */\n\nconst CanvasMapRenderer = function (map) {\n  MapRenderer.call(this, map);\n  const container = map.getViewport();\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n\n  this.context_ = createCanvasContext2D();\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = this.context_.canvas;\n  this.canvas_.style.width = '100%';\n  this.canvas_.style.height = '100%';\n  this.canvas_.style.display = 'block';\n  this.canvas_.className = CLASS_UNSELECTABLE;\n  container.insertBefore(this.canvas_, container.childNodes[0] || null);\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.renderedVisible_ = true;\n  /**\n   * @private\n   * @type {module:ol/transform~Transform}\n   */\n\n  this.transform_ = createTransform();\n};\n\ninherits(CanvasMapRenderer, MapRenderer);\n/**\n * @param {module:ol/render/EventType} type Event type.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @private\n */\n\nCanvasMapRenderer.prototype.dispatchComposeEvent_ = function (type, frameState) {\n  const map = this.getMap();\n  const context = this.context_;\n\n  if (map.hasListener(type)) {\n    const extent = frameState.extent;\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const transform = this.getTransform(frameState);\n    const vectorContext = new CanvasImmediateRenderer(context, pixelRatio, extent, transform, rotation);\n    const composeEvent = new RenderEvent(type, vectorContext, frameState, context, null);\n    map.dispatchEvent(composeEvent);\n  }\n};\n/**\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @protected\n * @return {!module:ol/transform~Transform} Transform.\n */\n\n\nCanvasMapRenderer.prototype.getTransform = function (frameState) {\n  const viewState = frameState.viewState;\n  const dx1 = this.canvas_.width / 2;\n  const dy1 = this.canvas_.height / 2;\n  const sx = frameState.pixelRatio / viewState.resolution;\n  const sy = -sx;\n  const angle = -viewState.rotation;\n  const dx2 = -viewState.center[0];\n  const dy2 = -viewState.center[1];\n  return composeTransform(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasMapRenderer.prototype.renderFrame = function (frameState) {\n  if (!frameState) {\n    if (this.renderedVisible_) {\n      this.canvas_.style.display = 'none';\n      this.renderedVisible_ = false;\n    }\n\n    return;\n  }\n\n  const context = this.context_;\n  const pixelRatio = frameState.pixelRatio;\n  const width = Math.round(frameState.size[0] * pixelRatio);\n  const height = Math.round(frameState.size[1] * pixelRatio);\n\n  if (this.canvas_.width != width || this.canvas_.height != height) {\n    this.canvas_.width = width;\n    this.canvas_.height = height;\n  } else {\n    context.clearRect(0, 0, width, height);\n  }\n\n  const rotation = frameState.viewState.rotation;\n  this.calculateMatrices2D(frameState);\n  this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, frameState);\n  const layerStatesArray = frameState.layerStatesArray;\n  stableSort(layerStatesArray, sortByZIndex);\n\n  if (rotation) {\n    context.save();\n    rotateAtOffset(context, rotation, width / 2, height / 2);\n  }\n\n  const viewResolution = frameState.viewState.resolution;\n  let i, ii, layer, layerRenderer, layerState;\n\n  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n    layerState = layerStatesArray[i];\n    layer = layerState.layer;\n    layerRenderer =\n    /** @type {module:ol/renderer/canvas/Layer} */\n    this.getLayerRenderer(layer);\n\n    if (!visibleAtResolution(layerState, viewResolution) || layerState.sourceState != SourceState.READY) {\n      continue;\n    }\n\n    if (layerRenderer.prepareFrame(frameState, layerState)) {\n      layerRenderer.composeFrame(frameState, layerState, context);\n    }\n  }\n\n  if (rotation) {\n    context.restore();\n  }\n\n  this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, frameState);\n\n  if (!this.renderedVisible_) {\n    this.canvas_.style.display = '';\n    this.renderedVisible_ = true;\n  }\n\n  this.scheduleRemoveUnusedLayerRenderers(frameState);\n  this.scheduleExpireIconCache(frameState);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n  let result;\n  const viewState = frameState.viewState;\n  const viewResolution = viewState.resolution;\n  const layerStates = frameState.layerStatesArray;\n  const numLayers = layerStates.length;\n  const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n  let i;\n\n  for (i = numLayers - 1; i >= 0; --i) {\n    const layerState = layerStates[i];\n    const layer = layerState.layer;\n\n    if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n      const layerRenderer =\n      /** @type {module:ol/renderer/canvas/Layer} */\n      this.getLayerRenderer(layer);\n      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  return undefined;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasMapRenderer.prototype.registerLayerRenderers = function (constructors) {\n  MapRenderer.prototype.registerLayerRenderers.call(this, constructors);\n\n  for (let i = 0, ii = constructors.length; i < ii; ++i) {\n    const ctor = constructors[i];\n\n    if (!includes(layerRendererConstructors, ctor)) {\n      layerRendererConstructors.push(ctor);\n    }\n  }\n};\n\nexport default CanvasMapRenderer;","map":null,"metadata":{},"sourceType":"module"}