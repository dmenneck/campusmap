{"ast":null,"code":"/**\n * @module ol/geom/GeometryCollection\n */\nimport { inherits } from '../util.js';\nimport { listen, unlisten } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { createOrUpdateEmpty, closestSquaredDistanceXY, extend, getCenter } from '../extent.js';\nimport Geometry from '../geom/Geometry.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { clear } from '../obj.js';\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @constructor\n * @extends {module:ol/geom/Geometry}\n * @param {Array.<module:ol/geom/Geometry>=} opt_geometries Geometries.\n * @api\n */\n\nconst GeometryCollection = function (opt_geometries) {\n  Geometry.call(this);\n  /**\n   * @private\n   * @type {Array.<module:ol/geom/Geometry>}\n   */\n\n  this.geometries_ = opt_geometries ? opt_geometries : null;\n  this.listenGeometriesChange_();\n};\n\ninherits(GeometryCollection, Geometry);\n/**\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\n * @return {Array.<module:ol/geom/Geometry>} Cloned geometries.\n */\n\nfunction cloneGeometries(geometries) {\n  const clonedGeometries = [];\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n\n  return clonedGeometries;\n}\n/**\n * @private\n */\n\n\nGeometryCollection.prototype.unlistenGeometriesChange_ = function () {\n  if (!this.geometries_) {\n    return;\n  }\n\n  for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\n    unlisten(this.geometries_[i], EventType.CHANGE, this.changed, this);\n  }\n};\n/**\n * @private\n */\n\n\nGeometryCollection.prototype.listenGeometriesChange_ = function () {\n  if (!this.geometries_) {\n    return;\n  }\n\n  for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\n    listen(this.geometries_[i], EventType.CHANGE, this.changed, this);\n  }\n};\n/**\n * Make a complete copy of the geometry.\n * @return {!module:ol/geom/GeometryCollection} Clone.\n * @override\n * @api\n */\n\n\nGeometryCollection.prototype.clone = function () {\n  const geometryCollection = new GeometryCollection(null);\n  geometryCollection.setGeometries(this.geometries_);\n  return geometryCollection;\n};\n/**\n * @inheritDoc\n */\n\n\nGeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n  }\n\n  return minSquaredDistance;\n};\n/**\n * @inheritDoc\n */\n\n\nGeometryCollection.prototype.containsXY = function (x, y) {\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    if (geometries[i].containsXY(x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @inheritDoc\n */\n\n\nGeometryCollection.prototype.computeExtent = function (extent) {\n  createOrUpdateEmpty(extent);\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    extend(extent, geometries[i].getExtent());\n  }\n\n  return extent;\n};\n/**\n * Return the geometries that make up this geometry collection.\n * @return {Array.<module:ol/geom/Geometry>} Geometries.\n * @api\n */\n\n\nGeometryCollection.prototype.getGeometries = function () {\n  return cloneGeometries(this.geometries_);\n};\n/**\n * @return {Array.<module:ol/geom/Geometry>} Geometries.\n */\n\n\nGeometryCollection.prototype.getGeometriesArray = function () {\n  return this.geometries_;\n};\n/**\n * @inheritDoc\n */\n\n\nGeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n  if (this.simplifiedGeometryRevision != this.getRevision()) {\n    clear(this.simplifiedGeometryCache);\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    this.simplifiedGeometryRevision = this.getRevision();\n  }\n\n  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {\n    return this;\n  }\n\n  const key = squaredTolerance.toString();\n\n  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n    return this.simplifiedGeometryCache[key];\n  } else {\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(null);\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\n      return simplifiedGeometryCollection;\n    } else {\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  }\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nGeometryCollection.prototype.getType = function () {\n  return GeometryType.GEOMETRY_COLLECTION;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nGeometryCollection.prototype.intersectsExtent = function (extent) {\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    if (geometries[i].intersectsExtent(extent)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @return {boolean} Is empty.\n */\n\n\nGeometryCollection.prototype.isEmpty = function () {\n  return this.geometries_.length === 0;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nGeometryCollection.prototype.rotate = function (angle, anchor) {\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].rotate(angle, anchor);\n  }\n\n  this.changed();\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nGeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {\n  let anchor = opt_anchor;\n\n  if (!anchor) {\n    anchor = getCenter(this.getExtent());\n  }\n\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].scale(sx, opt_sy, anchor);\n  }\n\n  this.changed();\n};\n/**\n * Set the geometries that make up this geometry collection.\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\n * @api\n */\n\n\nGeometryCollection.prototype.setGeometries = function (geometries) {\n  this.setGeometriesArray(cloneGeometries(geometries));\n};\n/**\n * @param {Array.<module:ol/geom/Geometry>} geometries Geometries.\n */\n\n\nGeometryCollection.prototype.setGeometriesArray = function (geometries) {\n  this.unlistenGeometriesChange_();\n  this.geometries_ = geometries;\n  this.listenGeometriesChange_();\n  this.changed();\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nGeometryCollection.prototype.applyTransform = function (transformFn) {\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].applyTransform(transformFn);\n  }\n\n  this.changed();\n};\n/**\n * Translate the geometry.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @override\n * @api\n */\n\n\nGeometryCollection.prototype.translate = function (deltaX, deltaY) {\n  const geometries = this.geometries_;\n\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    geometries[i].translate(deltaX, deltaY);\n  }\n\n  this.changed();\n};\n/**\n * @inheritDoc\n */\n\n\nGeometryCollection.prototype.disposeInternal = function () {\n  this.unlistenGeometriesChange_();\n  Geometry.prototype.disposeInternal.call(this);\n};\n\nexport default GeometryCollection;","map":null,"metadata":{},"sourceType":"module"}