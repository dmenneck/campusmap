{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar columnGroup_1 = require(\"../entities/columnGroup\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar expressionService_1 = require(\"../valueService/expressionService\");\n\nvar columnFactory_1 = require(\"./columnFactory\");\n\nvar displayedGroupCreator_1 = require(\"./displayedGroupCreator\");\n\nvar autoWidthCalculator_1 = require(\"../rendering/autoWidthCalculator\");\n\nvar eventService_1 = require(\"../eventService\");\n\nvar columnUtils_1 = require(\"./columnUtils\");\n\nvar logger_1 = require(\"../logger\");\n\nvar events_1 = require(\"../events\");\n\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\n\nvar groupInstanceIdCreator_1 = require(\"./groupInstanceIdCreator\");\n\nvar context_1 = require(\"../context/context\");\n\nvar columnAnimationService_1 = require(\"../rendering/columnAnimationService\");\n\nvar autoGroupColService_1 = require(\"./autoGroupColService\");\n\nvar valueCache_1 = require(\"../valueService/valueCache\");\n\nvar gridApi_1 = require(\"../gridApi\");\n\nvar columnApi_1 = require(\"./columnApi\");\n\nvar utils_1 = require(\"../utils\");\n\nvar ColumnController =\n/** @class */\nfunction () {\n  function ColumnController() {\n    // header row count, based on user provided columns\n    this.primaryHeaderRowCount = 0;\n    this.secondaryHeaderRowCount = 0;\n    this.secondaryColumnsPresent = false; // header row count, either above, or based on pivoting if we are pivoting\n\n    this.gridHeaderRowCount = 0; // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above\n    // displayed trees, however it also takes into account if the groups are open or not.\n\n    this.displayedLeftColumns = [];\n    this.displayedRightColumns = [];\n    this.displayedCenterColumns = []; // all three lists above combined\n\n    this.allDisplayedColumns = []; // same as above, except trimmed down to only columns within the viewport\n\n    this.allDisplayedVirtualColumns = [];\n    this.allDisplayedCenterVirtualColumns = [];\n    this.rowGroupColumns = [];\n    this.valueColumns = [];\n    this.pivotColumns = [];\n    this.ready = false;\n    this.autoGroupsNeedBuilding = false;\n    this.pivotMode = false;\n    this.bodyWidth = 0;\n    this.leftWidth = 0;\n    this.rightWidth = 0;\n    this.bodyWidthDirty = true;\n  }\n\n  ColumnController.prototype.init = function () {\n    var pivotMode = this.gridOptionsWrapper.isPivotMode();\n    this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n\n    if (this.isPivotSettingAllowed(pivotMode)) {\n      this.pivotMode = pivotMode;\n    }\n\n    this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n  };\n\n  ColumnController.prototype.setColumnDefs = function (columnDefs, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var colsPreviouslyExisted = !!this.columnDefs;\n    this.columnDefs = columnDefs; // always invalidate cache on changing columns, as the column id's for the new columns\n    // could overlap with the old id's, so the cache would return old values for new columns.\n\n    this.valueCache.expire(); // NOTE ==================\n    // we should be destroying the existing columns and groups if they exist, for example, the original column\n    // group adds a listener to the columns, it should be also removing the listeners\n\n    this.autoGroupsNeedBuilding = true;\n    var oldPrimaryColumns = this.primaryColumns;\n    var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryColumns);\n    this.primaryColumnTree = balancedTreeResult.columnTree;\n    this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n    this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    this.extractRowGroupColumns(source, oldPrimaryColumns);\n    this.extractPivotColumns(source, oldPrimaryColumns);\n    this.createValueColumns(source, oldPrimaryColumns);\n    this.ready = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n    this.checkDisplayedVirtualColumns();\n\n    if (this.gridOptionsWrapper.isDeltaColumnMode() && colsPreviouslyExisted) {\n      this.resetColumnState(true, source);\n    }\n\n    var eventEverythingChanged = {\n      type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(eventEverythingChanged);\n    var newColumnsLoadedEvent = {\n      type: events_1.Events.EVENT_NEW_COLUMNS_LOADED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(newColumnsLoadedEvent);\n  };\n\n  ColumnController.prototype.isAutoRowHeightActive = function () {\n    return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n  };\n\n  ColumnController.prototype.getAllAutoRowHeightCols = function () {\n    return this.autoRowHeightColumns;\n  };\n\n  ColumnController.prototype.setVirtualViewportLeftAndRight = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n      this.viewportRight = this.bodyWidth - this.scrollPosition;\n    } else {\n      this.viewportLeft = this.scrollPosition;\n      this.viewportRight = this.scrollWidth + this.scrollPosition;\n    }\n  }; // used by clipboard service, to know what columns to paste into\n\n\n  ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {\n    var currentColumn = column;\n    var result = [];\n\n    while (currentColumn && utils_1._.exists(currentColumn)) {\n      result.push(currentColumn);\n      currentColumn = this.getDisplayedColAfter(currentColumn);\n    }\n\n    return result;\n  }; // checks what columns are currently displayed due to column virtualisation. fires an event\n  // if the list of columns has changed.\n  // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n\n\n  ColumnController.prototype.checkDisplayedVirtualColumns = function () {\n    // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n    if (utils_1._.exists(this.displayedCenterColumns)) {\n      var hashBefore = this.allDisplayedVirtualColumns.map(function (column) {\n        return column.getId();\n      }).join('#');\n      this.updateVirtualSets();\n      var hashAfter = this.allDisplayedVirtualColumns.map(function (column) {\n        return column.getId();\n      }).join('#');\n\n      if (hashBefore !== hashAfter) {\n        var event_1 = {\n          type: events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n          api: this.gridApi,\n          columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event_1);\n      }\n    }\n  };\n\n  ColumnController.prototype.setVirtualViewportPosition = function (scrollWidth, scrollPosition) {\n    if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n      this.scrollWidth = scrollWidth;\n      this.scrollPosition = scrollPosition; // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n      // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n      // virtual columns again\n\n      this.bodyWidthDirty = true;\n      this.setVirtualViewportLeftAndRight();\n\n      if (this.ready) {\n        this.checkDisplayedVirtualColumns();\n      }\n    }\n  };\n\n  ColumnController.prototype.isPivotMode = function () {\n    return this.pivotMode;\n  };\n\n  ColumnController.prototype.isPivotSettingAllowed = function (pivot) {\n    if (pivot) {\n      if (this.gridOptionsWrapper.isTreeData()) {\n        console.warn(\"ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      return true;\n    }\n  };\n\n  ColumnController.prototype.setPivotMode = function (pivotMode, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (pivotMode === this.pivotMode) {\n      return;\n    }\n\n    if (!this.isPivotSettingAllowed(this.pivotMode)) {\n      return;\n    }\n\n    this.pivotMode = pivotMode; // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n    // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n    // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n\n    this.autoGroupsNeedBuilding = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n    if (!this.secondaryColumnsPresent) {\n      return null;\n    }\n\n    var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n    var foundColumn = null;\n\n    if (this.secondaryColumns) {\n      this.secondaryColumns.forEach(function (column) {\n        var thisPivotKeys = column.getColDef().pivotKeys;\n        var pivotValueColumn = column.getColDef().pivotValueColumn;\n\n        var pivotKeyMatches = utils_1._.compareArrays(thisPivotKeys, pivotKeys);\n\n        var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n\n        if (pivotKeyMatches && pivotValueMatches) {\n          foundColumn = column;\n        }\n      });\n    }\n\n    return foundColumn;\n  };\n\n  ColumnController.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ColumnController');\n  };\n\n  ColumnController.prototype.setFirstRightAndLastLeftPinned = function (source) {\n    var lastLeft;\n    var firstRight;\n\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;\n      firstRight = this.displayedRightColumns ? utils_1._.last(this.displayedRightColumns) : null;\n    } else {\n      lastLeft = this.displayedLeftColumns ? utils_1._.last(this.displayedLeftColumns) : null;\n      firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;\n    }\n\n    this.gridColumns.forEach(function (column) {\n      column.setLastLeftPinned(column === lastLeft, source);\n      column.setFirstRightPinned(column === firstRight, source);\n    });\n  };\n\n  ColumnController.prototype.autoSizeColumns = function (keys, source) {\n    // because of column virtualisation, we can only do this function on columns that are\n    // actually rendered, as non-rendered columns (outside the viewport and not rendered\n    // due to column virtualisation) are not present. this can result in all rendered columns\n    // getting narrowed, which in turn introduces more rendered columns on the RHS which\n    // did not get autosized in the original run, leaving the visible grid with columns on\n    // the LHS sized, but RHS no. so we keep looping through teh visible columns until\n    // no more cols are available (rendered) to be resized\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    } // keep track of which cols we have resized in here\n\n\n    var columnsAutosized = []; // initialise with anything except 0 so that while loop executes at least once\n\n    var changesThisTimeAround = -1;\n\n    while (changesThisTimeAround !== 0) {\n      changesThisTimeAround = 0;\n      this.actionOnGridColumns(keys, function (column) {\n        // if already autosized, skip it\n        if (columnsAutosized.indexOf(column) >= 0) {\n          return false;\n        } // get how wide this col should be\n\n\n        var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column); // preferredWidth = -1 if this col is not on the screen\n\n\n        if (preferredWidth > 0) {\n          var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n\n          column.setActualWidth(newWidth, source);\n          columnsAutosized.push(column);\n          changesThisTimeAround++;\n        }\n\n        return true;\n      }, source);\n    }\n\n    if (columnsAutosized.length > 0) {\n      var event_2 = {\n        type: events_1.Events.EVENT_COLUMN_RESIZED,\n        columns: columnsAutosized,\n        column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,\n        finished: true,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: \"autosizeColumns\"\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n  };\n\n  ColumnController.prototype.autoSizeColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.autoSizeColumns([key], source);\n    }\n  };\n\n  ColumnController.prototype.autoSizeAllColumns = function (source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    this.autoSizeColumns(allDisplayedColumns, source);\n  };\n\n  ColumnController.prototype.getColumnsFromTree = function (rootColumns) {\n    var result = [];\n    recursiveFindColumns(rootColumns);\n    return result;\n\n    function recursiveFindColumns(childColumns) {\n      for (var i = 0; i < childColumns.length; i++) {\n        var child = childColumns[i];\n\n        if (child instanceof column_1.Column) {\n          result.push(child);\n        } else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n          recursiveFindColumns(child.getChildren());\n        }\n      }\n    }\n  };\n\n  ColumnController.prototype.getAllDisplayedColumnGroups = function () {\n    if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {\n      return this.displayedLeftColumnTree.concat(this.displayedCentreColumnTree).concat(this.displayedRightColumnTree);\n    } else {\n      return null;\n    }\n  }; // + columnSelectPanel\n\n\n  ColumnController.prototype.getPrimaryColumnTree = function () {\n    return this.primaryColumnTree;\n  }; // + gridPanel -> for resizing the body and setting top margin\n\n\n  ColumnController.prototype.getHeaderRowCount = function () {\n    return this.gridHeaderRowCount;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getLeftDisplayedColumnGroups = function () {\n    return this.displayedLeftColumnTree;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getRightDisplayedColumnGroups = function () {\n    return this.displayedRightColumnTree;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getCenterDisplayedColumnGroups = function () {\n    return this.displayedCentreColumnTree;\n  };\n\n  ColumnController.prototype.getDisplayedColumnGroups = function (type) {\n    switch (type) {\n      case column_1.Column.PINNED_LEFT:\n        return this.getLeftDisplayedColumnGroups();\n\n      case column_1.Column.PINNED_RIGHT:\n        return this.getRightDisplayedColumnGroups();\n\n      default:\n        return this.getCenterDisplayedColumnGroups();\n    }\n  }; // gridPanel -> ensureColumnVisible\n\n\n  ColumnController.prototype.isColumnDisplayed = function (column) {\n    return this.getAllDisplayedColumns().indexOf(column) >= 0;\n  }; // + csvCreator\n\n\n  ColumnController.prototype.getAllDisplayedColumns = function () {\n    return this.allDisplayedColumns;\n  };\n\n  ColumnController.prototype.getAllDisplayedVirtualColumns = function () {\n    return this.allDisplayedVirtualColumns;\n  };\n\n  ColumnController.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedLeftColumns;\n    } else {\n      return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);\n    }\n  };\n\n  ColumnController.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedRightColumns;\n    } else {\n      return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);\n    }\n  };\n\n  ColumnController.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n    var result = [];\n    var lastConsideredCol = null;\n\n    var _loop_1 = function (i) {\n      var col = displayedColumns[i];\n      var maxAllowedColSpan = displayedColumns.length - i;\n      var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n      var columnsToCheckFilter = [col];\n\n      if (colSpan > 1) {\n        var colsToRemove = colSpan - 1;\n\n        for (var j = 1; j <= colsToRemove; j++) {\n          columnsToCheckFilter.push(displayedColumns[i + j]);\n        }\n\n        i += colsToRemove;\n      } // see which cols we should take out for column virtualisation\n\n\n      var filterPasses;\n\n      if (filterCallback) {\n        // if user provided a callback, means some columns may not be in the viewport.\n        // the user will NOT provide a callback if we are talking about pinned areas,\n        // as pinned areas have no horizontal scroll and do not virtualise the columns.\n        // if lots of columns, that means column spanning, and we set filterPasses = true\n        // if one or more of the columns spanned pass the filter.\n        filterPasses = false;\n        columnsToCheckFilter.forEach(function (colForFilter) {\n          if (filterCallback(colForFilter)) {\n            filterPasses = true;\n          }\n        });\n      } else {\n        filterPasses = true;\n      }\n\n      if (filterPasses) {\n        if (result.length === 0 && lastConsideredCol) {\n          var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n\n          if (gapBeforeColumn) {\n            result.push(lastConsideredCol);\n          }\n        }\n\n        result.push(col);\n      }\n\n      lastConsideredCol = col;\n      out_i_1 = i;\n    };\n\n    var out_i_1;\n\n    for (var i = 0; i < displayedColumns.length; i++) {\n      _loop_1(i);\n\n      i = out_i_1;\n    }\n\n    return result;\n  }; // + rowRenderer\n  // if we are not column spanning, this just returns back the virtual centre columns,\n  // however if we are column spanning, then different rows can have different virtual\n  // columns, so we have to work out the list for each individual row.\n\n\n  ColumnController.prototype.getAllDisplayedCenterVirtualColumnsForRow = function (rowNode) {\n    var _this = this;\n\n    if (!this.colSpanActive) {\n      return this.allDisplayedCenterVirtualColumns;\n    }\n\n    var emptySpaceBeforeColumn = function (col) {\n      return col.getLeft() > _this.viewportLeft;\n    }; // if doing column virtualisation, then we filter based on the viewport.\n\n\n    var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedCenterColumns, filterCallback, emptySpaceBeforeColumn);\n  };\n\n  ColumnController.prototype.isColumnInViewport = function (col) {\n    var columnLeft = col.getLeft();\n    var columnRight = col.getLeft() + col.getActualWidth(); // adding 200 for buffer size, so some cols off viewport are rendered.\n    // this helps horizontal scrolling so user rarely sees white space (unless\n    // they scroll horizontally fast). however we are conservative, as the more\n    // buffer the slower the vertical redraw speed\n\n    var leftBounds = this.viewportLeft - 200;\n    var rightBounds = this.viewportRight + 200;\n    var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n    var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n    return !columnToMuchLeft && !columnToMuchRight;\n  }; // used by:\n  // + angularGrid -> setting pinned body width\n  // note: this should be cached\n\n\n  ColumnController.prototype.getPinnedLeftContainerWidth = function () {\n    return this.getWidthOfColsInList(this.displayedLeftColumns);\n  }; // note: this should be cached\n\n\n  ColumnController.prototype.getPinnedRightContainerWidth = function () {\n    return this.getWidthOfColsInList(this.displayedRightColumns);\n  };\n\n  ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (!keys || utils_1._.missingOrEmpty(keys)) {\n      return;\n    }\n\n    var atLeastOne = false;\n    keys.forEach(function (key) {\n      var columnToAdd = _this.getPrimaryColumn(key);\n\n      if (!columnToAdd) {\n        return;\n      }\n\n      if (actionIsAdd) {\n        if (masterList.indexOf(columnToAdd) >= 0) {\n          return;\n        }\n\n        masterList.push(columnToAdd);\n      } else {\n        if (masterList.indexOf(columnToAdd) < 0) {\n          return;\n        }\n\n        utils_1._.removeFromArray(masterList, columnToAdd);\n      }\n\n      columnCallback(columnToAdd);\n      atLeastOne = true;\n    });\n\n    if (!atLeastOne) {\n      return;\n    }\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: eventType,\n      columns: masterList,\n      column: masterList.length === 1 ? masterList[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.setRowGroupColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.setPrimaryColumnList(colKeys, this.rowGroupColumns, events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n  };\n\n  ColumnController.prototype.setRowGroupActive = function (active, column, source) {\n    if (active === column.isRowGroupActive()) {\n      return;\n    }\n\n    column.setRowGroupActive(active, source);\n\n    if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n      column.setVisible(true, source);\n    }\n  };\n\n  ColumnController.prototype.addRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.addRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnController.prototype.addRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnController.prototype.removeRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnController.prototype.removeRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.removeRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnController.prototype.addPivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) {\n      return column.setPivotActive(true, source);\n    }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnController.prototype.setPivotColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.pivotColumns, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n      column.setPivotActive(added, source);\n    }, source);\n  };\n\n  ColumnController.prototype.addPivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.addPivotColumns([key], source);\n  };\n\n  ColumnController.prototype.removePivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) {\n      return column.setPivotActive(false, source);\n    }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnController.prototype.removePivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removePivotColumns([key], source);\n  };\n\n  ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n    var _this = this;\n\n    masterList.length = 0;\n\n    if (utils_1._.exists(colKeys)) {\n      colKeys.forEach(function (key) {\n        var column = _this.getPrimaryColumn(key);\n\n        if (column) {\n          masterList.push(column);\n        }\n      });\n    }\n\n    this.primaryColumns.forEach(function (column) {\n      var added = masterList.indexOf(column) >= 0;\n      columnCallback(added, column);\n    });\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: eventName,\n      columns: masterList,\n      column: masterList.length === 1 ? masterList[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.setValueColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.valueColumns, events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n  };\n\n  ColumnController.prototype.setValueActive = function (active, column, source) {\n    if (active === column.isValueActive()) {\n      return;\n    }\n\n    column.setValueActive(active, source);\n\n    if (active && !column.getAggFunc()) {\n      var defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n      column.setAggFunc(defaultAggFunc);\n    }\n  };\n\n  ColumnController.prototype.addValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), events_1.Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  };\n\n  ColumnController.prototype.addValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (colKey) {\n      this.addValueColumns([colKey], source);\n    }\n  };\n\n  ColumnController.prototype.removeValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removeValueColumns([colKey], source);\n  };\n\n  ColumnController.prototype.removeValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), events_1.Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  }; // returns the width we can set to this col, taking into consideration min and max widths\n\n\n  ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {\n    if (newWidth < column.getMinWidth()) {\n      newWidth = column.getMinWidth();\n    }\n\n    if (column.isGreaterThanMax(newWidth)) {\n      newWidth = column.getMaxWidth();\n    }\n\n    return newWidth;\n  };\n\n  ColumnController.prototype.getPrimaryOrGridColumn = function (key) {\n    var column = this.getPrimaryColumn(key);\n\n    if (column) {\n      return column;\n    } else {\n      return this.getGridColumn(key);\n    }\n  };\n\n  ColumnController.prototype.setColumnWidth = function (key, // @key - the column who's size we want to change\n  newWidth, // @newWidth - width in pixels\n  shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n  finished, // @finished - ends up in the event, tells the user if more events are to come\n  source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var col = this.getPrimaryOrGridColumn(key);\n\n    if (!col) {\n      return;\n    }\n\n    var sets = [];\n    sets.push({\n      width: newWidth,\n      ratios: [1],\n      columns: [col]\n    }); // if user wants to do shift resize by default, then we invert the shift operation\n\n    var defaultIsShift = this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n\n    if (defaultIsShift) {\n      shiftKey = !shiftKey;\n    }\n\n    if (shiftKey) {\n      var otherCol = this.getDisplayedColAfter(col);\n\n      if (!otherCol) {\n        return;\n      }\n\n      var widthDiff = col.getActualWidth() - newWidth;\n      var otherColWidth = otherCol.getActualWidth() + widthDiff;\n      sets.push({\n        width: otherColWidth,\n        ratios: [1],\n        columns: [otherCol]\n      });\n    }\n\n    this.resizeColumnSets(sets, finished, source);\n  };\n\n  ColumnController.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n    var columns = columnResizeSet.columns,\n        width = columnResizeSet.width; // every col has a min width, so sum them all up and see if we have enough room\n    // for all the min widths\n\n    var minWidthAccumulated = 0;\n    var maxWidthAccumulated = 0;\n    var maxWidthActive = true;\n    columns.forEach(function (col) {\n      minWidthAccumulated += col.getMinWidth();\n\n      if (col.getMaxWidth() > 0) {\n        maxWidthAccumulated += col.getMaxWidth();\n      } else {\n        // if at least one columns has no max width, it means the group of columns\n        // then has no max width, as at least one column can take as much width as possible\n        maxWidthActive = false;\n      }\n    });\n    var minWidthPasses = width >= minWidthAccumulated;\n    var maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;\n    return minWidthPasses && maxWidthPasses;\n  }; // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n  // be resized. this is used for example when user tries to resize a group and holds shift key,\n  // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n  // so that's two sets for this method.\n\n\n  ColumnController.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n    var passMinMaxCheck = utils_1._.every(resizeSets, this.checkMinAndMaxWidthsForSet.bind(this));\n\n    if (!passMinMaxCheck) {\n      // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n      if (finished) {\n        var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n        var event_3 = {\n          type: events_1.Events.EVENT_COLUMN_RESIZED,\n          columns: columns,\n          column: columns && columns.length === 1 ? columns[0] : null,\n          finished: finished,\n          api: this.gridApi,\n          columnApi: this.columnApi,\n          source: source\n        };\n        this.eventService.dispatchEvent(event_3);\n      }\n\n      return; // don't resize!\n    }\n\n    var changedCols = [];\n    var allCols = [];\n    resizeSets.forEach(function (set) {\n      var width = set.width,\n          columns = set.columns,\n          ratios = set.ratios; // keep track of pixels used, and last column gets the remaining,\n      // to cater for rounding errors, and min width adjustments\n\n      var newWidths = {};\n      var finishedCols = {};\n      columns.forEach(function (col) {\n        return allCols.push(col);\n      }); // the loop below goes through each col. if a col exceeds it's min/max width,\n      // it then gets set to its min/max width and the column is removed marked as 'finished'\n      // and the calculation is done again leaving this column out. take for example columns\n      // {A, width: 50, maxWidth: 100}\n      // {B, width: 50}\n      // {C, width: 50}\n      // and then the set is set to width 600 - on the first pass the grid tries to set each column\n      // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n      // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n      // splitting the remaining 500 pixels.\n\n      var finishedColsGrew = true;\n      var loopCount = 0;\n\n      var _loop_2 = function () {\n        loopCount++;\n\n        if (loopCount > 1000) {\n          // this should never happen, but in the future, someone might introduce a bug here,\n          // so we stop the browser from hanging and report bug properly\n          console.error('ag-Grid: infinite loop in resizeColumnSets');\n          return \"break\";\n        }\n\n        finishedColsGrew = false;\n        var subsetCols = [];\n        var subsetRatios = [];\n        var subsetRatioTotal = 0;\n        var pixelsToDistribute = width;\n        columns.forEach(function (col, index) {\n          var thisColFinished = finishedCols[col.getId()];\n\n          if (thisColFinished) {\n            pixelsToDistribute -= newWidths[col.getId()];\n          } else {\n            subsetCols.push(col);\n            var ratioThisCol = ratios[index];\n            subsetRatioTotal += ratioThisCol;\n            subsetRatios.push(ratioThisCol);\n          }\n        }); // because we are not using all of the ratios (cols can be missing),\n        // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n        // and so the ratioScale will be 1.\n\n        var ratioScale = 1 / subsetRatioTotal;\n        subsetCols.forEach(function (col, index) {\n          var lastCol = index === subsetCols.length - 1;\n          var colNewWidth;\n\n          if (lastCol) {\n            colNewWidth = pixelsToDistribute;\n          } else {\n            colNewWidth = Math.round(ratios[index] * width * ratioScale);\n            pixelsToDistribute -= colNewWidth;\n          }\n\n          if (colNewWidth < col.getMinWidth()) {\n            colNewWidth = col.getMinWidth();\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          } else if (col.getMaxWidth() > 0 && colNewWidth > col.getMaxWidth()) {\n            colNewWidth = col.getMaxWidth();\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          }\n\n          newWidths[col.getId()] = colNewWidth;\n        });\n      };\n\n      while (finishedColsGrew) {\n        var state_1 = _loop_2();\n\n        if (state_1 === \"break\") break;\n      }\n\n      columns.forEach(function (col) {\n        var newWidth = newWidths[col.getId()];\n\n        if (col.getActualWidth() !== newWidth) {\n          col.setActualWidth(newWidth);\n          changedCols.push(col);\n        }\n      });\n    }); // if no cols changed, then no need to update more or send event.\n\n    var atLeastOneColChanged = changedCols.length > 0;\n\n    if (atLeastOneColChanged) {\n      this.setLeftValues(source);\n      this.updateBodyWidths();\n      this.checkDisplayedVirtualColumns();\n    } // check for change first, to avoid unnecessary firing of events\n    // however we always fire 'finished' events. this is important\n    // when groups are resized, as if the group is changing slowly,\n    // eg 1 pixel at a time, then each change will fire change events\n    // in all the columns in the group, but only one with get the pixel.\n\n\n    if (atLeastOneColChanged || finished) {\n      var event_4 = {\n        type: events_1.Events.EVENT_COLUMN_RESIZED,\n        columns: allCols,\n        column: allCols.length === 1 ? allCols[0] : null,\n        finished: finished,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_4);\n    }\n  };\n\n  ColumnController.prototype.setColumnAggFunc = function (column, aggFunc, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (column) {\n      column.setAggFunc(aggFunc);\n      var event_5 = {\n        type: events_1.Events.EVENT_COLUMN_VALUE_CHANGED,\n        columns: [column],\n        column: column,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_5);\n    }\n  };\n\n  ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.rowGroupColumns[fromIndex];\n    this.rowGroupColumns.splice(fromIndex, 1);\n    this.rowGroupColumns.splice(toIndex, 0, column);\n    var event = {\n      type: events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n      columns: this.rowGroupColumns,\n      column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n\n    if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n      console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n      console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');\n      return;\n    } // we want to pull all the columns out first and put them into an ordered list\n\n\n    var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n    var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n\n    if (failedRules) {\n      return;\n    }\n\n    utils_1._.moveInArray(this.gridColumns, columnsToMove, toIndex);\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: events_1.Events.EVENT_COLUMN_MOVED,\n      columns: columnsToMove,\n      column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n      toIndex: toIndex,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n    this.columnAnimationService.finish();\n  };\n\n  ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n    // make a copy of what the grid columns would look like after the move\n    var proposedColumnOrder = this.gridColumns.slice();\n\n    utils_1._.moveInArray(proposedColumnOrder, columnsToMove, toIndex); // then check that the new proposed order of the columns passes all rules\n\n\n    if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n      return false;\n    }\n\n    if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ColumnController.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n    var foundNonLocked = false;\n    var rulePassed = true; // go though the cols, see if any non-locked appear before any locked\n\n    proposedColumnOrder.forEach(function (col) {\n      if (col.getColDef().lockPosition) {\n        if (foundNonLocked) {\n          rulePassed = false;\n        }\n      } else {\n        foundNonLocked = true;\n      }\n    });\n    return rulePassed;\n  };\n\n  ColumnController.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n    var rulePassed = true;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n      if (!(child instanceof originalColumnGroup_1.OriginalColumnGroup)) {\n        return;\n      }\n\n      var columnGroup = child;\n      var marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;\n\n      if (!marryChildren) {\n        return;\n      }\n\n      var newIndexes = [];\n      columnGroup.getLeafColumns().forEach(function (col) {\n        var newColIndex = allColumnsCopy.indexOf(col);\n        newIndexes.push(newColIndex);\n      });\n      var maxIndex = Math.max.apply(Math, newIndexes);\n      var minIndex = Math.min.apply(Math, newIndexes); // spread is how far the first column in this group is away from the last column\n\n      var spread = maxIndex - minIndex;\n      var maxSpread = columnGroup.getLeafColumns().length - 1; // if the columns\n\n      if (spread > maxSpread) {\n        rulePassed = false;\n      } // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n      // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n\n    });\n    return rulePassed;\n  };\n\n  ColumnController.prototype.moveColumn = function (key, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.moveColumns([key], toIndex, source);\n  };\n\n  ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.gridColumns[fromIndex];\n    this.moveColumn(column, toIndex, source);\n  }; // used by:\n  // + angularGrid -> for setting body width\n  // + rowController -> setting main row widths (when inserting and resizing)\n  // need to cache this\n\n\n  ColumnController.prototype.getBodyContainerWidth = function () {\n    return this.bodyWidth;\n  };\n\n  ColumnController.prototype.getContainerWidth = function (pinned) {\n    switch (pinned) {\n      case column_1.Column.PINNED_LEFT:\n        return this.leftWidth;\n\n      case column_1.Column.PINNED_RIGHT:\n        return this.rightWidth;\n\n      default:\n        return this.bodyWidth;\n    }\n  }; // after setColumnWidth or updateGroupsAndDisplayedColumns\n\n\n  ColumnController.prototype.updateBodyWidths = function () {\n    var newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);\n    var newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);\n    var newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns); // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n    // columns, due to RTL inverting the y coordinates\n\n    this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n    var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n\n    if (atLeastOneChanged) {\n      this.bodyWidth = newBodyWidth;\n      this.leftWidth = newLeftWidth;\n      this.rightWidth = newRightWidth; // when this fires, it is picked up by the gridPanel, which ends up in\n      // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()\n\n      var event_6 = {\n        type: events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_6);\n    }\n  }; // + rowController\n\n\n  ColumnController.prototype.getValueColumns = function () {\n    return this.valueColumns ? this.valueColumns : [];\n  }; // + rowController\n\n\n  ColumnController.prototype.getPivotColumns = function () {\n    return this.pivotColumns ? this.pivotColumns : [];\n  }; // + clientSideRowModel\n\n\n  ColumnController.prototype.isPivotActive = function () {\n    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n  }; // + toolPanel\n\n\n  ColumnController.prototype.getRowGroupColumns = function () {\n    return this.rowGroupColumns ? this.rowGroupColumns : [];\n  }; // + rowController -> while inserting rows\n\n\n  ColumnController.prototype.getDisplayedCenterColumns = function () {\n    return this.displayedCenterColumns;\n  }; // + rowController -> while inserting rows\n\n\n  ColumnController.prototype.getDisplayedLeftColumns = function () {\n    return this.displayedLeftColumns;\n  };\n\n  ColumnController.prototype.getDisplayedRightColumns = function () {\n    return this.displayedRightColumns;\n  };\n\n  ColumnController.prototype.getDisplayedColumns = function (type) {\n    switch (type) {\n      case column_1.Column.PINNED_LEFT:\n        return this.getDisplayedLeftColumns();\n\n      case column_1.Column.PINNED_RIGHT:\n        return this.getDisplayedRightColumns();\n\n      default:\n        return this.getDisplayedCenterColumns();\n    }\n  }; // used by:\n  // + clientSideRowController -> sorting, building quick filter text\n  // + headerRenderer -> sorting (clearing icon)\n\n\n  ColumnController.prototype.getAllPrimaryColumns = function () {\n    return this.primaryColumns ? this.primaryColumns.slice() : null;\n  };\n\n  ColumnController.prototype.getSecondaryColumns = function () {\n    return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n  };\n\n  ColumnController.prototype.getAllColumnsForQuickFilter = function () {\n    return this.columnsForQuickFilter;\n  }; // + moveColumnController\n\n\n  ColumnController.prototype.getAllGridColumns = function () {\n    return this.gridColumns;\n  };\n\n  ColumnController.prototype.isEmpty = function () {\n    return utils_1._.missingOrEmpty(this.gridColumns);\n  };\n\n  ColumnController.prototype.isRowGroupEmpty = function () {\n    return utils_1._.missingOrEmpty(this.rowGroupColumns);\n  };\n\n  ColumnController.prototype.setColumnVisible = function (key, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setColumnsVisible([key], visible, source);\n  };\n\n  ColumnController.prototype.setColumnsVisible = function (keys, visible, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    this.actionOnGridColumns(keys, function (column) {\n      if (column.isVisible() !== visible) {\n        column.setVisible(visible, source);\n        return true;\n      } else {\n        return false;\n      }\n    }, source, function () {\n      var event = {\n        type: events_1.Events.EVENT_COLUMN_VISIBLE,\n        visible: visible,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  };\n\n  ColumnController.prototype.setColumnPinned = function (key, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.setColumnsPinned([key], pinned, source);\n    }\n  };\n\n  ColumnController.prototype.setColumnsPinned = function (keys, pinned, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n      console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n      return;\n    }\n\n    this.columnAnimationService.start();\n    var actualPinned;\n\n    if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {\n      actualPinned = column_1.Column.PINNED_LEFT;\n    } else if (pinned === column_1.Column.PINNED_RIGHT) {\n      actualPinned = column_1.Column.PINNED_RIGHT;\n    } else {\n      actualPinned = null;\n    }\n\n    this.actionOnGridColumns(keys, function (col) {\n      if (col.getPinned() !== actualPinned) {\n        col.setPinned(actualPinned);\n        return true;\n      } else {\n        return false;\n      }\n    }, source, function () {\n      var event = {\n        type: events_1.Events.EVENT_COLUMN_PINNED,\n        pinned: actualPinned,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  }; // does an action on a set of columns. provides common functionality for looking up the\n  // columns based on key, getting a list of effected columns, and then updated the event\n  // with either one column (if it was just one col) or a list of columns\n  // used by: autoResize, setVisible, setPinned\n\n\n  ColumnController.prototype.actionOnGridColumns = function ( // the column keys this action will be on\n  keys, // the action to do - if this returns false, the column was skipped\n  // and won't be included in the event\n  action, // should return back a column event of the right type\n  source, createEvent) {\n    var _this = this;\n\n    if (utils_1._.missingOrEmpty(keys)) {\n      return;\n    }\n\n    var updatedColumns = [];\n    keys.forEach(function (key) {\n      var column = _this.getGridColumn(key);\n\n      if (!column) {\n        return;\n      } // need to check for false with type (ie !== instead of !=)\n      // as not returning anything (undefined) would also be false\n\n\n      var resultOfAction = action(column);\n\n      if (resultOfAction !== false) {\n        updatedColumns.push(column);\n      }\n    });\n\n    if (updatedColumns.length === 0) {\n      return;\n    }\n\n    this.updateDisplayedColumns(source);\n\n    if (utils_1._.exists(createEvent) && createEvent) {\n      var event_7 = createEvent();\n      event_7.columns = updatedColumns;\n      event_7.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n      this.eventService.dispatchEvent(event_7);\n    }\n  };\n\n  ColumnController.prototype.getDisplayedColBefore = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex > 0) {\n      return allDisplayedColumns[oldIndex - 1];\n    } else {\n      return null;\n    }\n  }; // used by:\n  // + rowRenderer -> for navigation\n\n\n  ColumnController.prototype.getDisplayedColAfter = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex < allDisplayedColumns.length - 1) {\n      return allDisplayedColumns[oldIndex + 1];\n    } else {\n      return null;\n    }\n  };\n\n  ColumnController.prototype.getDisplayedGroupAfter = function (columnGroup) {\n    // pick one col in this group at random\n    var col = columnGroup.getDisplayedLeafColumns()[0];\n    var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel();\n\n    while (true) {\n      // keep moving to the next col, until we get to another group\n      col = this.getDisplayedColAfter(col); // if no col after, means no group after\n\n      if (!col) {\n        return null;\n      } // get group at same level as the one we are looking for\n\n\n      var groupPointer = col.getParent();\n\n      while (groupPointer.getOriginalColumnGroup().getLevel() !== requiredLevel) {\n        groupPointer = groupPointer.getParent();\n      }\n\n      if (groupPointer !== columnGroup) {\n        return groupPointer;\n      }\n    }\n  };\n\n  ColumnController.prototype.isPinningLeft = function () {\n    return this.displayedLeftColumns.length > 0;\n  };\n\n  ColumnController.prototype.isPinningRight = function () {\n    return this.displayedRightColumns.length > 0;\n  };\n\n  ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n    var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n\n    if (this.groupAutoColumns && utils_1._.exists(this.groupAutoColumns)) {\n      this.groupAutoColumns.forEach(function (col) {\n        return result.push(col);\n      });\n    }\n\n    if (this.secondaryColumnsPresent && this.secondaryColumns) {\n      this.secondaryColumns.forEach(function (column) {\n        return result.push(column);\n      });\n    }\n\n    return result;\n  };\n\n  ColumnController.prototype.createStateItemFromColumn = function (column) {\n    var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n    var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n    var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n    return {\n      colId: column.getColId(),\n      hide: !column.isVisible(),\n      aggFunc: aggFunc,\n      width: column.getActualWidth(),\n      pivotIndex: pivotIndex,\n      pinned: column.getPinned(),\n      rowGroupIndex: rowGroupIndex\n    };\n  };\n\n  ColumnController.prototype.getColumnState = function () {\n    if (utils_1._.missing(this.primaryColumns)) {\n      return [];\n    }\n\n    var primaryColumnState = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n    var groupAutoColumnState = this.groupAutoColumns // if groupAutoCols, then include them\n    ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this)) // otherwise no\n    : [];\n    var columnStateList = groupAutoColumnState.concat(primaryColumnState);\n\n    if (!this.pivotMode) {\n      this.orderColumnStateList(columnStateList);\n    }\n\n    return columnStateList;\n  };\n\n  ColumnController.prototype.orderColumnStateList = function (columnStateList) {\n    var gridColumnIds = this.gridColumns.map(function (column) {\n      return column.getColId();\n    });\n    columnStateList.sort(function (itemA, itemB) {\n      var posA = gridColumnIds.indexOf(itemA.colId);\n      var posB = gridColumnIds.indexOf(itemB.colId);\n      return posA - posB;\n    });\n  };\n\n  ColumnController.prototype.resetColumnState = function (suppressEverythingEvent, source) {\n    // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n    // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n    // As a work around, developers should just put lockPosition columns first in their colDef list.\n    if (suppressEverythingEvent === void 0) {\n      suppressEverythingEvent = false;\n    }\n\n    if (source === void 0) {\n      source = \"api\";\n    } // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n\n\n    var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    var columnStates = []; // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n    // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n    // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n\n    var letRowGroupIndex = 1000;\n    var letPivotIndex = 1000;\n\n    if (primaryColumns) {\n      primaryColumns.forEach(function (column) {\n        var rowGroupIndex = column.getColDef().rowGroupIndex;\n        var rowGroup = column.getColDef().rowGroup;\n        var pivotIndex = column.getColDef().pivotIndex;\n        var pivot = column.getColDef().pivot;\n        var stateItem = {\n          colId: column.getColId(),\n          aggFunc: column.getColDef().aggFunc,\n          hide: column.getColDef().hide,\n          pinned: column.getColDef().pinned,\n          rowGroupIndex: rowGroupIndex,\n          pivotIndex: column.getColDef().pivotIndex,\n          width: column.getColDef().width\n        };\n\n        if (utils_1._.missing(rowGroupIndex) && rowGroup) {\n          stateItem.rowGroupIndex = letRowGroupIndex++;\n        }\n\n        if (utils_1._.missing(pivotIndex) && pivot) {\n          stateItem.pivotIndex = letPivotIndex++;\n        }\n\n        columnStates.push(stateItem);\n      });\n    }\n\n    this.setColumnState(columnStates, suppressEverythingEvent, source);\n  };\n\n  ColumnController.prototype.setColumnState = function (columnStates, suppressEverythingEvent, source) {\n    var _this = this;\n\n    if (suppressEverythingEvent === void 0) {\n      suppressEverythingEvent = false;\n    }\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (utils_1._.missingOrEmpty(this.primaryColumns)) {\n      return false;\n    }\n\n    var columnStateBefore = this.getColumnState();\n    this.autoGroupsNeedBuilding = true; // at the end below, this list will have all columns we got no state for\n\n    var columnsWithNoState = this.primaryColumns.slice();\n    this.rowGroupColumns = [];\n    this.valueColumns = [];\n    this.pivotColumns = [];\n    var success = true;\n    var rowGroupIndexes = {};\n    var pivotIndexes = {};\n    var autoGroupColumnStates = [];\n\n    if (columnStates) {\n      columnStates.forEach(function (state) {\n        // auto group columns are re-created so deferring syncing with ColumnState\n        if (utils_1._.exists(_this.getAutoColumn(state.colId))) {\n          autoGroupColumnStates.push(state);\n          return;\n        }\n\n        var column = _this.getPrimaryColumn(state.colId);\n\n        if (!column) {\n          console.warn('ag-grid: column ' + state.colId + ' not found');\n          success = false;\n        } else {\n          _this.syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, source);\n\n          utils_1._.removeFromArray(columnsWithNoState, column);\n        }\n      });\n    } // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n\n\n    columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this)); // sort the lists according to the indexes that were provided\n\n    this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));\n    this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));\n    this.updateGridColumns(); // sync newly created auto group columns with ColumnState\n\n    autoGroupColumnStates.forEach(function (stateItem) {\n      var autoCol = _this.getAutoColumn(stateItem.colId);\n\n      _this.syncColumnWithStateItem(autoCol, stateItem, rowGroupIndexes, pivotIndexes, source);\n    });\n\n    if (columnStates) {\n      var orderOfColIds_1 = columnStates.map(function (stateItem) {\n        return stateItem.colId;\n      });\n      this.gridColumns.sort(function (colA, colB) {\n        var indexA = orderOfColIds_1.indexOf(colA.getId());\n        var indexB = orderOfColIds_1.indexOf(colB.getId());\n        return indexA - indexB;\n      });\n    } // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n    // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n    // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n    // is less sexy for the code here, but it keeps consistency.\n\n\n    this.putFixedColumnsFirst();\n    this.updateDisplayedColumns(source);\n\n    if (!suppressEverythingEvent) {\n      var event_8 = {\n        type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_8);\n    }\n\n    this.raiseColumnEvents(columnStateBefore, source);\n    return success;\n  };\n\n  ColumnController.prototype.raiseColumnEvents = function (columnStateBefore, source) {\n    var _this = this;\n\n    if (this.gridOptionsWrapper.isSuppressSetColumnStateEvents()) {\n      return;\n    }\n\n    var columnStateAfter = this.getColumnState(); // raises generic ColumnEvents where all columns are returned rather than what has changed\n\n    var raiseEventWithAllColumns = function (eventType, idMapper, columns) {\n      var unchanged = utils_1._.compareArrays(columnStateBefore.map(idMapper).sort(), columnStateAfter.map(idMapper).sort());\n\n      if (unchanged) {\n        return;\n      } // returning all columns rather than what has changed!\n\n\n      var event = {\n        type: eventType,\n        columns: columns,\n        column: columns.length === 1 ? columns[0] : null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n\n      _this.eventService.dispatchEvent(event);\n    }; // determines which columns have changed according to supplied predicate\n\n\n    var getChangedColumns = function (changedPredicate) {\n      var changedColumns = [];\n      var columnStateBeforeMap = {};\n      columnStateBefore.forEach(function (col) {\n        columnStateBeforeMap[col.colId] = col;\n      });\n\n      _this.gridColumns.forEach(function (column) {\n        var colStateBefore = columnStateBeforeMap[column.getColId()];\n\n        if (!colStateBefore || changedPredicate(colStateBefore, column)) {\n          changedColumns.push(column);\n        }\n      });\n\n      return changedColumns;\n    }; // generic ColumnEvents which return current column list\n\n\n    var valueColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.aggFunc;\n    };\n\n    raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, valueColumnIdMapper, this.valueColumns);\n\n    var pivotColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.pivotIndex;\n    };\n\n    raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, pivotColumnIdMapper, this.pivotColumns);\n\n    var rowGroupColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.rowGroupIndex;\n    };\n\n    raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, rowGroupColumnIdMapper, this.rowGroupColumns); // specific ColumnEvents which return what's changed\n\n    var pinnedChangePredicate = function (cs, c) {\n      return cs.pinned !== c.getPinned();\n    };\n\n    this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n\n    var visibilityChangePredicate = function (cs, c) {\n      return cs.hide === c.isVisible();\n    };\n\n    var cols = getChangedColumns(visibilityChangePredicate);\n    this.raiseColumnVisibleEvent(cols, source);\n\n    var resizeChangePredicate = function (cs, c) {\n      return cs.width !== c.getActualWidth();\n    };\n\n    this.raiseColumnResizeEvent(getChangedColumns(resizeChangePredicate), source); // special handling for moved column events\n\n    this.raiseColumnMovedEvent(columnStateBefore, source);\n  };\n\n  ColumnController.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n    if (changedColumns.length > 0) {\n      var event_9 = {\n        type: events_1.Events.EVENT_COLUMN_PINNED,\n        pinned: null,\n        columns: changedColumns,\n        column: null,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_9);\n    }\n  };\n\n  ColumnController.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n    if (changedColumns.length > 0) {\n      var event_10 = {\n        type: events_1.Events.EVENT_COLUMN_VISIBLE,\n        visible: undefined,\n        columns: changedColumns,\n        column: null,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_10);\n    }\n  };\n\n  ColumnController.prototype.raiseColumnResizeEvent = function (changedColumns, source) {\n    if (changedColumns.length > 0) {\n      var event_11 = {\n        type: events_1.Events.EVENT_COLUMN_RESIZED,\n        columns: changedColumns,\n        column: null,\n        finished: true,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_11);\n    }\n  };\n\n  ColumnController.prototype.raiseColumnMovedEvent = function (columnStateBefore, source) {\n    var movedColumns = [];\n    var columnStateAfter = this.getColumnState();\n\n    var _loop_3 = function (i) {\n      var before = columnStateBefore[i];\n      var after = columnStateAfter[i]; // don't consider column if reintroduced or hidden\n\n      if (!before || after.hide) {\n        return \"continue\";\n      }\n\n      if (before.colId !== after.colId) {\n        var predicate = function (column) {\n          return column.getColId() === after.colId;\n        };\n\n        var movedColumn = utils_1._.find(this_1.allDisplayedColumns, predicate);\n\n        movedColumns.push(movedColumn);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < columnStateAfter.length; i++) {\n      _loop_3(i);\n    }\n\n    if (movedColumns.length > 0) {\n      var event_12 = {\n        type: events_1.Events.EVENT_COLUMN_MOVED,\n        columns: movedColumns,\n        column: null,\n        toIndex: undefined,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_12);\n    }\n  };\n\n  ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {\n    var indexA = indexes[colA.getId()];\n    var indexB = indexes[colB.getId()];\n    return indexA - indexB;\n  };\n\n  ColumnController.prototype.syncColumnWithNoState = function (column, source) {\n    column.setVisible(false, source);\n    column.setAggFunc(null);\n    column.setPinned(null);\n    column.setRowGroupActive(false, source);\n    column.setPivotActive(false, source);\n    column.setValueActive(false, source);\n  };\n\n  ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes, source) {\n    if (!column) {\n      return;\n    } // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n\n\n    column.setVisible(!stateItem.hide, source); // sets pinned to 'left' or 'right'\n\n    column.setPinned(stateItem.pinned); // if width provided and valid, use it, otherwise stick with the old width\n\n    var minColWidth = this.gridOptionsWrapper.getMinColWidth();\n\n    if (stateItem.width && minColWidth && stateItem.width >= minColWidth) {\n      column.setActualWidth(stateItem.width, source);\n    }\n\n    if (typeof stateItem.aggFunc === 'string') {\n      column.setAggFunc(stateItem.aggFunc);\n      column.setValueActive(true, source);\n      this.valueColumns.push(column);\n    } else {\n      if (utils_1._.exists(stateItem.aggFunc)) {\n        console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' + 'functions, register the functions first before using them in get/set state. This is because it is' + 'intended for the column state to be stored and retrieved as simple JSON.');\n      }\n\n      column.setAggFunc(null);\n      column.setValueActive(false, source);\n    }\n\n    if (typeof stateItem.rowGroupIndex === 'number') {\n      this.rowGroupColumns.push(column);\n      column.setRowGroupActive(true, source);\n      rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;\n    } else {\n      column.setRowGroupActive(false, source);\n    }\n\n    if (typeof stateItem.pivotIndex === 'number') {\n      this.pivotColumns.push(column);\n      column.setPivotActive(true, source);\n      pivotIndexes[column.getId()] = stateItem.pivotIndex;\n    } else {\n      column.setPivotActive(false, source);\n    }\n  };\n\n  ColumnController.prototype.getGridColumns = function (keys) {\n    return this.getColumns(keys, this.getGridColumn.bind(this));\n  };\n\n  ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {\n    var foundColumns = [];\n\n    if (keys) {\n      keys.forEach(function (key) {\n        var column = columnLookupCallback(key);\n\n        if (column) {\n          foundColumns.push(column);\n        }\n      });\n    }\n\n    return foundColumns;\n  }; // used by growGroupPanel\n\n\n  ColumnController.prototype.getColumnWithValidation = function (key) {\n    if (key == null) {\n      return null;\n    }\n\n    var column = this.getGridColumn(key);\n\n    if (!column) {\n      console.warn('ag-Grid: could not find column ' + key);\n    }\n\n    return column;\n  };\n\n  ColumnController.prototype.getPrimaryColumn = function (key) {\n    return this.getColumn(key, this.primaryColumns);\n  };\n\n  ColumnController.prototype.getGridColumn = function (key) {\n    return this.getColumn(key, this.gridColumns);\n  };\n\n  ColumnController.prototype.getColumn = function (key, columnList) {\n    if (!key) {\n      return null;\n    }\n\n    for (var i = 0; i < columnList.length; i++) {\n      if (this.columnsMatch(columnList[i], key)) {\n        return columnList[i];\n      }\n    }\n\n    return this.getAutoColumn(key);\n  };\n\n  ColumnController.prototype.getAutoColumn = function (key) {\n    var _this = this;\n\n    if (!this.groupAutoColumns || !utils_1._.exists(this.groupAutoColumns) || utils_1._.missing(this.groupAutoColumns)) {\n      return null;\n    }\n\n    return utils_1._.find(this.groupAutoColumns, function (groupCol) {\n      return _this.columnsMatch(groupCol, key);\n    });\n  };\n\n  ColumnController.prototype.columnsMatch = function (column, key) {\n    var columnMatches = column === key;\n    var colDefMatches = column.getColDef() === key;\n    var idMatches = column.getColId() == key;\n    return columnMatches || colDefMatches || idMatches;\n  };\n\n  ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n    if (includeAggFunc === void 0) {\n      includeAggFunc = false;\n    }\n\n    if (!column) {\n      return null;\n    }\n\n    var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n\n    if (includeAggFunc) {\n      return this.wrapHeaderNameWithAggFunc(column, headerName);\n    } else {\n      return headerName;\n    }\n  };\n\n  ColumnController.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n    var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n\n    if (colGroupDef) {\n      return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n    } else {\n      return null;\n    }\n  };\n\n  ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n    return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n  }; // location is where the column is going to appear, ie who is calling us\n\n\n  ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n    var headerValueGetter = colDef.headerValueGetter;\n\n    if (headerValueGetter) {\n      var params = {\n        colDef: colDef,\n        column: column,\n        columnGroup: columnGroup,\n        originalColumnGroup: originalColumnGroup,\n        location: location,\n        api: this.gridOptionsWrapper.getApi(),\n        context: this.gridOptionsWrapper.getContext()\n      };\n\n      if (typeof headerValueGetter === 'function') {\n        // valueGetter is a function, so just call it\n        return headerValueGetter(params);\n      } else if (typeof headerValueGetter === 'string') {\n        // valueGetter is an expression, so execute the expression\n        return this.expressionService.evaluate(headerValueGetter, params);\n      } else {\n        console.warn('ag-grid: headerValueGetter must be a function or a string');\n        return '';\n      }\n    } else if (colDef.headerName != null) {\n      return colDef.headerName;\n    } else if (colDef.field) {\n      return utils_1._.camelCaseToHumanText(colDef.field);\n    } else {\n      return '';\n    }\n  };\n  /*\n      private getHeaderGroupName(columnGroup: ColumnGroup): string {\n          let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n          let headerValueGetter = colGroupDef.headerValueGetter;\n           if (headerValueGetter) {\n              let params = {\n                  columnGroup: columnGroup,\n                  colDef: colGroupDef,\n                  api: this.gridOptionsWrapper.getApi(),\n                  context: this.gridOptionsWrapper.getContext()\n              };\n               if (typeof headerValueGetter === 'function') {\n                  // valueGetter is a function, so just call it\n                  return headerValueGetter(params);\n              } else if (typeof headerValueGetter === 'string') {\n                  // valueGetter is an expression, so execute the expression\n                  return this.expressionService.evaluate(headerValueGetter, params);\n              } else {\n                  console.warn('ag-grid: headerValueGetter must be a function or a string');\n                  return '';\n              }\n          } else {\n              return colGroupDef.headerName;\n          }\n      }\n  */\n\n\n  ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n    if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n      return headerName;\n    } // only columns with aggregation active can have aggregations\n\n\n    var pivotValueColumn = column.getColDef().pivotValueColumn;\n\n    var pivotActiveOnThisColumn = utils_1._.exists(pivotValueColumn);\n\n    var aggFunc = null;\n    var aggFuncFound; // otherwise we have a measure that is active, and we are doing aggregation on it\n\n    if (pivotActiveOnThisColumn) {\n      aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n      aggFuncFound = true;\n    } else {\n      var measureActive = column.isValueActive();\n      var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n\n      if (measureActive && aggregationPresent) {\n        aggFunc = column.getAggFunc();\n        aggFuncFound = true;\n      } else {\n        aggFuncFound = false;\n      }\n    }\n\n    if (aggFuncFound) {\n      var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'func';\n      var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n      var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n      return aggFuncStringTranslated + \"(\" + headerName + \")\";\n    } else {\n      return headerName;\n    }\n  }; // returns the group with matching colId and instanceId. If instanceId is missing,\n  // matches only on the colId.\n\n\n  ColumnController.prototype.getColumnGroup = function (colId, instanceId) {\n    if (!colId) {\n      return null;\n    }\n\n    if (colId instanceof columnGroup_1.ColumnGroup) {\n      return colId;\n    }\n\n    var allColumnGroups = this.getAllDisplayedColumnGroups();\n    var checkInstanceId = typeof instanceId === 'number';\n    var result = null;\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof columnGroup_1.ColumnGroup) {\n        var columnGroup = child;\n        var matched = void 0;\n\n        if (checkInstanceId) {\n          matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n        } else {\n          matched = colId === columnGroup.getGroupId();\n        }\n\n        if (matched) {\n          result = columnGroup;\n        }\n      }\n    });\n    return result;\n  };\n\n  ColumnController.prototype.isReady = function () {\n    return this.ready;\n  };\n\n  ColumnController.prototype.createValueColumns = function (source, oldPrimaryColumns) {\n    this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) {\n      return col.setValueActive(flag, source);\n    }, // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n    function () {\n      return null;\n    }, // aggFunc is a string, so return it's existence\n    function (colDef) {\n      return !!colDef.aggFunc;\n    }); // all new columns added will have aggFunc missing, so set it to what is in the colDef\n\n    this.valueColumns.forEach(function (col) {\n      if (!col.getAggFunc()) {\n        col.setAggFunc(col.getColDef().aggFunc);\n      }\n    });\n  };\n\n  ColumnController.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n    this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) {\n      return col.setRowGroupActive(flag, source);\n    }, function (colDef) {\n      return colDef.rowGroupIndex;\n    }, function (colDef) {\n      return colDef.rowGroup;\n    });\n  };\n\n  ColumnController.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getValueFunc) {\n    var _this = this;\n\n    if (!previousCols) {\n      previousCols = [];\n    } // remove cols that no longer exist\n\n\n    var colPresentInPrimaryFunc = function (col) {\n      return _this.primaryColumns.indexOf(col) >= 0;\n    };\n\n    var colMissingFromPrimaryFunc = function (col) {\n      return _this.primaryColumns.indexOf(col) < 0;\n    };\n\n    var colNewFunc = function (col) {\n      return !oldPrimaryColumns || oldPrimaryColumns.indexOf(col) < 0;\n    };\n\n    var removedCols = previousCols.filter(colMissingFromPrimaryFunc);\n    var existingCols = previousCols.filter(colPresentInPrimaryFunc);\n    var newPrimaryCols = this.primaryColumns.filter(colNewFunc);\n    removedCols.forEach(function (col) {\n      return setFlagFunc(col, false);\n    });\n    var newCols = []; // we only want to work on new columns, as old columns already got processed first time around\n    // pull out items with xxxIndex\n\n    newPrimaryCols.forEach(function (col) {\n      var index = getIndexFunc(col.getColDef());\n\n      if (typeof index === 'number') {\n        newCols.push(col);\n      }\n    }); // then sort them\n\n    newCols.sort(function (colA, colB) {\n      var indexA = getIndexFunc(colA.getColDef());\n      var indexB = getIndexFunc(colB.getColDef());\n\n      if (indexA === indexB) {\n        return 0;\n      } else if (indexA < indexB) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }); // now just pull out items xxx (boolean value), they will be added at the end\n    // after the indexed ones, but in the order the columns appear\n\n    newPrimaryCols.forEach(function (col) {\n      var booleanValue = getValueFunc(col.getColDef());\n\n      if (booleanValue) {\n        // if user already specified xxxIndex then we skip it as this col already included\n        if (newCols.indexOf(col) >= 0) {\n          return;\n        }\n\n        newCols.push(col);\n      }\n    });\n    newCols.forEach(function (col) {\n      return setFlagFunc(col, true);\n    });\n    var res = existingCols.concat(newCols);\n    return res;\n  };\n\n  ColumnController.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n    this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) {\n      return col.setPivotActive(flag, source);\n    }, function (colDef) {\n      return colDef.pivotIndex;\n    }, function (colDef) {\n      return colDef.pivot;\n    });\n  };\n\n  ColumnController.prototype.resetColumnGroupState = function (source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var stateItems = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n      if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        var groupState = {\n          groupId: child.getGroupId(),\n          open: child.getColGroupDef().openByDefault\n        };\n        stateItems.push(groupState);\n      }\n    });\n    this.setColumnGroupState(stateItems, source);\n  };\n\n  ColumnController.prototype.getColumnGroupState = function () {\n    var columnGroupState = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        var originalColumnGroup = node;\n        columnGroupState.push({\n          groupId: originalColumnGroup.getGroupId(),\n          open: originalColumnGroup.isExpanded()\n        });\n      }\n    });\n    return columnGroupState;\n  };\n\n  ColumnController.prototype.setColumnGroupState = function (stateItems, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    var impactedGroups = [];\n    stateItems.forEach(function (stateItem) {\n      var groupKey = stateItem.groupId;\n      var newValue = stateItem.open;\n\n      var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n\n      if (!originalColumnGroup) {\n        return;\n      }\n\n      if (originalColumnGroup.isExpanded() === newValue) {\n        return;\n      }\n\n      _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n\n      originalColumnGroup.setExpanded(newValue);\n      impactedGroups.push(originalColumnGroup);\n    });\n    this.updateGroupsAndDisplayedColumns(source);\n    this.setFirstRightAndLastLeftPinned(source);\n    impactedGroups.forEach(function (originalColumnGroup) {\n      var event = {\n        type: events_1.Events.EVENT_COLUMN_GROUP_OPENED,\n        columnGroup: originalColumnGroup,\n        api: _this.gridApi,\n        columnApi: _this.columnApi\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n    this.columnAnimationService.finish();\n  }; // called by headerRenderer - when a header is opened or closed\n\n\n  ColumnController.prototype.setColumnGroupOpened = function (key, newValue, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var keyAsString;\n\n    if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {\n      keyAsString = key.getId();\n    } else {\n      keyAsString = key;\n    }\n\n    this.setColumnGroupState([{\n      groupId: keyAsString,\n      open: newValue\n    }], source);\n  };\n\n  ColumnController.prototype.getOriginalColumnGroup = function (key) {\n    if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {\n      return key;\n    }\n\n    if (typeof key !== 'string') {\n      console.error('ag-Grid: group key must be a string');\n    } // otherwise, search for the column group by id\n\n\n    var res = null;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        var originalColumnGroup = node;\n\n        if (originalColumnGroup.getId() === key) {\n          res = originalColumnGroup;\n        }\n      }\n    });\n    return res;\n  };\n\n  ColumnController.prototype.calculateColumnsForDisplay = function () {\n    var _this = this;\n\n    var columnsForDisplay;\n\n    if (this.pivotMode && !this.secondaryColumnsPresent) {\n      // pivot mode is on, but we are not pivoting, so we only\n      // show columns we are aggregating on\n      columnsForDisplay = utils_1._.filter(this.gridColumns, function (column) {\n        var isAutoGroupCol = _this.groupAutoColumns && _this.groupAutoColumns.indexOf(column) >= 0;\n        var isValueCol = _this.valueColumns && _this.valueColumns.indexOf(column) >= 0;\n        return isAutoGroupCol || isValueCol;\n      });\n    } else {\n      // otherwise continue as normal. this can be working on the primary\n      // or secondary columns, whatever the gridColumns are set to\n      columnsForDisplay = utils_1._.filter(this.gridColumns, function (column) {\n        // keep col if a) it's auto-group or b) it's visible\n        var isAutoGroupCol = _this.groupAutoColumns && _this.groupAutoColumns.indexOf(column) >= 0;\n        return isAutoGroupCol || column.isVisible();\n      });\n    }\n\n    return columnsForDisplay;\n  };\n\n  ColumnController.prototype.checkColSpanActiveInCols = function (columns) {\n    var result = false;\n    columns.forEach(function (col) {\n      if (utils_1._.exists(col.getColDef().colSpan)) {\n        result = true;\n      }\n    });\n    return result;\n  };\n\n  ColumnController.prototype.calculateColumnsForGroupDisplay = function () {\n    var _this = this;\n\n    this.groupDisplayColumns = [];\n\n    var checkFunc = function (col) {\n      var colDef = col.getColDef();\n\n      if (colDef && utils_1._.exists(colDef.showRowGroup)) {\n        _this.groupDisplayColumns.push(col);\n      }\n    };\n\n    this.gridColumns.forEach(checkFunc);\n\n    if (this.groupAutoColumns) {\n      this.groupAutoColumns.forEach(checkFunc);\n    }\n  };\n\n  ColumnController.prototype.getGroupDisplayColumns = function () {\n    return this.groupDisplayColumns;\n  };\n\n  ColumnController.prototype.updateDisplayedColumns = function (source) {\n    var columnsForDisplay = this.calculateColumnsForDisplay();\n    this.buildDisplayedTrees(columnsForDisplay);\n    this.calculateColumnsForGroupDisplay(); // also called when group opened/closed\n\n    this.updateGroupsAndDisplayedColumns(source); // also called when group opened/closed\n\n    this.setFirstRightAndLastLeftPinned(source);\n  };\n\n  ColumnController.prototype.isSecondaryColumnsPresent = function () {\n    return this.secondaryColumnsPresent;\n  };\n\n  ColumnController.prototype.setSecondaryColumns = function (colDefs, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var newColsPresent = colDefs && colDefs.length > 0; // if not cols passed, and we had to cols anyway, then do nothing\n\n    if (!newColsPresent && !this.secondaryColumnsPresent) {\n      return;\n    }\n\n    if (newColsPresent) {\n      this.processSecondaryColumnDefinitions(colDefs);\n      var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n      this.secondaryBalancedTree = balancedTreeResult.columnTree;\n      this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n      this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n      this.secondaryColumnsPresent = true;\n    } else {\n      this.secondaryBalancedTree = null;\n      this.secondaryHeaderRowCount = -1;\n      this.secondaryColumns = null;\n      this.secondaryColumnsPresent = false;\n    }\n\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n  };\n\n  ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n    var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n    var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n\n    if (!columnCallback && !groupCallback) {\n      return undefined;\n    }\n\n    if (colDefs) {\n      searchForColDefs(colDefs);\n    }\n\n    function searchForColDefs(colDefs2) {\n      colDefs2.forEach(function (abstractColDef) {\n        var isGroup = utils_1._.exists(abstractColDef.children);\n\n        if (isGroup) {\n          var colGroupDef = abstractColDef;\n\n          if (groupCallback) {\n            groupCallback(colGroupDef);\n          }\n\n          searchForColDefs(colGroupDef.children);\n        } else {\n          var colDef = abstractColDef;\n\n          if (columnCallback) {\n            columnCallback(colDef);\n          }\n        }\n      });\n    }\n  }; // called from: setColumnState, setColumnDefs, setSecondaryColumns\n\n\n  ColumnController.prototype.updateGridColumns = function () {\n    if (this.gridColsArePrimary) {\n      this.lastPrimaryOrder = this.gridColumns;\n    }\n\n    if (this.secondaryColumns && this.secondaryBalancedTree) {\n      this.gridBalancedTree = this.secondaryBalancedTree.slice();\n      this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n      this.gridColumns = this.secondaryColumns.slice();\n      this.gridColsArePrimary = false;\n    } else {\n      this.gridBalancedTree = this.primaryColumnTree.slice();\n      this.gridHeaderRowCount = this.primaryHeaderRowCount;\n      this.gridColumns = this.primaryColumns.slice();\n      this.gridColsArePrimary = true; // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n      // when this happens (eg if user moved a column) rather than revert back to the original column order.\n      // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n\n      this.orderGridColsLikeLastPrimary();\n    }\n\n    this.addAutoGroupToGridColumns();\n    this.autoRowHeightColumns = this.gridColumns.filter(function (col) {\n      return col.getColDef().autoHeight;\n    });\n    this.putFixedColumnsFirst();\n    this.setupQuickFilterColumns();\n    this.clearDisplayedColumns();\n    this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n    var event = {\n      type: events_1.Events.EVENT_GRID_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.orderGridColsLikeLastPrimary = function () {\n    var _this = this;\n\n    if (utils_1._.missing(this.lastPrimaryOrder)) {\n      return;\n    } // only do the sort if at least one column is accounted for. columns will be not accounted for\n    // if changing from secondary to primary columns\n\n\n    var noColsFound = true;\n    this.gridColumns.forEach(function (col) {\n      if (_this.lastPrimaryOrder.indexOf(col) >= 0) {\n        noColsFound = false;\n      }\n    });\n\n    if (noColsFound) {\n      return;\n    } // order cols in the same order as before. we need to make sure that all\n    // cols still exists, so filter out any that no longer exist.\n\n\n    var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) {\n      return _this.gridColumns.indexOf(col) >= 0;\n    });\n    var newColsOrdered = this.gridColumns.filter(function (col) {\n      return oldColsOrdered.indexOf(col) < 0;\n    }); // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n\n    var newGridColumns = oldColsOrdered.slice();\n    newColsOrdered.forEach(function (newCol) {\n      var parent = newCol.getOriginalParent(); // if no parent, means we are not grouping, so just add the column to the end\n\n      if (!parent) {\n        newGridColumns.push(newCol);\n        return;\n      } // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n      // own) then go up one level and look for siblings there.\n\n\n      var siblings = [];\n\n      while (!siblings.length && parent) {\n        var leafCols = parent.getLeafColumns();\n        leafCols.forEach(function (leafCol) {\n          var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n          var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n\n          if (presentInNewGriColumns && noYetInSiblings) {\n            siblings.push(leafCol);\n          }\n        });\n        parent = parent.getOriginalParent();\n      } // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n\n\n      if (!siblings.length) {\n        newGridColumns.push(newCol);\n        return;\n      } // find index of last column in the group\n\n\n      var indexes = siblings.map(function (col) {\n        return newGridColumns.indexOf(col);\n      });\n      var lastIndex = Math.max.apply(Math, indexes);\n\n      utils_1._.insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n    });\n    this.gridColumns = newGridColumns;\n  };\n\n  ColumnController.prototype.isPrimaryColumnGroupsPresent = function () {\n    return this.primaryHeaderRowCount > 1;\n  }; // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n  // following scenarios:\n  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n\n\n  ColumnController.prototype.setupQuickFilterColumns = function () {\n    if (this.groupAutoColumns) {\n      this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n    } else {\n      this.columnsForQuickFilter = this.primaryColumns;\n    }\n  };\n\n  ColumnController.prototype.putFixedColumnsFirst = function () {\n    var locked = this.gridColumns.filter(function (c) {\n      return c.getColDef().lockPosition;\n    });\n    var unlocked = this.gridColumns.filter(function (c) {\n      return !c.getColDef().lockPosition;\n    });\n    this.gridColumns = locked.concat(unlocked);\n  };\n\n  ColumnController.prototype.addAutoGroupToGridColumns = function () {\n    // add in auto-group here\n    this.createGroupAutoColumnsIfNeeded();\n\n    if (utils_1._.missing(this.groupAutoColumns)) {\n      return;\n    }\n\n    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n    var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n    this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n  }; // gets called after we copy down grid columns, to make sure any part of the gui\n  // that tries to draw, eg the header, it will get empty lists of columns rather\n  // than stale columns. for example, the header will received gridColumnsChanged\n  // event, so will try and draw, but it will draw successfully when it acts on the\n  // virtualColumnsChanged event\n\n\n  ColumnController.prototype.clearDisplayedColumns = function () {\n    this.displayedLeftColumnTree = [];\n    this.displayedRightColumnTree = [];\n    this.displayedCentreColumnTree = [];\n    this.displayedLeftHeaderRows = {};\n    this.displayedRightHeaderRows = {};\n    this.displayedCentreHeaderRows = {};\n    this.displayedLeftColumns = [];\n    this.displayedRightColumns = [];\n    this.displayedCenterColumns = [];\n    this.allDisplayedColumns = [];\n    this.allDisplayedVirtualColumns = [];\n  };\n\n  ColumnController.prototype.updateGroupsAndDisplayedColumns = function (source) {\n    this.updateOpenClosedVisibilityInColumnGroups();\n    this.updateDisplayedColumnsFromTrees(source);\n    this.updateVirtualSets();\n    this.updateBodyWidths(); // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n\n    var event = {\n      type: events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.updateDisplayedColumnsFromTrees = function (source) {\n    this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);\n    this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);\n    this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);\n    this.setupAllDisplayedColumns();\n    this.setLeftValues(source);\n  };\n\n  ColumnController.prototype.setupAllDisplayedColumns = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.allDisplayedColumns = this.displayedRightColumns.concat(this.displayedCenterColumns).concat(this.displayedLeftColumns);\n    } else {\n      this.allDisplayedColumns = this.displayedLeftColumns.concat(this.displayedCenterColumns).concat(this.displayedRightColumns);\n    }\n  }; // sets the left pixel position of each column\n\n\n  ColumnController.prototype.setLeftValues = function (source) {\n    this.setLeftValuesOfColumns(source);\n    this.setLeftValuesOfGroups();\n  };\n\n  ColumnController.prototype.setLeftValuesOfColumns = function (source) {\n    var _this = this; // go through each list of displayed columns\n\n\n    var allColumns = this.primaryColumns.slice(0); // let totalColumnWidth = this.getWidthOfColsInList()\n\n    var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n    [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {\n      if (doingRtl) {\n        // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n        var left_1 = _this.getWidthOfColsInList(columns);\n\n        columns.forEach(function (column) {\n          left_1 -= column.getActualWidth();\n          column.setLeft(left_1, source);\n        });\n      } else {\n        // otherwise normal LTR, we start at zero\n        var left_2 = 0;\n        columns.forEach(function (column) {\n          column.setLeft(left_2, source);\n          left_2 += column.getActualWidth();\n        });\n      }\n\n      utils_1._.removeAllFromArray(allColumns, columns);\n    }); // items left in allColumns are columns not displayed, so remove the left position. this is\n    // important for the rows, as if a col is made visible, then taken out, then made visible again,\n    // we don't want the animation of the cell floating in from the old position, whatever that was.\n\n    allColumns.forEach(function (column) {\n      column.setLeft(null, source);\n    });\n  };\n\n  ColumnController.prototype.setLeftValuesOfGroups = function () {\n    // a groups left value is the lest left value of it's children\n    [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {\n      columns.forEach(function (column) {\n        if (column instanceof columnGroup_1.ColumnGroup) {\n          var columnGroup = column;\n          columnGroup.checkLeft();\n        }\n      });\n    });\n  };\n\n  ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {\n    displayedColumns.length = 0;\n    this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {\n      if (child instanceof column_1.Column) {\n        displayedColumns.push(child);\n      }\n    });\n  };\n\n  ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {\n    if (this.suppressColumnVirtualisation) {\n      // no virtualisation, so don't filter\n      this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;\n    } else {\n      // filter out what should be visible\n      this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();\n    }\n\n    this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns.concat(this.displayedLeftColumns).concat(this.displayedRightColumns); // return map of virtual col id's, for easy lookup when building the groups.\n    // the map will be colId=>true, ie col id's mapping to 'true'.\n\n    var result = {};\n    this.allDisplayedVirtualColumns.forEach(function (col) {\n      result[col.getId()] = true;\n    });\n    return result;\n  };\n\n  ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n    var result;\n\n    switch (type) {\n      case column_1.Column.PINNED_LEFT:\n        result = this.displayedLeftHeaderRows[dept];\n        break;\n\n      case column_1.Column.PINNED_RIGHT:\n        result = this.displayedRightHeaderRows[dept];\n        break;\n\n      default:\n        result = this.displayedCentreHeaderRows[dept];\n        break;\n    }\n\n    if (utils_1._.missing(result)) {\n      result = [];\n    }\n\n    return result;\n  };\n\n  ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {\n    // go through each group, see if any of it's cols are displayed, and if yes,\n    // then this group is included\n    this.displayedLeftHeaderRows = {};\n    this.displayedRightHeaderRows = {};\n    this.displayedCentreHeaderRows = {};\n    testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);\n    testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);\n    testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);\n\n    function testGroup(children, result, dept) {\n      var returnValue = false;\n\n      for (var i = 0; i < children.length; i++) {\n        // see if this item is within viewport\n        var child = children[i];\n        var addThisItem = void 0;\n\n        if (child instanceof column_1.Column) {\n          // for column, test if column is included\n          addThisItem = virtualColIds[child.getId()] === true;\n        } else {\n          // if group, base decision on children\n          var columnGroup = child;\n          addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);\n        }\n\n        if (addThisItem) {\n          returnValue = true;\n\n          if (!result[dept]) {\n            result[dept] = [];\n          }\n\n          result[dept].push(child);\n        }\n      }\n\n      return returnValue;\n    }\n  };\n\n  ColumnController.prototype.updateVirtualSets = function () {\n    var virtualColIds = this.updateDisplayedCenterVirtualColumns();\n    this.updateDisplayedVirtualGroups(virtualColIds);\n  };\n\n  ColumnController.prototype.filterOutColumnsWithinViewport = function () {\n    return utils_1._.filter(this.displayedCenterColumns, this.isColumnInViewport.bind(this));\n  }; // called from api\n\n\n  ColumnController.prototype.sizeColumnsToFit = function (gridWidth, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    } // avoid divide by zero\n\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n\n    if (gridWidth <= 0 || allDisplayedColumns.length === 0) {\n      return;\n    }\n\n    var colsToNotSpread = utils_1._.filter(allDisplayedColumns, function (column) {\n      return column.getColDef().suppressSizeToFit === true;\n    });\n\n    var colsToSpread = utils_1._.filter(allDisplayedColumns, function (column) {\n      return column.getColDef().suppressSizeToFit !== true;\n    }); // make a copy of the cols that are going to be resized\n\n\n    var colsToFireEventFor = colsToSpread.slice(0);\n    var finishedResizing = false;\n\n    while (!finishedResizing) {\n      finishedResizing = true;\n      var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n\n      if (availablePixels <= 0) {\n        // no width, set everything to minimum\n        colsToSpread.forEach(function (column) {\n          column.setMinimum(source);\n        });\n      } else {\n        var scale = availablePixels / this.getWidthOfColsInList(colsToSpread); // we set the pixels for the last col based on what's left, as otherwise\n        // we could be a pixel or two short or extra because of rounding errors.\n\n        var pixelsForLastCol = availablePixels; // backwards through loop, as we are removing items as we go\n\n        for (var i = colsToSpread.length - 1; i >= 0; i--) {\n          var column = colsToSpread[i];\n          var newWidth = Math.round(column.getActualWidth() * scale);\n\n          if (newWidth < column.getMinWidth()) {\n            column.setMinimum(source);\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else if (column.isGreaterThanMax(newWidth)) {\n            column.setActualWidth(column.getMaxWidth(), source);\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else {\n            var onLastCol = i === 0;\n\n            if (onLastCol) {\n              column.setActualWidth(pixelsForLastCol, source);\n            } else {\n              column.setActualWidth(newWidth, source);\n            }\n          }\n\n          pixelsForLastCol -= newWidth;\n        }\n      }\n    }\n\n    this.setLeftValues(source);\n    this.updateBodyWidths();\n    colsToFireEventFor.forEach(function (column) {\n      var event = {\n        type: events_1.Events.EVENT_COLUMN_RESIZED,\n        column: column,\n        columns: [column],\n        finished: true,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: \"sizeColumnsToFit\"\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n\n    function moveToNotSpread(column) {\n      utils_1._.removeFromArray(colsToSpread, column);\n\n      colsToNotSpread.push(column);\n    }\n  };\n\n  ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {\n    var leftVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n      return column.getPinned() === 'left';\n    });\n\n    var rightVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n      return column.getPinned() === 'right';\n    });\n\n    var centerVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n      return column.getPinned() !== 'left' && column.getPinned() !== 'right';\n    });\n\n    var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();\n    this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, column_1.Column.PINNED_LEFT, this.displayedLeftColumnTree);\n    this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, column_1.Column.PINNED_RIGHT, this.displayedRightColumnTree);\n    this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedCentreColumnTree);\n  };\n\n  ColumnController.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n    var allColumnGroups = this.getAllDisplayedColumnGroups();\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof columnGroup_1.ColumnGroup) {\n        var columnGroup = child;\n        columnGroup.calculateDisplayedColumns();\n      }\n    });\n  };\n\n  ColumnController.prototype.getGroupAutoColumns = function () {\n    return this.groupAutoColumns;\n  };\n\n  ColumnController.prototype.createGroupAutoColumnsIfNeeded = function () {\n    if (!this.autoGroupsNeedBuilding) {\n      return;\n    }\n\n    this.autoGroupsNeedBuilding = false;\n    var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode); // we never suppress auto col for pivot mode, as there is no way for user to provide group columns\n    // in pivot mode. pivot mode has auto group column (provide by grid) and value columns (provided by\n    // pivot feature in the grid).\n\n    var groupSuppressAutoColumn = this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.pivotMode;\n    var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n    var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n    var needAutoColumns = groupingActive && !groupSuppressAutoColumn && !groupFullWidthRow && !groupSuppressRow;\n\n    if (needAutoColumns) {\n      var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n      var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n\n      if (autoColsDifferent) {\n        this.groupAutoColumns = newAutoGroupCols;\n      }\n    } else {\n      this.groupAutoColumns = null;\n    }\n  };\n\n  ColumnController.prototype.autoColsEqual = function (colsA, colsB) {\n    var bothMissing = !colsA && !colsB;\n\n    if (bothMissing) {\n      return true;\n    }\n\n    var atLeastOneListMissing = !colsA || !colsB;\n\n    if (atLeastOneListMissing) {\n      return false;\n    }\n\n    if (colsA.length !== colsB.length) {\n      return false;\n    }\n\n    for (var i = 0; i < colsA.length; i++) {\n      var colA = colsA[i];\n      var colB = colsB[i];\n\n      if (colA.getColId() !== colB.getColId()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ColumnController.prototype.getWidthOfColsInList = function (columnList) {\n    var result = 0;\n\n    for (var i = 0; i < columnList.length; i++) {\n      result += columnList[i].getActualWidth();\n    }\n\n    return result;\n  };\n\n  ColumnController.prototype.getGridBalancedTree = function () {\n    return this.gridBalancedTree;\n  };\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], ColumnController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('expressionService'), __metadata(\"design:type\", expressionService_1.ExpressionService)], ColumnController.prototype, \"expressionService\", void 0);\n\n  __decorate([context_1.Autowired('columnFactory'), __metadata(\"design:type\", columnFactory_1.ColumnFactory)], ColumnController.prototype, \"columnFactory\", void 0);\n\n  __decorate([context_1.Autowired('displayedGroupCreator'), __metadata(\"design:type\", displayedGroupCreator_1.DisplayedGroupCreator)], ColumnController.prototype, \"displayedGroupCreator\", void 0);\n\n  __decorate([context_1.Autowired('autoWidthCalculator'), __metadata(\"design:type\", autoWidthCalculator_1.AutoWidthCalculator)], ColumnController.prototype, \"autoWidthCalculator\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], ColumnController.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('columnUtils'), __metadata(\"design:type\", columnUtils_1.ColumnUtils)], ColumnController.prototype, \"columnUtils\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], ColumnController.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired('columnAnimationService'), __metadata(\"design:type\", columnAnimationService_1.ColumnAnimationService)], ColumnController.prototype, \"columnAnimationService\", void 0);\n\n  __decorate([context_1.Autowired('autoGroupColService'), __metadata(\"design:type\", autoGroupColService_1.AutoGroupColService)], ColumnController.prototype, \"autoGroupColService\", void 0);\n\n  __decorate([context_1.Optional('aggFuncService'), __metadata(\"design:type\", Object)], ColumnController.prototype, \"aggFuncService\", void 0);\n\n  __decorate([context_1.Optional('valueCache'), __metadata(\"design:type\", valueCache_1.ValueCache)], ColumnController.prototype, \"valueCache\", void 0);\n\n  __decorate([context_1.Autowired('columnApi'), __metadata(\"design:type\", columnApi_1.ColumnApi)], ColumnController.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.Autowired('gridApi'), __metadata(\"design:type\", gridApi_1.GridApi)], ColumnController.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ColumnController.prototype, \"init\", null);\n\n  __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], ColumnController.prototype, \"setBeans\", null);\n\n  ColumnController = __decorate([context_1.Bean('columnController')], ColumnController);\n  return ColumnController;\n}();\n\nexports.ColumnController = ColumnController;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/columnController/columnController.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","__param","paramIndex","decorator","exports","value","columnGroup_1","require","column_1","gridOptionsWrapper_1","expressionService_1","columnFactory_1","displayedGroupCreator_1","autoWidthCalculator_1","eventService_1","columnUtils_1","logger_1","events_1","originalColumnGroup_1","groupInstanceIdCreator_1","context_1","columnAnimationService_1","autoGroupColService_1","valueCache_1","gridApi_1","columnApi_1","utils_1","ColumnController","primaryHeaderRowCount","secondaryHeaderRowCount","secondaryColumnsPresent","gridHeaderRowCount","displayedLeftColumns","displayedRightColumns","displayedCenterColumns","allDisplayedColumns","allDisplayedVirtualColumns","allDisplayedCenterVirtualColumns","rowGroupColumns","valueColumns","pivotColumns","ready","autoGroupsNeedBuilding","pivotMode","bodyWidth","leftWidth","rightWidth","bodyWidthDirty","prototype","init","gridOptionsWrapper","isPivotMode","suppressColumnVirtualisation","isSuppressColumnVirtualisation","isPivotSettingAllowed","usingTreeData","isTreeData","setColumnDefs","columnDefs","source","colsPreviouslyExisted","valueCache","expire","oldPrimaryColumns","primaryColumns","balancedTreeResult","columnFactory","createColumnTree","primaryColumnTree","columnTree","treeDept","getColumnsFromTree","extractRowGroupColumns","extractPivotColumns","createValueColumns","updateGridColumns","updateDisplayedColumns","checkDisplayedVirtualColumns","isDeltaColumnMode","resetColumnState","eventEverythingChanged","type","Events","EVENT_COLUMN_EVERYTHING_CHANGED","api","gridApi","columnApi","eventService","dispatchEvent","newColumnsLoadedEvent","EVENT_NEW_COLUMNS_LOADED","isAutoRowHeightActive","autoRowHeightColumns","getAllAutoRowHeightCols","setVirtualViewportLeftAndRight","isEnableRtl","viewportLeft","scrollPosition","scrollWidth","viewportRight","getDisplayedColumnsStartingAt","column","currentColumn","result","_","exists","push","getDisplayedColAfter","hashBefore","map","getId","join","updateVirtualSets","hashAfter","event_1","EVENT_VIRTUAL_COLUMNS_CHANGED","setVirtualViewportPosition","pivot","console","warn","setPivotMode","event","EVENT_COLUMN_PIVOT_MODE_CHANGED","getSecondaryPivotColumn","pivotKeys","valueColKey","valueColumnToFind","getPrimaryColumn","foundColumn","secondaryColumns","forEach","thisPivotKeys","getColDef","pivotValueColumn","pivotKeyMatches","compareArrays","pivotValueMatches","setBeans","loggerFactory","logger","create","setFirstRightAndLastLeftPinned","lastLeft","firstRight","last","gridColumns","setLastLeftPinned","setFirstRightPinned","autoSizeColumns","keys","_this","columnsAutosized","changesThisTimeAround","actionOnGridColumns","indexOf","preferredWidth","autoWidthCalculator","getPreferredWidthForColumn","newWidth","normaliseColumnWidth","setActualWidth","event_2","EVENT_COLUMN_RESIZED","columns","finished","autoSizeColumn","autoSizeAllColumns","getAllDisplayedColumns","rootColumns","recursiveFindColumns","childColumns","child","Column","OriginalColumnGroup","getChildren","getAllDisplayedColumnGroups","displayedLeftColumnTree","displayedRightColumnTree","displayedCentreColumnTree","concat","getPrimaryColumnTree","getHeaderRowCount","getLeftDisplayedColumnGroups","getRightDisplayedColumnGroups","getCenterDisplayedColumnGroups","getDisplayedColumnGroups","PINNED_LEFT","PINNED_RIGHT","isColumnDisplayed","getAllDisplayedVirtualColumns","getDisplayedLeftColumnsForRow","rowNode","colSpanActive","getDisplayedColumnsForRow","getDisplayedRightColumnsForRow","displayedColumns","filterCallback","emptySpaceBeforeColumn","lastConsideredCol","_loop_1","col","maxAllowedColSpan","colSpan","Math","min","getColSpan","columnsToCheckFilter","colsToRemove","j","filterPasses","colForFilter","gapBeforeColumn","out_i_1","getAllDisplayedCenterVirtualColumnsForRow","getLeft","isColumnInViewport","bind","columnLeft","columnRight","getActualWidth","leftBounds","rightBounds","columnToMuchLeft","columnToMuchRight","getPinnedLeftContainerWidth","getWidthOfColsInList","getPinnedRightContainerWidth","updatePrimaryColumnList","masterList","actionIsAdd","columnCallback","eventType","missingOrEmpty","atLeastOne","columnToAdd","removeFromArray","setRowGroupColumns","colKeys","setPrimaryColumnList","EVENT_COLUMN_ROW_GROUP_CHANGED","setRowGroupActive","active","isRowGroupActive","isSuppressMakeColumnVisibleAfterUnGroup","setVisible","addRowGroupColumn","addRowGroupColumns","removeRowGroupColumns","removeRowGroupColumn","addPivotColumns","setPivotActive","EVENT_COLUMN_PIVOT_CHANGED","setPivotColumns","added","addPivotColumn","removePivotColumns","removePivotColumn","eventName","setValueColumns","EVENT_COLUMN_VALUE_CHANGED","setValueActive","isValueActive","getAggFunc","defaultAggFunc","aggFuncService","getDefaultAggFunc","setAggFunc","addValueColumns","addValueColumn","colKey","removeValueColumn","removeValueColumns","getMinWidth","isGreaterThanMax","getMaxWidth","getPrimaryOrGridColumn","getGridColumn","setColumnWidth","shiftKey","sets","width","ratios","defaultIsShift","getColResizeDefault","otherCol","widthDiff","otherColWidth","resizeColumnSets","checkMinAndMaxWidthsForSet","columnResizeSet","minWidthAccumulated","maxWidthAccumulated","maxWidthActive","minWidthPasses","maxWidthPasses","resizeSets","passMinMaxCheck","every","event_3","changedCols","allCols","set","newWidths","finishedCols","finishedColsGrew","loopCount","_loop_2","error","subsetCols","subsetRatios","subsetRatioTotal","pixelsToDistribute","index","thisColFinished","ratioThisCol","ratioScale","lastCol","colNewWidth","round","state_1","atLeastOneColChanged","setLeftValues","updateBodyWidths","event_4","setColumnAggFunc","aggFunc","event_5","moveRowGroupColumn","fromIndex","toIndex","splice","moveColumns","columnsToMoveKeys","columnAnimationService","start","columnsToMove","getGridColumns","failedRules","doesMovePassRules","moveInArray","EVENT_COLUMN_MOVED","finish","proposedColumnOrder","slice","doesMovePassMarryChildren","doesMovePassLockedPositions","foundNonLocked","rulePassed","lockPosition","allColumnsCopy","columnUtils","depthFirstOriginalTreeSearch","gridBalancedTree","columnGroup","marryChildren","getColGroupDef","newIndexes","getLeafColumns","newColIndex","maxIndex","max","apply","minIndex","spread","maxSpread","moveColumn","moveColumnByIndex","getBodyContainerWidth","getContainerWidth","pinned","newBodyWidth","newLeftWidth","newRightWidth","atLeastOneChanged","event_6","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","getValueColumns","getPivotColumns","isPivotActive","getRowGroupColumns","getDisplayedCenterColumns","getDisplayedLeftColumns","getDisplayedRightColumns","getDisplayedColumns","getAllPrimaryColumns","getSecondaryColumns","getAllColumnsForQuickFilter","columnsForQuickFilter","getAllGridColumns","isEmpty","isRowGroupEmpty","setColumnVisible","visible","setColumnsVisible","isVisible","EVENT_COLUMN_VISIBLE","setColumnPinned","setColumnsPinned","getDomLayout","actualPinned","getPinned","setPinned","EVENT_COLUMN_PINNED","action","createEvent","updatedColumns","resultOfAction","event_7","getDisplayedColBefore","oldIndex","getDisplayedGroupAfter","getDisplayedLeafColumns","requiredLevel","getOriginalColumnGroup","getLevel","groupPointer","getParent","isPinningLeft","isPinningRight","getPrimaryAndSecondaryAndAutoColumns","groupAutoColumns","createStateItemFromColumn","rowGroupIndex","pivotIndex","colId","getColId","hide","getColumnState","missing","primaryColumnState","groupAutoColumnState","columnStateList","orderColumnStateList","gridColumnIds","sort","itemA","itemB","posA","posB","suppressEverythingEvent","columnStates","letRowGroupIndex","letPivotIndex","rowGroup","stateItem","setColumnState","columnStateBefore","columnsWithNoState","success","rowGroupIndexes","pivotIndexes","autoGroupColumnStates","state","getAutoColumn","syncColumnWithStateItem","syncColumnWithNoState","sortColumnListUsingIndexes","autoCol","orderOfColIds_1","colA","colB","indexA","indexB","putFixedColumnsFirst","event_8","raiseColumnEvents","isSuppressSetColumnStateEvents","columnStateAfter","raiseEventWithAllColumns","idMapper","unchanged","getChangedColumns","changedPredicate","changedColumns","columnStateBeforeMap","colStateBefore","valueColumnIdMapper","cs","pivotColumnIdMapper","rowGroupColumnIdMapper","pinnedChangePredicate","raiseColumnPinnedEvent","visibilityChangePredicate","cols","raiseColumnVisibleEvent","resizeChangePredicate","raiseColumnResizeEvent","raiseColumnMovedEvent","event_9","event_10","undefined","event_11","movedColumns","_loop_3","before","after","predicate","movedColumn","find","this_1","event_12","indexes","minColWidth","getMinColWidth","getColumns","columnLookupCallback","foundColumns","getColumnWithValidation","getColumn","columnList","columnsMatch","groupCol","columnMatches","colDefMatches","idMatches","getDisplayNameForColumn","location","includeAggFunc","headerName","getHeaderName","wrapHeaderNameWithAggFunc","getDisplayNameForOriginalColumnGroup","originalColumnGroup","colGroupDef","getDisplayNameForColumnGroup","colDef","headerValueGetter","params","getApi","context","getContext","expressionService","evaluate","field","camelCaseToHumanText","isSuppressAggFuncInHeader","pivotActiveOnThisColumn","aggFuncFound","measureActive","aggregationPresent","aggFuncString","localeTextFunc","getLocaleTextFunc","aggFuncStringTranslated","getColumnGroup","instanceId","ColumnGroup","allColumnGroups","checkInstanceId","depthFirstAllColumnTreeSearch","matched","getGroupId","getInstanceId","isReady","extractColumns","flag","previousCols","setFlagFunc","getIndexFunc","getValueFunc","colPresentInPrimaryFunc","colMissingFromPrimaryFunc","colNewFunc","removedCols","filter","existingCols","newPrimaryCols","newCols","booleanValue","res","resetColumnGroupState","stateItems","groupState","groupId","open","openByDefault","setColumnGroupState","getColumnGroupState","columnGroupState","node","isExpanded","impactedGroups","groupKey","newValue","log","setExpanded","updateGroupsAndDisplayedColumns","EVENT_COLUMN_GROUP_OPENED","setColumnGroupOpened","keyAsString","calculateColumnsForDisplay","columnsForDisplay","isAutoGroupCol","isValueCol","checkColSpanActiveInCols","calculateColumnsForGroupDisplay","groupDisplayColumns","checkFunc","showRowGroup","getGroupDisplayColumns","buildDisplayedTrees","isSecondaryColumnsPresent","setSecondaryColumns","colDefs","newColsPresent","processSecondaryColumnDefinitions","secondaryBalancedTree","getProcessSecondaryColDefFunc","groupCallback","getProcessSecondaryColGroupDefFunc","searchForColDefs","colDefs2","abstractColDef","isGroup","children","gridColsArePrimary","lastPrimaryOrder","orderGridColsLikeLastPrimary","addAutoGroupToGridColumns","autoHeight","setupQuickFilterColumns","clearDisplayedColumns","EVENT_GRID_COLUMNS_CHANGED","noColsFound","oldColsOrdered","newColsOrdered","newGridColumns","newCol","parent","getOriginalParent","siblings","leafCols","leafCol","presentInNewGriColumns","noYetInSiblings","lastIndex","insertIntoArray","isPrimaryColumnGroupsPresent","locked","unlocked","createGroupAutoColumnsIfNeeded","autoColBalancedTree","createForAutoGroups","displayedLeftHeaderRows","displayedRightHeaderRows","displayedCentreHeaderRows","updateOpenClosedVisibilityInColumnGroups","updateDisplayedColumnsFromTrees","EVENT_DISPLAYED_COLUMNS_CHANGED","addToDisplayedColumns","setupAllDisplayedColumns","setLeftValuesOfColumns","setLeftValuesOfGroups","allColumns","doingRtl","left_1","setLeft","left_2","removeAllFromArray","checkLeft","displayedColumnTree","depthFirstDisplayedColumnTreeSearch","updateDisplayedCenterVirtualColumns","filterOutColumnsWithinViewport","getVirtualHeaderGroupRow","dept","updateDisplayedVirtualGroups","virtualColIds","testGroup","returnValue","addThisItem","getDisplayedChildren","sizeColumnsToFit","gridWidth","colsToNotSpread","suppressSizeToFit","colsToSpread","colsToFireEventFor","finishedResizing","availablePixels","setMinimum","scale","pixelsForLastCol","moveToNotSpread","onLastCol","visibleColumns","leftVisibleColumns","rightVisibleColumns","centerVisibleColumns","groupInstanceIdCreator","GroupInstanceIdCreator","displayedGroupCreator","createDisplayedGroups","calculateDisplayedColumns","getGroupAutoColumns","groupFullWidthRow","isGroupUseEntireRow","groupSuppressAutoColumn","isGroupSuppressAutoColumn","groupSuppressRow","isGroupSuppressRow","groupingActive","needAutoColumns","newAutoGroupCols","autoGroupColService","createAutoGroupColumns","autoColsDifferent","autoColsEqual","colsA","colsB","bothMissing","atLeastOneListMissing","getGridBalancedTree","Autowired","GridOptionsWrapper","ExpressionService","ColumnFactory","DisplayedGroupCreator","AutoWidthCalculator","EventService","ColumnUtils","Context","ColumnAnimationService","AutoGroupColService","Optional","ValueCache","ColumnApi","GridApi","PostConstruct","Function","Qualifier","LoggerFactory","Bean"],"mappings":"AAAA;;;;;;AAMA;;AACA,IAAIA,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC1D,MAAI,OAAON,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACO,QAAf,KAA4B,UAA/D,EAA2E,OAAOP,OAAO,CAACO,QAAR,CAAiBF,CAAjB,EAAoBC,CAApB,CAAP;AAC9E,CAFD;;AAGA,IAAIE,OAAO,GAAI,QAAQ,KAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUpB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEmB,IAAAA,SAAS,CAACpB,MAAD,EAASC,GAAT,EAAckB,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGAZ,MAAM,CAACM,cAAP,CAAsBQ,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,aAAa,GAAGC,OAAO,CAAC,yBAAD,CAA3B;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,oBAAD,CAAtB;;AACA,IAAIE,oBAAoB,GAAGF,OAAO,CAAC,uBAAD,CAAlC;;AACA,IAAIG,mBAAmB,GAAGH,OAAO,CAAC,mCAAD,CAAjC;;AACA,IAAII,eAAe,GAAGJ,OAAO,CAAC,iBAAD,CAA7B;;AACA,IAAIK,uBAAuB,GAAGL,OAAO,CAAC,yBAAD,CAArC;;AACA,IAAIM,qBAAqB,GAAGN,OAAO,CAAC,kCAAD,CAAnC;;AACA,IAAIO,cAAc,GAAGP,OAAO,CAAC,iBAAD,CAA5B;;AACA,IAAIQ,aAAa,GAAGR,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIS,QAAQ,GAAGT,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIU,QAAQ,GAAGV,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIW,qBAAqB,GAAGX,OAAO,CAAC,iCAAD,CAAnC;;AACA,IAAIY,wBAAwB,GAAGZ,OAAO,CAAC,0BAAD,CAAtC;;AACA,IAAIa,SAAS,GAAGb,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIc,wBAAwB,GAAGd,OAAO,CAAC,qCAAD,CAAtC;;AACA,IAAIe,qBAAqB,GAAGf,OAAO,CAAC,uBAAD,CAAnC;;AACA,IAAIgB,YAAY,GAAGhB,OAAO,CAAC,4BAAD,CAA1B;;AACA,IAAIiB,SAAS,GAAGjB,OAAO,CAAC,YAAD,CAAvB;;AACA,IAAIkB,WAAW,GAAGlB,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAImB,OAAO,GAAGnB,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIoB,gBAAgB;AAAG;AAAe,YAAY;AAC9C,WAASA,gBAAT,GAA4B;AACxB;AACA,SAAKC,qBAAL,GAA6B,CAA7B;AACA,SAAKC,uBAAL,GAA+B,CAA/B;AACA,SAAKC,uBAAL,GAA+B,KAA/B,CAJwB,CAKxB;;AACA,SAAKC,kBAAL,GAA0B,CAA1B,CANwB,CAOxB;AACA;;AACA,SAAKC,oBAAL,GAA4B,EAA5B;AACA,SAAKC,qBAAL,GAA6B,EAA7B;AACA,SAAKC,sBAAL,GAA8B,EAA9B,CAXwB,CAYxB;;AACA,SAAKC,mBAAL,GAA2B,EAA3B,CAbwB,CAcxB;;AACA,SAAKC,0BAAL,GAAkC,EAAlC;AACA,SAAKC,gCAAL,GAAwC,EAAxC;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,KAAL,GAAa,KAAb;AACA,SAAKC,sBAAL,GAA8B,KAA9B;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACH;;AACDpB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BC,IAA3B,GAAkC,YAAY;AAC1C,QAAIN,SAAS,GAAG,KAAKO,kBAAL,CAAwBC,WAAxB,EAAhB;AACA,SAAKC,4BAAL,GAAoC,KAAKF,kBAAL,CAAwBG,8BAAxB,EAApC;;AACA,QAAI,KAAKC,qBAAL,CAA2BX,SAA3B,CAAJ,EAA2C;AACvC,WAAKA,SAAL,GAAiBA,SAAjB;AACH;;AACD,SAAKY,aAAL,GAAqB,KAAKL,kBAAL,CAAwBM,UAAxB,EAArB;AACH,GAPD;;AAQA7B,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BS,aAA3B,GAA2C,UAAUC,UAAV,EAAsBC,MAAtB,EAA8B;AACrE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIC,qBAAqB,GAAG,CAAC,CAAC,KAAKF,UAAnC;AACA,SAAKA,UAAL,GAAkBA,UAAlB,CAHqE,CAIrE;AACA;;AACA,SAAKG,UAAL,CAAgBC,MAAhB,GANqE,CAOrE;AACA;AACA;;AACA,SAAKpB,sBAAL,GAA8B,IAA9B;AACA,QAAIqB,iBAAiB,GAAG,KAAKC,cAA7B;AACA,QAAIC,kBAAkB,GAAG,KAAKC,aAAL,CAAmBC,gBAAnB,CAAoCT,UAApC,EAAgD,IAAhD,EAAsDK,iBAAtD,CAAzB;AACA,SAAKK,iBAAL,GAAyBH,kBAAkB,CAACI,UAA5C;AACA,SAAKzC,qBAAL,GAA6BqC,kBAAkB,CAACK,QAAnB,GAA8B,CAA3D;AACA,SAAKN,cAAL,GAAsB,KAAKO,kBAAL,CAAwB,KAAKH,iBAA7B,CAAtB;AACA,SAAKI,sBAAL,CAA4Bb,MAA5B,EAAoCI,iBAApC;AACA,SAAKU,mBAAL,CAAyBd,MAAzB,EAAiCI,iBAAjC;AACA,SAAKW,kBAAL,CAAwBf,MAAxB,EAAgCI,iBAAhC;AACA,SAAKtB,KAAL,GAAa,IAAb;AACA,SAAKkC,iBAAL;AACA,SAAKC,sBAAL,CAA4BjB,MAA5B;AACA,SAAKkB,4BAAL;;AACA,QAAI,KAAK3B,kBAAL,CAAwB4B,iBAAxB,MAA+ClB,qBAAnD,EAA0E;AACtE,WAAKmB,gBAAL,CAAsB,IAAtB,EAA4BpB,MAA5B;AACH;;AACD,QAAIqB,sBAAsB,GAAG;AACzBC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBC,+BADG;AAEzBC,MAAAA,GAAG,EAAE,KAAKC,OAFe;AAGzBC,MAAAA,SAAS,EAAE,KAAKA,SAHS;AAIzB3B,MAAAA,MAAM,EAAEA;AAJiB,KAA7B;AAMA,SAAK4B,YAAL,CAAkBC,aAAlB,CAAgCR,sBAAhC;AACA,QAAIS,qBAAqB,GAAG;AACxBR,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBQ,wBADE;AAExBN,MAAAA,GAAG,EAAE,KAAKC,OAFc;AAGxBC,MAAAA,SAAS,EAAE,KAAKA;AAHQ,KAA5B;AAKA,SAAKC,YAAL,CAAkBC,aAAlB,CAAgCC,qBAAhC;AACH,GAvCD;;AAwCA9D,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2C,qBAA3B,GAAmD,YAAY;AAC3D,WAAO,KAAKC,oBAAL,IAA6B,KAAKA,oBAAL,CAA0BxG,MAA1B,GAAmC,CAAvE;AACH,GAFD;;AAGAuC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6C,uBAA3B,GAAqD,YAAY;AAC7D,WAAO,KAAKD,oBAAZ;AACH,GAFD;;AAGAjE,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8C,8BAA3B,GAA4D,YAAY;AACpE,QAAI,KAAK5C,kBAAL,CAAwB6C,WAAxB,EAAJ,EAA2C;AACvC,WAAKC,YAAL,GAAoB,KAAKpD,SAAL,GAAiB,KAAKqD,cAAtB,GAAuC,KAAKC,WAAhE;AACA,WAAKC,aAAL,GAAqB,KAAKvD,SAAL,GAAiB,KAAKqD,cAA3C;AACH,KAHD,MAIK;AACD,WAAKD,YAAL,GAAoB,KAAKC,cAAzB;AACA,WAAKE,aAAL,GAAqB,KAAKD,WAAL,GAAmB,KAAKD,cAA7C;AACH;AACJ,GATD,CAnF8C,CA6F9C;;;AACAtE,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoD,6BAA3B,GAA2D,UAAUC,MAAV,EAAkB;AACzE,QAAIC,aAAa,GAAGD,MAApB;AACA,QAAIE,MAAM,GAAG,EAAb;;AACA,WAAOD,aAAa,IAAI5E,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiBH,aAAjB,CAAxB,EAAyD;AACrDC,MAAAA,MAAM,CAACG,IAAP,CAAYJ,aAAZ;AACAA,MAAAA,aAAa,GAAG,KAAKK,oBAAL,CAA0BL,aAA1B,CAAhB;AACH;;AACD,WAAOC,MAAP;AACH,GARD,CA9F8C,CAuG9C;AACA;AACA;;;AACA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6B,4BAA3B,GAA0D,YAAY;AAClE;AACA,QAAInD,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB,KAAKvE,sBAAtB,CAAJ,EAAmD;AAC/C,UAAI0E,UAAU,GAAG,KAAKxE,0BAAL,CAAgCyE,GAAhC,CAAoC,UAAUR,MAAV,EAAkB;AAAE,eAAOA,MAAM,CAACS,KAAP,EAAP;AAAwB,OAAhF,EAAkFC,IAAlF,CAAuF,GAAvF,CAAjB;AACA,WAAKC,iBAAL;AACA,UAAIC,SAAS,GAAG,KAAK7E,0BAAL,CAAgCyE,GAAhC,CAAoC,UAAUR,MAAV,EAAkB;AAAE,eAAOA,MAAM,CAACS,KAAP,EAAP;AAAwB,OAAhF,EAAkFC,IAAlF,CAAuF,GAAvF,CAAhB;;AACA,UAAIH,UAAU,KAAKK,SAAnB,EAA8B;AAC1B,YAAIC,OAAO,GAAG;AACVjC,UAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBiC,6BADZ;AAEV/B,UAAAA,GAAG,EAAE,KAAKC,OAFA;AAGVC,UAAAA,SAAS,EAAE,KAAKA;AAHN,SAAd;AAKA,aAAKC,YAAL,CAAkBC,aAAlB,CAAgC0B,OAAhC;AACH;AACJ;AACJ,GAfD;;AAgBAvF,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoE,0BAA3B,GAAwD,UAAUlB,WAAV,EAAuBD,cAAvB,EAAuC;AAC3F,QAAIC,WAAW,KAAK,KAAKA,WAArB,IAAoCD,cAAc,KAAK,KAAKA,cAA5D,IAA8E,KAAKlD,cAAvF,EAAuG;AACnG,WAAKmD,WAAL,GAAmBA,WAAnB;AACA,WAAKD,cAAL,GAAsBA,cAAtB,CAFmG,CAGnG;AACA;AACA;;AACA,WAAKlD,cAAL,GAAsB,IAAtB;AACA,WAAK+C,8BAAL;;AACA,UAAI,KAAKrD,KAAT,EAAgB;AACZ,aAAKoC,4BAAL;AACH;AACJ;AACJ,GAbD;;AAcAlD,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BG,WAA3B,GAAyC,YAAY;AACjD,WAAO,KAAKR,SAAZ;AACH,GAFD;;AAGAhB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BM,qBAA3B,GAAmD,UAAU+D,KAAV,EAAiB;AAChE,QAAIA,KAAJ,EAAW;AACP,UAAI,KAAKnE,kBAAL,CAAwBM,UAAxB,EAAJ,EAA0C;AACtC8D,QAAAA,OAAO,CAACC,IAAR,CAAa,8FAAb;AACA,eAAO,KAAP;AACH,OAHD,MAIK;AACD,eAAO,IAAP;AACH;AACJ,KARD,MASK;AACD,aAAO,IAAP;AACH;AACJ,GAbD;;AAcA5F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwE,YAA3B,GAA0C,UAAU7E,SAAV,EAAqBgB,MAArB,EAA6B;AACnE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIhB,SAAS,KAAK,KAAKA,SAAvB,EAAkC;AAC9B;AACH;;AACD,QAAI,CAAC,KAAKW,qBAAL,CAA2B,KAAKX,SAAhC,CAAL,EAAiD;AAC7C;AACH;;AACD,SAAKA,SAAL,GAAiBA,SAAjB,CARmE,CASnE;AACA;AACA;;AACA,SAAKD,sBAAL,GAA8B,IAA9B;AACA,SAAKiC,iBAAL;AACA,SAAKC,sBAAL,CAA4BjB,MAA5B;AACA,QAAI8D,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBwC,+BADd;AAERtC,MAAAA,GAAG,EAAE,KAAKC,OAFF;AAGRC,MAAAA,SAAS,EAAE,KAAKA;AAHR,KAAZ;AAKA,SAAKC,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GArBD;;AAsBA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2E,uBAA3B,GAAqD,UAAUC,SAAV,EAAqBC,WAArB,EAAkC;AACnF,QAAI,CAAC,KAAK/F,uBAAV,EAAmC;AAC/B,aAAO,IAAP;AACH;;AACD,QAAIgG,iBAAiB,GAAG,KAAKC,gBAAL,CAAsBF,WAAtB,CAAxB;AACA,QAAIG,WAAW,GAAG,IAAlB;;AACA,QAAI,KAAKC,gBAAT,EAA2B;AACvB,WAAKA,gBAAL,CAAsBC,OAAtB,CAA8B,UAAU7B,MAAV,EAAkB;AAC5C,YAAI8B,aAAa,GAAG9B,MAAM,CAAC+B,SAAP,GAAmBR,SAAvC;AACA,YAAIS,gBAAgB,GAAGhC,MAAM,CAAC+B,SAAP,GAAmBC,gBAA1C;;AACA,YAAIC,eAAe,GAAG5G,OAAO,CAAC8E,CAAR,CAAU+B,aAAV,CAAwBJ,aAAxB,EAAuCP,SAAvC,CAAtB;;AACA,YAAIY,iBAAiB,GAAGH,gBAAgB,KAAKP,iBAA7C;;AACA,YAAIQ,eAAe,IAAIE,iBAAvB,EAA0C;AACtCR,UAAAA,WAAW,GAAG3B,MAAd;AACH;AACJ,OARD;AASH;;AACD,WAAO2B,WAAP;AACH,GAlBD;;AAmBArG,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByF,QAA3B,GAAsC,UAAUC,aAAV,EAAyB;AAC3D,SAAKC,MAAL,GAAcD,aAAa,CAACE,MAAd,CAAqB,kBAArB,CAAd;AACH,GAFD;;AAGAjH,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6F,8BAA3B,GAA4D,UAAUlF,MAAV,EAAkB;AAC1E,QAAImF,QAAJ;AACA,QAAIC,UAAJ;;AACA,QAAI,KAAK7F,kBAAL,CAAwB6C,WAAxB,EAAJ,EAA2C;AACvC+C,MAAAA,QAAQ,GAAG,KAAK9G,oBAAL,GAA4B,KAAKA,oBAAL,CAA0B,CAA1B,CAA5B,GAA2D,IAAtE;AACA+G,MAAAA,UAAU,GAAG,KAAK9G,qBAAL,GAA6BP,OAAO,CAAC8E,CAAR,CAAUwC,IAAV,CAAe,KAAK/G,qBAApB,CAA7B,GAA0E,IAAvF;AACH,KAHD,MAIK;AACD6G,MAAAA,QAAQ,GAAG,KAAK9G,oBAAL,GAA4BN,OAAO,CAAC8E,CAAR,CAAUwC,IAAV,CAAe,KAAKhH,oBAApB,CAA5B,GAAwE,IAAnF;AACA+G,MAAAA,UAAU,GAAG,KAAK9G,qBAAL,GAA6B,KAAKA,qBAAL,CAA2B,CAA3B,CAA7B,GAA6D,IAA1E;AACH;;AACD,SAAKgH,WAAL,CAAiBf,OAAjB,CAAyB,UAAU7B,MAAV,EAAkB;AACvCA,MAAAA,MAAM,CAAC6C,iBAAP,CAAyB7C,MAAM,KAAKyC,QAApC,EAA8CnF,MAA9C;AACA0C,MAAAA,MAAM,CAAC8C,mBAAP,CAA2B9C,MAAM,KAAK0C,UAAtC,EAAkDpF,MAAlD;AACH,KAHD;AAIH,GAfD;;AAgBAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoG,eAA3B,GAA6C,UAAUC,IAAV,EAAgB1F,MAAhB,EAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB,KATuB,CAUjE;;;AACA,QAAI4F,gBAAgB,GAAG,EAAvB,CAXiE,CAYjE;;AACA,QAAIC,qBAAqB,GAAG,CAAC,CAA7B;;AACA,WAAOA,qBAAqB,KAAK,CAAjC,EAAoC;AAChCA,MAAAA,qBAAqB,GAAG,CAAxB;AACA,WAAKC,mBAAL,CAAyBJ,IAAzB,EAA+B,UAAUhD,MAAV,EAAkB;AAC7C;AACA,YAAIkD,gBAAgB,CAACG,OAAjB,CAAyBrD,MAAzB,KAAoC,CAAxC,EAA2C;AACvC,iBAAO,KAAP;AACH,SAJ4C,CAK7C;;;AACA,YAAIsD,cAAc,GAAGL,KAAK,CAACM,mBAAN,CAA0BC,0BAA1B,CAAqDxD,MAArD,CAArB,CAN6C,CAO7C;;;AACA,YAAIsD,cAAc,GAAG,CAArB,EAAwB;AACpB,cAAIG,QAAQ,GAAGR,KAAK,CAACS,oBAAN,CAA2B1D,MAA3B,EAAmCsD,cAAnC,CAAf;;AACAtD,UAAAA,MAAM,CAAC2D,cAAP,CAAsBF,QAAtB,EAAgCnG,MAAhC;AACA4F,UAAAA,gBAAgB,CAAC7C,IAAjB,CAAsBL,MAAtB;AACAmD,UAAAA,qBAAqB;AACxB;;AACD,eAAO,IAAP;AACH,OAfD,EAeG7F,MAfH;AAgBH;;AACD,QAAI4F,gBAAgB,CAACnK,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,UAAI6K,OAAO,GAAG;AACVhF,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgF,oBADZ;AAEVC,QAAAA,OAAO,EAAEZ,gBAFC;AAGVlD,QAAAA,MAAM,EAAEkD,gBAAgB,CAACnK,MAAjB,KAA4B,CAA5B,GAAgCmK,gBAAgB,CAAC,CAAD,CAAhD,GAAsD,IAHpD;AAIVa,QAAAA,QAAQ,EAAE,IAJA;AAKVhF,QAAAA,GAAG,EAAE,KAAKC,OALA;AAMVC,QAAAA,SAAS,EAAE,KAAKA,SANN;AAOV3B,QAAAA,MAAM,EAAE;AAPE,OAAd;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgCyE,OAAhC;AACH;AACJ,GA7CD;;AA8CAtI,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqH,cAA3B,GAA4C,UAAUrL,GAAV,EAAe2E,MAAf,EAAuB;AAC/D,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI3E,GAAJ,EAAS;AACL,WAAKoK,eAAL,CAAqB,CAACpK,GAAD,CAArB,EAA4B2E,MAA5B;AACH;AACJ,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsH,kBAA3B,GAAgD,UAAU3G,MAAV,EAAkB;AAC9D,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIxB,mBAAmB,GAAG,KAAKoI,sBAAL,EAA1B;AACA,SAAKnB,eAAL,CAAqBjH,mBAArB,EAA0CwB,MAA1C;AACH,GAJD;;AAKAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuB,kBAA3B,GAAgD,UAAUiG,WAAV,EAAuB;AACnE,QAAIjE,MAAM,GAAG,EAAb;AACAkE,IAAAA,oBAAoB,CAACD,WAAD,CAApB;AACA,WAAOjE,MAAP;;AACA,aAASkE,oBAAT,CAA8BC,YAA9B,EAA4C;AACxC,WAAK,IAAI/K,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+K,YAAY,CAACtL,MAAjC,EAAyCO,CAAC,EAA1C,EAA8C;AAC1C,YAAIgL,KAAK,GAAGD,YAAY,CAAC/K,CAAD,CAAxB;;AACA,YAAIgL,KAAK,YAAYnK,QAAQ,CAACoK,MAA9B,EAAsC;AAClCrE,UAAAA,MAAM,CAACG,IAAP,CAAYiE,KAAZ;AACH,SAFD,MAGK,IAAIA,KAAK,YAAYzJ,qBAAqB,CAAC2J,mBAA3C,EAAgE;AACjEJ,UAAAA,oBAAoB,CAACE,KAAK,CAACG,WAAN,EAAD,CAApB;AACH;AACJ;AACJ;AACJ,GAfD;;AAgBAnJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+H,2BAA3B,GAAyD,YAAY;AACjE,QAAI,KAAKC,uBAAL,IAAgC,KAAKC,wBAArC,IAAiE,KAAKC,yBAA1E,EAAqG;AACjG,aAAO,KAAKF,uBAAL,CACFG,MADE,CACK,KAAKD,yBADV,EAEFC,MAFE,CAEK,KAAKF,wBAFV,CAAP;AAGH,KAJD,MAKK;AACD,aAAO,IAAP;AACH;AACJ,GATD,CA9R8C,CAwS9C;;;AACAtJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoI,oBAA3B,GAAkD,YAAY;AAC1D,WAAO,KAAKhH,iBAAZ;AACH,GAFD,CAzS8C,CA4S9C;;;AACAzC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqI,iBAA3B,GAA+C,YAAY;AACvD,WAAO,KAAKtJ,kBAAZ;AACH,GAFD,CA7S8C,CAgT9C;;;AACAJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsI,4BAA3B,GAA0D,YAAY;AAClE,WAAO,KAAKN,uBAAZ;AACH,GAFD,CAjT8C,CAoT9C;;;AACArJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuI,6BAA3B,GAA2D,YAAY;AACnE,WAAO,KAAKN,wBAAZ;AACH,GAFD,CArT8C,CAwT9C;;;AACAtJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwI,8BAA3B,GAA4D,YAAY;AACpE,WAAO,KAAKN,yBAAZ;AACH,GAFD;;AAGAvJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByI,wBAA3B,GAAsD,UAAUxG,IAAV,EAAgB;AAClE,YAAQA,IAAR;AACI,WAAKzE,QAAQ,CAACoK,MAAT,CAAgBc,WAArB;AACI,eAAO,KAAKJ,4BAAL,EAAP;;AACJ,WAAK9K,QAAQ,CAACoK,MAAT,CAAgBe,YAArB;AACI,eAAO,KAAKJ,6BAAL,EAAP;;AACJ;AACI,eAAO,KAAKC,8BAAL,EAAP;AANR;AAQH,GATD,CA5T8C,CAsU9C;;;AACA7J,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4I,iBAA3B,GAA+C,UAAUvF,MAAV,EAAkB;AAC7D,WAAO,KAAKkE,sBAAL,GAA8Bb,OAA9B,CAAsCrD,MAAtC,KAAiD,CAAxD;AACH,GAFD,CAvU8C,CA0U9C;;;AACA1E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuH,sBAA3B,GAAoD,YAAY;AAC5D,WAAO,KAAKpI,mBAAZ;AACH,GAFD;;AAGAR,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6I,6BAA3B,GAA2D,YAAY;AACnE,WAAO,KAAKzJ,0BAAZ;AACH,GAFD;;AAGAT,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8I,6BAA3B,GAA2D,UAAUC,OAAV,EAAmB;AAC1E,QAAI,CAAC,KAAKC,aAAV,EAAyB;AACrB,aAAO,KAAKhK,oBAAZ;AACH,KAFD,MAGK;AACD,aAAO,KAAKiK,yBAAL,CAA+BF,OAA/B,EAAwC,KAAK/J,oBAA7C,CAAP;AACH;AACJ,GAPD;;AAQAL,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkJ,8BAA3B,GAA4D,UAAUH,OAAV,EAAmB;AAC3E,QAAI,CAAC,KAAKC,aAAV,EAAyB;AACrB,aAAO,KAAK/J,qBAAZ;AACH,KAFD,MAGK;AACD,aAAO,KAAKgK,yBAAL,CAA+BF,OAA/B,EAAwC,KAAK9J,qBAA7C,CAAP;AACH;AACJ,GAPD;;AAQAN,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BiJ,yBAA3B,GAAuD,UAAUF,OAAV,EAAmBI,gBAAnB,EAAqCC,cAArC,EAAqDC,sBAArD,EAA6E;AAChI,QAAI9F,MAAM,GAAG,EAAb;AACA,QAAI+F,iBAAiB,GAAG,IAAxB;;AACA,QAAIC,OAAO,GAAG,UAAU5M,CAAV,EAAa;AACvB,UAAI6M,GAAG,GAAGL,gBAAgB,CAACxM,CAAD,CAA1B;AACA,UAAI8M,iBAAiB,GAAGN,gBAAgB,CAAC/M,MAAjB,GAA0BO,CAAlD;AACA,UAAI+M,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASJ,GAAG,CAACK,UAAJ,CAAed,OAAf,CAAT,EAAkCU,iBAAlC,CAAd;AACA,UAAIK,oBAAoB,GAAG,CAACN,GAAD,CAA3B;;AACA,UAAIE,OAAO,GAAG,CAAd,EAAiB;AACb,YAAIK,YAAY,GAAGL,OAAO,GAAG,CAA7B;;AACA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAID,YAArB,EAAmCC,CAAC,EAApC,EAAwC;AACpCF,UAAAA,oBAAoB,CAACpG,IAArB,CAA0ByF,gBAAgB,CAACxM,CAAC,GAAGqN,CAAL,CAA1C;AACH;;AACDrN,QAAAA,CAAC,IAAIoN,YAAL;AACH,OAXsB,CAYvB;;;AACA,UAAIE,YAAJ;;AACA,UAAIb,cAAJ,EAAoB;AAChB;AACA;AACA;AACA;AACA;AACAa,QAAAA,YAAY,GAAG,KAAf;AACAH,QAAAA,oBAAoB,CAAC5E,OAArB,CAA6B,UAAUgF,YAAV,EAAwB;AACjD,cAAId,cAAc,CAACc,YAAD,CAAlB,EAAkC;AAC9BD,YAAAA,YAAY,GAAG,IAAf;AACH;AACJ,SAJD;AAKH,OAZD,MAaK;AACDA,QAAAA,YAAY,GAAG,IAAf;AACH;;AACD,UAAIA,YAAJ,EAAkB;AACd,YAAI1G,MAAM,CAACnH,MAAP,KAAkB,CAAlB,IAAuBkN,iBAA3B,EAA8C;AAC1C,cAAIa,eAAe,GAAGd,sBAAsB,GAAGA,sBAAsB,CAACG,GAAD,CAAzB,GAAiC,KAA7E;;AACA,cAAIW,eAAJ,EAAqB;AACjB5G,YAAAA,MAAM,CAACG,IAAP,CAAY4F,iBAAZ;AACH;AACJ;;AACD/F,QAAAA,MAAM,CAACG,IAAP,CAAY8F,GAAZ;AACH;;AACDF,MAAAA,iBAAiB,GAAGE,GAApB;AACAY,MAAAA,OAAO,GAAGzN,CAAV;AACH,KAzCD;;AA0CA,QAAIyN,OAAJ;;AACA,SAAK,IAAIzN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwM,gBAAgB,CAAC/M,MAArC,EAA6CO,CAAC,EAA9C,EAAkD;AAC9C4M,MAAAA,OAAO,CAAC5M,CAAD,CAAP;;AACAA,MAAAA,CAAC,GAAGyN,OAAJ;AACH;;AACD,WAAO7G,MAAP;AACH,GAnDD,CAjW8C,CAqZ9C;AACA;AACA;AACA;;;AACA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqK,yCAA3B,GAAuE,UAAUtB,OAAV,EAAmB;AACtF,QAAIzC,KAAK,GAAG,IAAZ;;AACA,QAAI,CAAC,KAAK0C,aAAV,EAAyB;AACrB,aAAO,KAAK3J,gCAAZ;AACH;;AACD,QAAIgK,sBAAsB,GAAG,UAAUG,GAAV,EAAe;AAAE,aAAOA,GAAG,CAACc,OAAJ,KAAgBhE,KAAK,CAACtD,YAA7B;AAA4C,KAA1F,CALsF,CAMtF;;;AACA,QAAIoG,cAAc,GAAG,KAAKhJ,4BAAL,GAAoC,IAApC,GAA2C,KAAKmK,kBAAL,CAAwBC,IAAxB,CAA6B,IAA7B,CAAhE;AACA,WAAO,KAAKvB,yBAAL,CAA+BF,OAA/B,EAAwC,KAAK7J,sBAA7C,EAAqEkK,cAArE,EAAqFC,sBAArF,CAAP;AACH,GATD;;AAUA1K,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuK,kBAA3B,GAAgD,UAAUf,GAAV,EAAe;AAC3D,QAAIiB,UAAU,GAAGjB,GAAG,CAACc,OAAJ,EAAjB;AACA,QAAII,WAAW,GAAGlB,GAAG,CAACc,OAAJ,KAAgBd,GAAG,CAACmB,cAAJ,EAAlC,CAF2D,CAG3D;AACA;AACA;AACA;;AACA,QAAIC,UAAU,GAAG,KAAK5H,YAAL,GAAoB,GAArC;AACA,QAAI6H,WAAW,GAAG,KAAK1H,aAAL,GAAqB,GAAvC;AACA,QAAI2H,gBAAgB,GAAGL,UAAU,GAAGG,UAAb,IAA2BF,WAAW,GAAGE,UAAhE;AACA,QAAIG,iBAAiB,GAAGN,UAAU,GAAGI,WAAb,IAA4BH,WAAW,GAAGG,WAAlE;AACA,WAAO,CAACC,gBAAD,IAAqB,CAACC,iBAA7B;AACH,GAZD,CAna8C,CAgb9C;AACA;AACA;;;AACApM,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgL,2BAA3B,GAAyD,YAAY;AACjE,WAAO,KAAKC,oBAAL,CAA0B,KAAKjM,oBAA/B,CAAP;AACH,GAFD,CAnb8C,CAsb9C;;;AACAL,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkL,4BAA3B,GAA0D,YAAY;AAClE,WAAO,KAAKD,oBAAL,CAA0B,KAAKhM,qBAA/B,CAAP;AACH,GAFD;;AAGAN,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BmL,uBAA3B,GAAqD,UAAU9E,IAAV,EAAgB+E,UAAhB,EAA4BC,WAA5B,EAAyCC,cAAzC,EAAyDC,SAAzD,EAAoE5K,MAApE,EAA4E;AAC7H,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI,CAAC0F,IAAD,IAAS3H,OAAO,CAAC8E,CAAR,CAAUgI,cAAV,CAAyBnF,IAAzB,CAAb,EAA6C;AACzC;AACH;;AACD,QAAIoF,UAAU,GAAG,KAAjB;AACApF,IAAAA,IAAI,CAACnB,OAAL,CAAa,UAAUlJ,GAAV,EAAe;AACxB,UAAI0P,WAAW,GAAGpF,KAAK,CAACvB,gBAAN,CAAuB/I,GAAvB,CAAlB;;AACA,UAAI,CAAC0P,WAAL,EAAkB;AACd;AACH;;AACD,UAAIL,WAAJ,EAAiB;AACb,YAAID,UAAU,CAAC1E,OAAX,CAAmBgF,WAAnB,KAAmC,CAAvC,EAA0C;AACtC;AACH;;AACDN,QAAAA,UAAU,CAAC1H,IAAX,CAAgBgI,WAAhB;AACH,OALD,MAMK;AACD,YAAIN,UAAU,CAAC1E,OAAX,CAAmBgF,WAAnB,IAAkC,CAAtC,EAAyC;AACrC;AACH;;AACDhN,QAAAA,OAAO,CAAC8E,CAAR,CAAUmI,eAAV,CAA0BP,UAA1B,EAAsCM,WAAtC;AACH;;AACDJ,MAAAA,cAAc,CAACI,WAAD,CAAd;AACAD,MAAAA,UAAU,GAAG,IAAb;AACH,KAnBD;;AAoBA,QAAI,CAACA,UAAL,EAAiB;AACb;AACH;;AACD,QAAI,KAAK/L,sBAAT,EAAiC;AAC7B,WAAKiC,iBAAL;AACH;;AACD,SAAKC,sBAAL,CAA4BjB,MAA5B;AACA,QAAI8D,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEsJ,SADE;AAERpE,MAAAA,OAAO,EAAEiE,UAFD;AAGR/H,MAAAA,MAAM,EAAE+H,UAAU,CAAChP,MAAX,KAAsB,CAAtB,GAA0BgP,UAAU,CAAC,CAAD,CAApC,GAA0C,IAH1C;AAIRhJ,MAAAA,GAAG,EAAE,KAAKC,OAJF;AAKRC,MAAAA,SAAS,EAAE,KAAKA,SALR;AAMR3B,MAAAA,MAAM,EAAEA;AANA,KAAZ;AAQA,SAAK4B,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GA3CD;;AA4CA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4L,kBAA3B,GAAgD,UAAUC,OAAV,EAAmBlL,MAAnB,EAA2B;AACvE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKjB,sBAAL,GAA8B,IAA9B;AACA,SAAKoM,oBAAL,CAA0BD,OAA1B,EAAmC,KAAKvM,eAAxC,EAAyDrB,QAAQ,CAACiE,MAAT,CAAgB6J,8BAAzE,EAAyG,KAAKC,iBAAL,CAAuBxB,IAAvB,CAA4B,IAA5B,CAAzG,EAA4I7J,MAA5I;AACH,GAJD;;AAKAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgM,iBAA3B,GAA+C,UAAUC,MAAV,EAAkB5I,MAAlB,EAA0B1C,MAA1B,EAAkC;AAC7E,QAAIsL,MAAM,KAAK5I,MAAM,CAAC6I,gBAAP,EAAf,EAA0C;AACtC;AACH;;AACD7I,IAAAA,MAAM,CAAC2I,iBAAP,CAAyBC,MAAzB,EAAiCtL,MAAjC;;AACA,QAAI,CAACsL,MAAD,IAAW,CAAC,KAAK/L,kBAAL,CAAwBiM,uCAAxB,EAAhB,EAAmF;AAC/E9I,MAAAA,MAAM,CAAC+I,UAAP,CAAkB,IAAlB,EAAwBzL,MAAxB;AACH;AACJ,GARD;;AASAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqM,iBAA3B,GAA+C,UAAUrQ,GAAV,EAAe2E,MAAf,EAAuB;AAClE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI3E,GAAJ,EAAS;AACL,WAAKsQ,kBAAL,CAAwB,CAACtQ,GAAD,CAAxB,EAA+B2E,MAA/B;AACH;AACJ,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsM,kBAA3B,GAAgD,UAAUjG,IAAV,EAAgB1F,MAAhB,EAAwB;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKjB,sBAAL,GAA8B,IAA9B;AACA,SAAKyL,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK/G,eAAxC,EAAyD,IAAzD,EAA+D,KAAK0M,iBAAL,CAAuBxB,IAAvB,CAA4B,IAA5B,EAAkC,IAAlC,CAA/D,EAAwGvM,QAAQ,CAACiE,MAAT,CAAgB6J,8BAAxH,EAAwJpL,MAAxJ;AACH,GAJD;;AAKAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuM,qBAA3B,GAAmD,UAAUlG,IAAV,EAAgB1F,MAAhB,EAAwB;AACvE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKjB,sBAAL,GAA8B,IAA9B;AACA,SAAKyL,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK/G,eAAxC,EAAyD,KAAzD,EAAgE,KAAK0M,iBAAL,CAAuBxB,IAAvB,CAA4B,IAA5B,EAAkC,KAAlC,CAAhE,EAA0GvM,QAAQ,CAACiE,MAAT,CAAgB6J,8BAA1H,EAA0JpL,MAA1J;AACH,GAJD;;AAKAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwM,oBAA3B,GAAkD,UAAUxQ,GAAV,EAAe2E,MAAf,EAAuB;AACrE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI3E,GAAJ,EAAS;AACL,WAAKuQ,qBAAL,CAA2B,CAACvQ,GAAD,CAA3B,EAAkC2E,MAAlC;AACH;AACJ,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByM,eAA3B,GAA6C,UAAUpG,IAAV,EAAgB1F,MAAhB,EAAwB;AACjE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKwK,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK7G,YAAxC,EAAsD,IAAtD,EAA4D,UAAU6D,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACqJ,cAAP,CAAsB,IAAtB,EAA4B/L,MAA5B,CAAP;AAA6C,KAA7H,EAA+H1C,QAAQ,CAACiE,MAAT,CAAgByK,0BAA/I,EAA2KhM,MAA3K;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4M,eAA3B,GAA6C,UAAUf,OAAV,EAAmBlL,MAAnB,EAA2B;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKmL,oBAAL,CAA0BD,OAA1B,EAAmC,KAAKrM,YAAxC,EAAsDvB,QAAQ,CAACiE,MAAT,CAAgByK,0BAAtE,EAAkG,UAAUE,KAAV,EAAiBxJ,MAAjB,EAAyB;AACvHA,MAAAA,MAAM,CAACqJ,cAAP,CAAsBG,KAAtB,EAA6BlM,MAA7B;AACH,KAFD,EAEGA,MAFH;AAGH,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8M,cAA3B,GAA4C,UAAU9Q,GAAV,EAAe2E,MAAf,EAAuB;AAC/D,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAK8L,eAAL,CAAqB,CAACzQ,GAAD,CAArB,EAA4B2E,MAA5B;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+M,kBAA3B,GAAgD,UAAU1G,IAAV,EAAgB1F,MAAhB,EAAwB;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKwK,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK7G,YAAxC,EAAsD,KAAtD,EAA6D,UAAU6D,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACqJ,cAAP,CAAsB,KAAtB,EAA6B/L,MAA7B,CAAP;AAA8C,KAA/H,EAAiI1C,QAAQ,CAACiE,MAAT,CAAgByK,0BAAjJ,EAA6KhM,MAA7K;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgN,iBAA3B,GAA+C,UAAUhR,GAAV,EAAe2E,MAAf,EAAuB;AAClE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKoM,kBAAL,CAAwB,CAAC/Q,GAAD,CAAxB,EAA+B2E,MAA/B;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8L,oBAA3B,GAAkD,UAAUD,OAAV,EAAmBT,UAAnB,EAA+B6B,SAA/B,EAA0C3B,cAA1C,EAA0D3K,MAA1D,EAAkE;AAChH,QAAI2F,KAAK,GAAG,IAAZ;;AACA8E,IAAAA,UAAU,CAAChP,MAAX,GAAoB,CAApB;;AACA,QAAIsC,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiBoI,OAAjB,CAAJ,EAA+B;AAC3BA,MAAAA,OAAO,CAAC3G,OAAR,CAAgB,UAAUlJ,GAAV,EAAe;AAC3B,YAAIqH,MAAM,GAAGiD,KAAK,CAACvB,gBAAN,CAAuB/I,GAAvB,CAAb;;AACA,YAAIqH,MAAJ,EAAY;AACR+H,UAAAA,UAAU,CAAC1H,IAAX,CAAgBL,MAAhB;AACH;AACJ,OALD;AAMH;;AACD,SAAKrC,cAAL,CAAoBkE,OAApB,CAA4B,UAAU7B,MAAV,EAAkB;AAC1C,UAAIwJ,KAAK,GAAGzB,UAAU,CAAC1E,OAAX,CAAmBrD,MAAnB,KAA8B,CAA1C;AACAiI,MAAAA,cAAc,CAACuB,KAAD,EAAQxJ,MAAR,CAAd;AACH,KAHD;;AAIA,QAAI,KAAK3D,sBAAT,EAAiC;AAC7B,WAAKiC,iBAAL;AACH;;AACD,SAAKC,sBAAL,CAA4BjB,MAA5B;AACA,QAAI8D,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEgL,SADE;AAER9F,MAAAA,OAAO,EAAEiE,UAFD;AAGR/H,MAAAA,MAAM,EAAE+H,UAAU,CAAChP,MAAX,KAAsB,CAAtB,GAA0BgP,UAAU,CAAC,CAAD,CAApC,GAA0C,IAH1C;AAIRhJ,MAAAA,GAAG,EAAE,KAAKC,OAJF;AAKRC,MAAAA,SAAS,EAAE,KAAKA,SALR;AAMR3B,MAAAA,MAAM,EAAEA;AANA,KAAZ;AAQA,SAAK4B,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GA5BD;;AA6BA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkN,eAA3B,GAA6C,UAAUrB,OAAV,EAAmBlL,MAAnB,EAA2B;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKmL,oBAAL,CAA0BD,OAA1B,EAAmC,KAAKtM,YAAxC,EAAsDtB,QAAQ,CAACiE,MAAT,CAAgBiL,0BAAtE,EAAkG,KAAKC,cAAL,CAAoB5C,IAApB,CAAyB,IAAzB,CAAlG,EAAkI7J,MAAlI;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoN,cAA3B,GAA4C,UAAUnB,MAAV,EAAkB5I,MAAlB,EAA0B1C,MAA1B,EAAkC;AAC1E,QAAIsL,MAAM,KAAK5I,MAAM,CAACgK,aAAP,EAAf,EAAuC;AACnC;AACH;;AACDhK,IAAAA,MAAM,CAAC+J,cAAP,CAAsBnB,MAAtB,EAA8BtL,MAA9B;;AACA,QAAIsL,MAAM,IAAI,CAAC5I,MAAM,CAACiK,UAAP,EAAf,EAAoC;AAChC,UAAIC,cAAc,GAAG,KAAKC,cAAL,CAAoBC,iBAApB,CAAsCpK,MAAtC,CAArB;AACAA,MAAAA,MAAM,CAACqK,UAAP,CAAkBH,cAAlB;AACH;AACJ,GATD;;AAUA5O,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2N,eAA3B,GAA6C,UAAUtH,IAAV,EAAgB1F,MAAhB,EAAwB;AACjE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKwK,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK9G,YAAxC,EAAsD,IAAtD,EAA4D,KAAK6N,cAAL,CAAoB5C,IAApB,CAAyB,IAAzB,EAA+B,IAA/B,CAA5D,EAAkGvM,QAAQ,CAACiE,MAAT,CAAgBiL,0BAAlH,EAA8IxM,MAA9I;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4N,cAA3B,GAA4C,UAAUC,MAAV,EAAkBlN,MAAlB,EAA0B;AAClE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIkN,MAAJ,EAAY;AACR,WAAKF,eAAL,CAAqB,CAACE,MAAD,CAArB,EAA+BlN,MAA/B;AACH;AACJ,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8N,iBAA3B,GAA+C,UAAUD,MAAV,EAAkBlN,MAAlB,EAA0B;AACrE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKoN,kBAAL,CAAwB,CAACF,MAAD,CAAxB,EAAkClN,MAAlC;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+N,kBAA3B,GAAgD,UAAU1H,IAAV,EAAgB1F,MAAhB,EAAwB;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKwK,uBAAL,CAA6B9E,IAA7B,EAAmC,KAAK9G,YAAxC,EAAsD,KAAtD,EAA6D,KAAK6N,cAAL,CAAoB5C,IAApB,CAAyB,IAAzB,EAA+B,KAA/B,CAA7D,EAAoGvM,QAAQ,CAACiE,MAAT,CAAgBiL,0BAApH,EAAgJxM,MAAhJ;AACH,GAHD,CAzlB8C,CA6lB9C;;;AACAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+G,oBAA3B,GAAkD,UAAU1D,MAAV,EAAkByD,QAAlB,EAA4B;AAC1E,QAAIA,QAAQ,GAAGzD,MAAM,CAAC2K,WAAP,EAAf,EAAqC;AACjClH,MAAAA,QAAQ,GAAGzD,MAAM,CAAC2K,WAAP,EAAX;AACH;;AACD,QAAI3K,MAAM,CAAC4K,gBAAP,CAAwBnH,QAAxB,CAAJ,EAAuC;AACnCA,MAAAA,QAAQ,GAAGzD,MAAM,CAAC6K,WAAP,EAAX;AACH;;AACD,WAAOpH,QAAP;AACH,GARD;;AASAnI,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BmO,sBAA3B,GAAoD,UAAUnS,GAAV,EAAe;AAC/D,QAAIqH,MAAM,GAAG,KAAK0B,gBAAL,CAAsB/I,GAAtB,CAAb;;AACA,QAAIqH,MAAJ,EAAY;AACR,aAAOA,MAAP;AACH,KAFD,MAGK;AACD,aAAO,KAAK+K,aAAL,CAAmBpS,GAAnB,CAAP;AACH;AACJ,GARD;;AASA2C,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqO,cAA3B,GAA4C,UAAUrS,GAAV,EAAe;AAC3D8K,EAAAA,QAD4C,EAClC;AACVwH,EAAAA,QAF4C,EAElC;AACVlH,EAAAA,QAH4C,EAGlC;AACVzG,EAAAA,MAJ4C,EAIpC;AACJ,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI6I,GAAG,GAAG,KAAK2E,sBAAL,CAA4BnS,GAA5B,CAAV;;AACA,QAAI,CAACwN,GAAL,EAAU;AACN;AACH;;AACD,QAAI+E,IAAI,GAAG,EAAX;AACAA,IAAAA,IAAI,CAAC7K,IAAL,CAAU;AACN8K,MAAAA,KAAK,EAAE1H,QADD;AAEN2H,MAAAA,MAAM,EAAE,CAAC,CAAD,CAFF;AAGNtH,MAAAA,OAAO,EAAE,CAACqC,GAAD;AAHH,KAAV,EAPI,CAYJ;;AACA,QAAIkF,cAAc,GAAG,KAAKxO,kBAAL,CAAwByO,mBAAxB,OAAkD,OAAvE;;AACA,QAAID,cAAJ,EAAoB;AAChBJ,MAAAA,QAAQ,GAAG,CAACA,QAAZ;AACH;;AACD,QAAIA,QAAJ,EAAc;AACV,UAAIM,QAAQ,GAAG,KAAKjL,oBAAL,CAA0B6F,GAA1B,CAAf;;AACA,UAAI,CAACoF,QAAL,EAAe;AACX;AACH;;AACD,UAAIC,SAAS,GAAGrF,GAAG,CAACmB,cAAJ,KAAuB7D,QAAvC;AACA,UAAIgI,aAAa,GAAGF,QAAQ,CAACjE,cAAT,KAA4BkE,SAAhD;AACAN,MAAAA,IAAI,CAAC7K,IAAL,CAAU;AACN8K,QAAAA,KAAK,EAAEM,aADD;AAENL,QAAAA,MAAM,EAAE,CAAC,CAAD,CAFF;AAGNtH,QAAAA,OAAO,EAAE,CAACyH,QAAD;AAHH,OAAV;AAKH;;AACD,SAAKG,gBAAL,CAAsBR,IAAtB,EAA4BnH,QAA5B,EAAsCzG,MAAtC;AACH,GAnCD;;AAoCAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgP,0BAA3B,GAAwD,UAAUC,eAAV,EAA2B;AAC/E,QAAI9H,OAAO,GAAG8H,eAAe,CAAC9H,OAA9B;AAAA,QAAuCqH,KAAK,GAAGS,eAAe,CAACT,KAA/D,CAD+E,CAE/E;AACA;;AACA,QAAIU,mBAAmB,GAAG,CAA1B;AACA,QAAIC,mBAAmB,GAAG,CAA1B;AACA,QAAIC,cAAc,GAAG,IAArB;AACAjI,IAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAUsE,GAAV,EAAe;AAC3B0F,MAAAA,mBAAmB,IAAI1F,GAAG,CAACwE,WAAJ,EAAvB;;AACA,UAAIxE,GAAG,CAAC0E,WAAJ,KAAoB,CAAxB,EAA2B;AACvBiB,QAAAA,mBAAmB,IAAI3F,GAAG,CAAC0E,WAAJ,EAAvB;AACH,OAFD,MAGK;AACD;AACA;AACAkB,QAAAA,cAAc,GAAG,KAAjB;AACH;AACJ,KAVD;AAWA,QAAIC,cAAc,GAAGb,KAAK,IAAIU,mBAA9B;AACA,QAAII,cAAc,GAAG,CAACF,cAAD,IAAoBZ,KAAK,IAAIW,mBAAlD;AACA,WAAOE,cAAc,IAAIC,cAAzB;AACH,GArBD,CAppB8C,CA0qB9C;AACA;AACA;AACA;;;AACA3Q,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+O,gBAA3B,GAA8C,UAAUQ,UAAV,EAAsBnI,QAAtB,EAAgCzG,MAAhC,EAAwC;AAClF,QAAI6O,eAAe,GAAG9Q,OAAO,CAAC8E,CAAR,CAAUiM,KAAV,CAAgBF,UAAhB,EAA4B,KAAKP,0BAAL,CAAgCxE,IAAhC,CAAqC,IAArC,CAA5B,CAAtB;;AACA,QAAI,CAACgF,eAAL,EAAsB;AAClB;AACA,UAAIpI,QAAJ,EAAc;AACV,YAAID,OAAO,GAAGoI,UAAU,IAAIA,UAAU,CAACnT,MAAX,GAAoB,CAAlC,GAAsCmT,UAAU,CAAC,CAAD,CAAV,CAAcpI,OAApD,GAA8D,IAA5E;AACA,YAAIuI,OAAO,GAAG;AACVzN,UAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgF,oBADZ;AAEVC,UAAAA,OAAO,EAAEA,OAFC;AAGV9D,UAAAA,MAAM,EAAE8D,OAAO,IAAIA,OAAO,CAAC/K,MAAR,KAAmB,CAA9B,GAAkC+K,OAAO,CAAC,CAAD,CAAzC,GAA+C,IAH7C;AAIVC,UAAAA,QAAQ,EAAEA,QAJA;AAKVhF,UAAAA,GAAG,EAAE,KAAKC,OALA;AAMVC,UAAAA,SAAS,EAAE,KAAKA,SANN;AAOV3B,UAAAA,MAAM,EAAEA;AAPE,SAAd;AASA,aAAK4B,YAAL,CAAkBC,aAAlB,CAAgCkN,OAAhC;AACH;;AACD,aAfkB,CAeV;AACX;;AACD,QAAIC,WAAW,GAAG,EAAlB;AACA,QAAIC,OAAO,GAAG,EAAd;AACAL,IAAAA,UAAU,CAACrK,OAAX,CAAmB,UAAU2K,GAAV,EAAe;AAC9B,UAAIrB,KAAK,GAAGqB,GAAG,CAACrB,KAAhB;AAAA,UAAuBrH,OAAO,GAAG0I,GAAG,CAAC1I,OAArC;AAAA,UAA8CsH,MAAM,GAAGoB,GAAG,CAACpB,MAA3D,CAD8B,CAE9B;AACA;;AACA,UAAIqB,SAAS,GAAG,EAAhB;AACA,UAAIC,YAAY,GAAG,EAAnB;AACA5I,MAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAUsE,GAAV,EAAe;AAAE,eAAOoG,OAAO,CAAClM,IAAR,CAAa8F,GAAb,CAAP;AAA2B,OAA5D,EAN8B,CAO9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAIwG,gBAAgB,GAAG,IAAvB;AACA,UAAIC,SAAS,GAAG,CAAhB;;AACA,UAAIC,OAAO,GAAG,YAAY;AACtBD,QAAAA,SAAS;;AACT,YAAIA,SAAS,GAAG,IAAhB,EAAsB;AAClB;AACA;AACA3L,UAAAA,OAAO,CAAC6L,KAAR,CAAc,4CAAd;AACA,iBAAO,OAAP;AACH;;AACDH,QAAAA,gBAAgB,GAAG,KAAnB;AACA,YAAII,UAAU,GAAG,EAAjB;AACA,YAAIC,YAAY,GAAG,EAAnB;AACA,YAAIC,gBAAgB,GAAG,CAAvB;AACA,YAAIC,kBAAkB,GAAG/B,KAAzB;AACArH,QAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAUsE,GAAV,EAAegH,KAAf,EAAsB;AAClC,cAAIC,eAAe,GAAGV,YAAY,CAACvG,GAAG,CAAC1F,KAAJ,EAAD,CAAlC;;AACA,cAAI2M,eAAJ,EAAqB;AACjBF,YAAAA,kBAAkB,IAAIT,SAAS,CAACtG,GAAG,CAAC1F,KAAJ,EAAD,CAA/B;AACH,WAFD,MAGK;AACDsM,YAAAA,UAAU,CAAC1M,IAAX,CAAgB8F,GAAhB;AACA,gBAAIkH,YAAY,GAAGjC,MAAM,CAAC+B,KAAD,CAAzB;AACAF,YAAAA,gBAAgB,IAAII,YAApB;AACAL,YAAAA,YAAY,CAAC3M,IAAb,CAAkBgN,YAAlB;AACH;AACJ,SAXD,EAbsB,CAyBtB;AACA;AACA;;AACA,YAAIC,UAAU,GAAG,IAAIL,gBAArB;AACAF,QAAAA,UAAU,CAAClL,OAAX,CAAmB,UAAUsE,GAAV,EAAegH,KAAf,EAAsB;AACrC,cAAII,OAAO,GAAGJ,KAAK,KAAMJ,UAAU,CAAChU,MAAX,GAAoB,CAA7C;AACA,cAAIyU,WAAJ;;AACA,cAAID,OAAJ,EAAa;AACTC,YAAAA,WAAW,GAAGN,kBAAd;AACH,WAFD,MAGK;AACDM,YAAAA,WAAW,GAAGlH,IAAI,CAACmH,KAAL,CAAWrC,MAAM,CAAC+B,KAAD,CAAN,GAAgBhC,KAAhB,GAAwBmC,UAAnC,CAAd;AACAJ,YAAAA,kBAAkB,IAAIM,WAAtB;AACH;;AACD,cAAIA,WAAW,GAAGrH,GAAG,CAACwE,WAAJ,EAAlB,EAAqC;AACjC6C,YAAAA,WAAW,GAAGrH,GAAG,CAACwE,WAAJ,EAAd;AACA+B,YAAAA,YAAY,CAACvG,GAAG,CAAC1F,KAAJ,EAAD,CAAZ,GAA4B,IAA5B;AACAkM,YAAAA,gBAAgB,GAAG,IAAnB;AACH,WAJD,MAKK,IAAIxG,GAAG,CAAC0E,WAAJ,KAAoB,CAApB,IAAyB2C,WAAW,GAAGrH,GAAG,CAAC0E,WAAJ,EAA3C,EAA8D;AAC/D2C,YAAAA,WAAW,GAAGrH,GAAG,CAAC0E,WAAJ,EAAd;AACA6B,YAAAA,YAAY,CAACvG,GAAG,CAAC1F,KAAJ,EAAD,CAAZ,GAA4B,IAA5B;AACAkM,YAAAA,gBAAgB,GAAG,IAAnB;AACH;;AACDF,UAAAA,SAAS,CAACtG,GAAG,CAAC1F,KAAJ,EAAD,CAAT,GAAyB+M,WAAzB;AACH,SArBD;AAsBH,OAnDD;;AAoDA,aAAOb,gBAAP,EAAyB;AACrB,YAAIe,OAAO,GAAGb,OAAO,EAArB;;AACA,YAAIa,OAAO,KAAK,OAAhB,EACI;AACP;;AACD5J,MAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAUsE,GAAV,EAAe;AAC3B,YAAI1C,QAAQ,GAAGgJ,SAAS,CAACtG,GAAG,CAAC1F,KAAJ,EAAD,CAAxB;;AACA,YAAI0F,GAAG,CAACmB,cAAJ,OAAyB7D,QAA7B,EAAuC;AACnC0C,UAAAA,GAAG,CAACxC,cAAJ,CAAmBF,QAAnB;AACA6I,UAAAA,WAAW,CAACjM,IAAZ,CAAiB8F,GAAjB;AACH;AACJ,OAND;AAOH,KAnFD,EArBkF,CAyGlF;;AACA,QAAIwH,oBAAoB,GAAGrB,WAAW,CAACvT,MAAZ,GAAqB,CAAhD;;AACA,QAAI4U,oBAAJ,EAA0B;AACtB,WAAKC,aAAL,CAAmBtQ,MAAnB;AACA,WAAKuQ,gBAAL;AACA,WAAKrP,4BAAL;AACH,KA/GiF,CAgHlF;AACA;AACA;AACA;AACA;;;AACA,QAAImP,oBAAoB,IAAI5J,QAA5B,EAAsC;AAClC,UAAI+J,OAAO,GAAG;AACVlP,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgF,oBADZ;AAEVC,QAAAA,OAAO,EAAEyI,OAFC;AAGVvM,QAAAA,MAAM,EAAEuM,OAAO,CAACxT,MAAR,KAAmB,CAAnB,GAAuBwT,OAAO,CAAC,CAAD,CAA9B,GAAoC,IAHlC;AAIVxI,QAAAA,QAAQ,EAAEA,QAJA;AAKVhF,QAAAA,GAAG,EAAE,KAAKC,OALA;AAMVC,QAAAA,SAAS,EAAE,KAAKA,SANN;AAOV3B,QAAAA,MAAM,EAAEA;AAPE,OAAd;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgC2O,OAAhC;AACH;AACJ,GAjID;;AAkIAxS,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoR,gBAA3B,GAA8C,UAAU/N,MAAV,EAAkBgO,OAAlB,EAA2B1Q,MAA3B,EAAmC;AAC7E,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI0C,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAACqK,UAAP,CAAkB2D,OAAlB;AACA,UAAIC,OAAO,GAAG;AACVrP,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBiL,0BADZ;AAEVhG,QAAAA,OAAO,EAAE,CAAC9D,MAAD,CAFC;AAGVA,QAAAA,MAAM,EAAEA,MAHE;AAIVjB,QAAAA,GAAG,EAAE,KAAKC,OAJA;AAKVC,QAAAA,SAAS,EAAE,KAAKA,SALN;AAMV3B,QAAAA,MAAM,EAAEA;AANE,OAAd;AAQA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgC8O,OAAhC;AACH;AACJ,GAdD;;AAeA3S,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuR,kBAA3B,GAAgD,UAAUC,SAAV,EAAqBC,OAArB,EAA8B9Q,MAA9B,EAAsC;AAClF,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI0C,MAAM,GAAG,KAAK/D,eAAL,CAAqBkS,SAArB,CAAb;AACA,SAAKlS,eAAL,CAAqBoS,MAArB,CAA4BF,SAA5B,EAAuC,CAAvC;AACA,SAAKlS,eAAL,CAAqBoS,MAArB,CAA4BD,OAA5B,EAAqC,CAArC,EAAwCpO,MAAxC;AACA,QAAIoB,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgB6J,8BADd;AAER5E,MAAAA,OAAO,EAAE,KAAK7H,eAFN;AAGR+D,MAAAA,MAAM,EAAE,KAAK/D,eAAL,CAAqBlD,MAArB,KAAgC,CAAhC,GAAoC,KAAKkD,eAAL,CAAqB,CAArB,CAApC,GAA8D,IAH9D;AAIR8C,MAAAA,GAAG,EAAE,KAAKC,OAJF;AAKRC,MAAAA,SAAS,EAAE,KAAKA,SALR;AAMR3B,MAAAA,MAAM,EAAEA;AANA,KAAZ;AAQA,SAAK4B,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GAdD;;AAeA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2R,WAA3B,GAAyC,UAAUC,iBAAV,EAA6BH,OAA7B,EAAsC9Q,MAAtC,EAA8C;AACnF,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKkR,sBAAL,CAA4BC,KAA5B;;AACA,QAAIL,OAAO,GAAG,KAAKxL,WAAL,CAAiB7J,MAAjB,GAA0BwV,iBAAiB,CAACxV,MAA1D,EAAkE;AAC9DkI,MAAAA,OAAO,CAACC,IAAR,CAAa,qEAAqEkN,OAAlF;AACAnN,MAAAA,OAAO,CAACC,IAAR,CAAa,+FAAb;AACA;AACH,KAPkF,CAQnF;;;AACA,QAAIwN,aAAa,GAAG,KAAKC,cAAL,CAAoBJ,iBAApB,CAApB;AACA,QAAIK,WAAW,GAAG,CAAC,KAAKC,iBAAL,CAAuBH,aAAvB,EAAsCN,OAAtC,CAAnB;;AACA,QAAIQ,WAAJ,EAAiB;AACb;AACH;;AACDvT,IAAAA,OAAO,CAAC8E,CAAR,CAAU2O,WAAV,CAAsB,KAAKlM,WAA3B,EAAwC8L,aAAxC,EAAuDN,OAAvD;;AACA,SAAK7P,sBAAL,CAA4BjB,MAA5B;AACA,QAAI8D,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBkQ,kBADd;AAERjL,MAAAA,OAAO,EAAE4K,aAFD;AAGR1O,MAAAA,MAAM,EAAE0O,aAAa,CAAC3V,MAAd,KAAyB,CAAzB,GAA6B2V,aAAa,CAAC,CAAD,CAA1C,GAAgD,IAHhD;AAIRN,MAAAA,OAAO,EAAEA,OAJD;AAKRrP,MAAAA,GAAG,EAAE,KAAKC,OALF;AAMRC,MAAAA,SAAS,EAAE,KAAKA,SANR;AAOR3B,MAAAA,MAAM,EAAEA;AAPA,KAAZ;AASA,SAAK4B,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACA,SAAKoN,sBAAL,CAA4BQ,MAA5B;AACH,GA3BD;;AA4BA1T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkS,iBAA3B,GAA+C,UAAUH,aAAV,EAAyBN,OAAzB,EAAkC;AAC7E;AACA,QAAIa,mBAAmB,GAAG,KAAKrM,WAAL,CAAiBsM,KAAjB,EAA1B;;AACA7T,IAAAA,OAAO,CAAC8E,CAAR,CAAU2O,WAAV,CAAsBG,mBAAtB,EAA2CP,aAA3C,EAA0DN,OAA1D,EAH6E,CAI7E;;;AACA,QAAI,CAAC,KAAKe,yBAAL,CAA+BF,mBAA/B,CAAL,EAA0D;AACtD,aAAO,KAAP;AACH;;AACD,QAAI,CAAC,KAAKG,2BAAL,CAAiCH,mBAAjC,CAAL,EAA4D;AACxD,aAAO,KAAP;AACH;;AACD,WAAO,IAAP;AACH,GAZD;;AAaA3T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByS,2BAA3B,GAAyD,UAAUH,mBAAV,EAA+B;AACpF,QAAII,cAAc,GAAG,KAArB;AACA,QAAIC,UAAU,GAAG,IAAjB,CAFoF,CAGpF;;AACAL,IAAAA,mBAAmB,CAACpN,OAApB,CAA4B,UAAUsE,GAAV,EAAe;AACvC,UAAIA,GAAG,CAACpE,SAAJ,GAAgBwN,YAApB,EAAkC;AAC9B,YAAIF,cAAJ,EAAoB;AAChBC,UAAAA,UAAU,GAAG,KAAb;AACH;AACJ,OAJD,MAKK;AACDD,QAAAA,cAAc,GAAG,IAAjB;AACH;AACJ,KATD;AAUA,WAAOC,UAAP;AACH,GAfD;;AAgBAhU,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwS,yBAA3B,GAAuD,UAAUK,cAAV,EAA0B;AAC7E,QAAIF,UAAU,GAAG,IAAjB;AACA,SAAKG,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoD,KAAKC,gBAAzD,EAA2E,UAAUrL,KAAV,EAAiB;AACxF,UAAI,EAAEA,KAAK,YAAYzJ,qBAAqB,CAAC2J,mBAAzC,CAAJ,EAAmE;AAC/D;AACH;;AACD,UAAIoL,WAAW,GAAGtL,KAAlB;AACA,UAAIuL,aAAa,GAAGD,WAAW,CAACE,cAAZ,MAAgCF,WAAW,CAACE,cAAZ,GAA6BD,aAAjF;;AACA,UAAI,CAACA,aAAL,EAAoB;AAChB;AACH;;AACD,UAAIE,UAAU,GAAG,EAAjB;AACAH,MAAAA,WAAW,CAACI,cAAZ,GAA6BnO,OAA7B,CAAqC,UAAUsE,GAAV,EAAe;AAChD,YAAI8J,WAAW,GAAGT,cAAc,CAACnM,OAAf,CAAuB8C,GAAvB,CAAlB;AACA4J,QAAAA,UAAU,CAAC1P,IAAX,CAAgB4P,WAAhB;AACH,OAHD;AAIA,UAAIC,QAAQ,GAAG5J,IAAI,CAAC6J,GAAL,CAASC,KAAT,CAAe9J,IAAf,EAAqByJ,UAArB,CAAf;AACA,UAAIM,QAAQ,GAAG/J,IAAI,CAACC,GAAL,CAAS6J,KAAT,CAAe9J,IAAf,EAAqByJ,UAArB,CAAf,CAfwF,CAgBxF;;AACA,UAAIO,MAAM,GAAGJ,QAAQ,GAAGG,QAAxB;AACA,UAAIE,SAAS,GAAGX,WAAW,CAACI,cAAZ,GAA6BjX,MAA7B,GAAsC,CAAtD,CAlBwF,CAmBxF;;AACA,UAAIuX,MAAM,GAAGC,SAAb,EAAwB;AACpBjB,QAAAA,UAAU,GAAG,KAAb;AACH,OAtBuF,CAuBxF;AACA;;AACH,KAzBD;AA0BA,WAAOA,UAAP;AACH,GA7BD;;AA8BAhU,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6T,UAA3B,GAAwC,UAAU7X,GAAV,EAAeyV,OAAf,EAAwB9Q,MAAxB,EAAgC;AACpE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKgR,WAAL,CAAiB,CAAC3V,GAAD,CAAjB,EAAwByV,OAAxB,EAAiC9Q,MAAjC;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8T,iBAA3B,GAA+C,UAAUtC,SAAV,EAAqBC,OAArB,EAA8B9Q,MAA9B,EAAsC;AACjF,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI0C,MAAM,GAAG,KAAK4C,WAAL,CAAiBuL,SAAjB,CAAb;AACA,SAAKqC,UAAL,CAAgBxQ,MAAhB,EAAwBoO,OAAxB,EAAiC9Q,MAAjC;AACH,GAJD,CAz6B8C,CA86B9C;AACA;AACA;AACA;;;AACAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+T,qBAA3B,GAAmD,YAAY;AAC3D,WAAO,KAAKnU,SAAZ;AACH,GAFD;;AAGAjB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgU,iBAA3B,GAA+C,UAAUC,MAAV,EAAkB;AAC7D,YAAQA,MAAR;AACI,WAAKzW,QAAQ,CAACoK,MAAT,CAAgBc,WAArB;AACI,eAAO,KAAK7I,SAAZ;;AACJ,WAAKrC,QAAQ,CAACoK,MAAT,CAAgBe,YAArB;AACI,eAAO,KAAK7I,UAAZ;;AACJ;AACI,eAAO,KAAKF,SAAZ;AANR;AAQH,GATD,CAr7B8C,CA+7B9C;;;AACAjB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkR,gBAA3B,GAA8C,YAAY;AACtD,QAAIgD,YAAY,GAAG,KAAKjJ,oBAAL,CAA0B,KAAK/L,sBAA/B,CAAnB;AACA,QAAIiV,YAAY,GAAG,KAAKlJ,oBAAL,CAA0B,KAAKjM,oBAA/B,CAAnB;AACA,QAAIoV,aAAa,GAAG,KAAKnJ,oBAAL,CAA0B,KAAKhM,qBAA/B,CAApB,CAHsD,CAItD;AACA;;AACA,SAAKc,cAAL,GAAsB,KAAKH,SAAL,KAAmBsU,YAAzC;AACA,QAAIG,iBAAiB,GAAG,KAAKzU,SAAL,KAAmBsU,YAAnB,IAAmC,KAAKrU,SAAL,KAAmBsU,YAAtD,IAAsE,KAAKrU,UAAL,KAAoBsU,aAAlH;;AACA,QAAIC,iBAAJ,EAAuB;AACnB,WAAKzU,SAAL,GAAiBsU,YAAjB;AACA,WAAKrU,SAAL,GAAiBsU,YAAjB;AACA,WAAKrU,UAAL,GAAkBsU,aAAlB,CAHmB,CAInB;AACA;;AACA,UAAIE,OAAO,GAAG;AACVrS,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBqS,qCADZ;AAEVnS,QAAAA,GAAG,EAAE,KAAKC,OAFA;AAGVC,QAAAA,SAAS,EAAE,KAAKA;AAHN,OAAd;AAKA,WAAKC,YAAL,CAAkBC,aAAlB,CAAgC8R,OAAhC;AACH;AACJ,GArBD,CAh8B8C,CAs9B9C;;;AACA3V,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwU,eAA3B,GAA6C,YAAY;AACrD,WAAO,KAAKjV,YAAL,GAAoB,KAAKA,YAAzB,GAAwC,EAA/C;AACH,GAFD,CAv9B8C,CA09B9C;;;AACAZ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByU,eAA3B,GAA6C,YAAY;AACrD,WAAO,KAAKjV,YAAL,GAAoB,KAAKA,YAAzB,GAAwC,EAA/C;AACH,GAFD,CA39B8C,CA89B9C;;;AACAb,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0U,aAA3B,GAA2C,YAAY;AACnD,WAAO,KAAKlV,YAAL,IAAqB,KAAKA,YAAL,CAAkBpD,MAAlB,GAA2B,CAAhD,IAAqD,KAAKuD,SAAjE;AACH,GAFD,CA/9B8C,CAk+B9C;;;AACAhB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2U,kBAA3B,GAAgD,YAAY;AACxD,WAAO,KAAKrV,eAAL,GAAuB,KAAKA,eAA5B,GAA8C,EAArD;AACH,GAFD,CAn+B8C,CAs+B9C;;;AACAX,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4U,yBAA3B,GAAuD,YAAY;AAC/D,WAAO,KAAK1V,sBAAZ;AACH,GAFD,CAv+B8C,CA0+B9C;;;AACAP,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6U,uBAA3B,GAAqD,YAAY;AAC7D,WAAO,KAAK7V,oBAAZ;AACH,GAFD;;AAGAL,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8U,wBAA3B,GAAsD,YAAY;AAC9D,WAAO,KAAK7V,qBAAZ;AACH,GAFD;;AAGAN,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+U,mBAA3B,GAAiD,UAAU9S,IAAV,EAAgB;AAC7D,YAAQA,IAAR;AACI,WAAKzE,QAAQ,CAACoK,MAAT,CAAgBc,WAArB;AACI,eAAO,KAAKmM,uBAAL,EAAP;;AACJ,WAAKrX,QAAQ,CAACoK,MAAT,CAAgBe,YAArB;AACI,eAAO,KAAKmM,wBAAL,EAAP;;AACJ;AACI,eAAO,KAAKF,yBAAL,EAAP;AANR;AAQH,GATD,CAj/B8C,CA2/B9C;AACA;AACA;;;AACAjW,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgV,oBAA3B,GAAkD,YAAY;AAC1D,WAAO,KAAKhU,cAAL,GAAsB,KAAKA,cAAL,CAAoBuR,KAApB,EAAtB,GAAoD,IAA3D;AACH,GAFD;;AAGA5T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BiV,mBAA3B,GAAiD,YAAY;AACzD,WAAO,KAAKhQ,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBsN,KAAtB,EAAxB,GAAwD,IAA/D;AACH,GAFD;;AAGA5T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkV,2BAA3B,GAAyD,YAAY;AACjE,WAAO,KAAKC,qBAAZ;AACH,GAFD,CApgC8C,CAugC9C;;;AACAxW,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoV,iBAA3B,GAA+C,YAAY;AACvD,WAAO,KAAKnP,WAAZ;AACH,GAFD;;AAGAtH,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqV,OAA3B,GAAqC,YAAY;AAC7C,WAAO3W,OAAO,CAAC8E,CAAR,CAAUgI,cAAV,CAAyB,KAAKvF,WAA9B,CAAP;AACH,GAFD;;AAGAtH,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsV,eAA3B,GAA6C,YAAY;AACrD,WAAO5W,OAAO,CAAC8E,CAAR,CAAUgI,cAAV,CAAyB,KAAKlM,eAA9B,CAAP;AACH,GAFD;;AAGAX,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuV,gBAA3B,GAA8C,UAAUvZ,GAAV,EAAewZ,OAAf,EAAwB7U,MAAxB,EAAgC;AAC1E,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAK8U,iBAAL,CAAuB,CAACzZ,GAAD,CAAvB,EAA8BwZ,OAA9B,EAAuC7U,MAAvC;AACH,GAHD;;AAIAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByV,iBAA3B,GAA+C,UAAUpP,IAAV,EAAgBmP,OAAhB,EAAyB7U,MAAzB,EAAiC;AAC5E,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKkR,sBAAL,CAA4BC,KAA5B;AACA,SAAKrL,mBAAL,CAAyBJ,IAAzB,EAA+B,UAAUhD,MAAV,EAAkB;AAC7C,UAAIA,MAAM,CAACqS,SAAP,OAAuBF,OAA3B,EAAoC;AAChCnS,QAAAA,MAAM,CAAC+I,UAAP,CAAkBoJ,OAAlB,EAA2B7U,MAA3B;AACA,eAAO,IAAP;AACH,OAHD,MAIK;AACD,eAAO,KAAP;AACH;AACJ,KARD,EAQGA,MARH,EAQW,YAAY;AACnB,UAAI8D,KAAK,GAAG;AACRxC,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgByT,oBADd;AAERH,QAAAA,OAAO,EAAEA,OAFD;AAGRnS,QAAAA,MAAM,EAAE,IAHA;AAIR8D,QAAAA,OAAO,EAAE,IAJD;AAKR/E,QAAAA,GAAG,EAAEkE,KAAK,CAACjE,OALH;AAMRC,QAAAA,SAAS,EAAEgE,KAAK,CAAChE,SANT;AAOR3B,QAAAA,MAAM,EAAEA;AAPA,OAAZ;AASA,aAAO8D,KAAP;AACH,KAnBD;AAoBA,SAAKoN,sBAAL,CAA4BQ,MAA5B;AACH,GAzBD;;AA0BA1T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4V,eAA3B,GAA6C,UAAU5Z,GAAV,EAAeiY,MAAf,EAAuBtT,MAAvB,EAA+B;AACxE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI3E,GAAJ,EAAS;AACL,WAAK6Z,gBAAL,CAAsB,CAAC7Z,GAAD,CAAtB,EAA6BiY,MAA7B,EAAqCtT,MAArC;AACH;AACJ,GALD;;AAMAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6V,gBAA3B,GAA8C,UAAUxP,IAAV,EAAgB4N,MAAhB,EAAwBtT,MAAxB,EAAgC;AAC1E,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAI,KAAKT,kBAAL,CAAwB4V,YAAxB,OAA2C,OAA/C,EAAwD;AACpDxR,MAAAA,OAAO,CAACC,IAAR,CAAa,0EAAb;AACA;AACH;;AACD,SAAKsN,sBAAL,CAA4BC,KAA5B;AACA,QAAIiE,YAAJ;;AACA,QAAI9B,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKzW,QAAQ,CAACoK,MAAT,CAAgBc,WAAlD,EAA+D;AAC3DqN,MAAAA,YAAY,GAAGvY,QAAQ,CAACoK,MAAT,CAAgBc,WAA/B;AACH,KAFD,MAGK,IAAIuL,MAAM,KAAKzW,QAAQ,CAACoK,MAAT,CAAgBe,YAA/B,EAA6C;AAC9CoN,MAAAA,YAAY,GAAGvY,QAAQ,CAACoK,MAAT,CAAgBe,YAA/B;AACH,KAFI,MAGA;AACDoN,MAAAA,YAAY,GAAG,IAAf;AACH;;AACD,SAAKtP,mBAAL,CAAyBJ,IAAzB,EAA+B,UAAUmD,GAAV,EAAe;AAC1C,UAAIA,GAAG,CAACwM,SAAJ,OAAoBD,YAAxB,EAAsC;AAClCvM,QAAAA,GAAG,CAACyM,SAAJ,CAAcF,YAAd;AACA,eAAO,IAAP;AACH,OAHD,MAIK;AACD,eAAO,KAAP;AACH;AACJ,KARD,EAQGpV,MARH,EAQW,YAAY;AACnB,UAAI8D,KAAK,GAAG;AACRxC,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgU,mBADd;AAERjC,QAAAA,MAAM,EAAE8B,YAFA;AAGR1S,QAAAA,MAAM,EAAE,IAHA;AAIR8D,QAAAA,OAAO,EAAE,IAJD;AAKR/E,QAAAA,GAAG,EAAEkE,KAAK,CAACjE,OALH;AAMRC,QAAAA,SAAS,EAAEgE,KAAK,CAAChE,SANT;AAOR3B,QAAAA,MAAM,EAAEA;AAPA,OAAZ;AASA,aAAO8D,KAAP;AACH,KAnBD;AAoBA,SAAKoN,sBAAL,CAA4BQ,MAA5B;AACH,GAvCD,CArjC8C,CA6lC9C;AACA;AACA;AACA;;;AACA1T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByG,mBAA3B,GAAiD,WAAU;AAC3DJ,EAAAA,IADiD,EAEjD;AACA;AACA8P,EAAAA,MAJiD,EAKjD;AACAxV,EAAAA,MANiD,EAMzCyV,WANyC,EAM5B;AACjB,QAAI9P,KAAK,GAAG,IAAZ;;AACA,QAAI5H,OAAO,CAAC8E,CAAR,CAAUgI,cAAV,CAAyBnF,IAAzB,CAAJ,EAAoC;AAChC;AACH;;AACD,QAAIgQ,cAAc,GAAG,EAArB;AACAhQ,IAAAA,IAAI,CAACnB,OAAL,CAAa,UAAUlJ,GAAV,EAAe;AACxB,UAAIqH,MAAM,GAAGiD,KAAK,CAAC8H,aAAN,CAAoBpS,GAApB,CAAb;;AACA,UAAI,CAACqH,MAAL,EAAa;AACT;AACH,OAJuB,CAKxB;AACA;;;AACA,UAAIiT,cAAc,GAAGH,MAAM,CAAC9S,MAAD,CAA3B;;AACA,UAAIiT,cAAc,KAAK,KAAvB,EAA8B;AAC1BD,QAAAA,cAAc,CAAC3S,IAAf,CAAoBL,MAApB;AACH;AACJ,KAXD;;AAYA,QAAIgT,cAAc,CAACja,MAAf,KAA0B,CAA9B,EAAiC;AAC7B;AACH;;AACD,SAAKwF,sBAAL,CAA4BjB,MAA5B;;AACA,QAAIjC,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB2S,WAAjB,KAAiCA,WAArC,EAAkD;AAC9C,UAAIG,OAAO,GAAGH,WAAW,EAAzB;AACAG,MAAAA,OAAO,CAACpP,OAAR,GAAkBkP,cAAlB;AACAE,MAAAA,OAAO,CAAClT,MAAR,GAAiBgT,cAAc,CAACja,MAAf,KAA0B,CAA1B,GAA8Bia,cAAc,CAAC,CAAD,CAA5C,GAAkD,IAAnE;AACA,WAAK9T,YAAL,CAAkBC,aAAlB,CAAgC+T,OAAhC;AACH;AACJ,GAlCD;;AAmCA5X,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwW,qBAA3B,GAAmD,UAAUhN,GAAV,EAAe;AAC9D,QAAIrK,mBAAmB,GAAG,KAAKoI,sBAAL,EAA1B;AACA,QAAIkP,QAAQ,GAAGtX,mBAAmB,CAACuH,OAApB,CAA4B8C,GAA5B,CAAf;;AACA,QAAIiN,QAAQ,GAAG,CAAf,EAAkB;AACd,aAAOtX,mBAAmB,CAACsX,QAAQ,GAAG,CAAZ,CAA1B;AACH,KAFD,MAGK;AACD,aAAO,IAAP;AACH;AACJ,GATD,CApoC8C,CA8oC9C;AACA;;;AACA9X,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2D,oBAA3B,GAAkD,UAAU6F,GAAV,EAAe;AAC7D,QAAIrK,mBAAmB,GAAG,KAAKoI,sBAAL,EAA1B;AACA,QAAIkP,QAAQ,GAAGtX,mBAAmB,CAACuH,OAApB,CAA4B8C,GAA5B,CAAf;;AACA,QAAIiN,QAAQ,GAAItX,mBAAmB,CAAC/C,MAApB,GAA6B,CAA7C,EAAiD;AAC7C,aAAO+C,mBAAmB,CAACsX,QAAQ,GAAG,CAAZ,CAA1B;AACH,KAFD,MAGK;AACD,aAAO,IAAP;AACH;AACJ,GATD;;AAUA9X,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0W,sBAA3B,GAAoD,UAAUzD,WAAV,EAAuB;AACvE;AACA,QAAIzJ,GAAG,GAAGyJ,WAAW,CAAC0D,uBAAZ,GAAsC,CAAtC,CAAV;AACA,QAAIC,aAAa,GAAG3D,WAAW,CAAC4D,sBAAZ,GAAqCC,QAArC,EAApB;;AACA,WAAO,IAAP,EAAa;AACT;AACAtN,MAAAA,GAAG,GAAG,KAAK7F,oBAAL,CAA0B6F,GAA1B,CAAN,CAFS,CAGT;;AACA,UAAI,CAACA,GAAL,EAAU;AACN,eAAO,IAAP;AACH,OANQ,CAOT;;;AACA,UAAIuN,YAAY,GAAGvN,GAAG,CAACwN,SAAJ,EAAnB;;AACA,aAAOD,YAAY,CAACF,sBAAb,GAAsCC,QAAtC,OAAqDF,aAA5D,EAA2E;AACvEG,QAAAA,YAAY,GAAGA,YAAY,CAACC,SAAb,EAAf;AACH;;AACD,UAAID,YAAY,KAAK9D,WAArB,EAAkC;AAC9B,eAAO8D,YAAP;AACH;AACJ;AACJ,GApBD;;AAqBApY,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BiX,aAA3B,GAA2C,YAAY;AACnD,WAAO,KAAKjY,oBAAL,CAA0B5C,MAA1B,GAAmC,CAA1C;AACH,GAFD;;AAGAuC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkX,cAA3B,GAA4C,YAAY;AACpD,WAAO,KAAKjY,qBAAL,CAA2B7C,MAA3B,GAAoC,CAA3C;AACH,GAFD;;AAGAuC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BmX,oCAA3B,GAAkE,YAAY;AAC1E,QAAI5T,MAAM,GAAG,KAAKvC,cAAL,GAAsB,KAAKA,cAAL,CAAoBuR,KAApB,CAA0B,CAA1B,CAAtB,GAAqD,EAAlE;;AACA,QAAI,KAAK6E,gBAAL,IAAyB1Y,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB,KAAK2T,gBAAtB,CAA7B,EAAsE;AAClE,WAAKA,gBAAL,CAAsBlS,OAAtB,CAA8B,UAAUsE,GAAV,EAAe;AAAE,eAAOjG,MAAM,CAACG,IAAP,CAAY8F,GAAZ,CAAP;AAA0B,OAAzE;AACH;;AACD,QAAI,KAAK1K,uBAAL,IAAgC,KAAKmG,gBAAzC,EAA2D;AACvD,WAAKA,gBAAL,CAAsBC,OAAtB,CAA8B,UAAU7B,MAAV,EAAkB;AAAE,eAAOE,MAAM,CAACG,IAAP,CAAYL,MAAZ,CAAP;AAA6B,OAA/E;AACH;;AACD,WAAOE,MAAP;AACH,GATD;;AAUA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqX,yBAA3B,GAAuD,UAAUhU,MAAV,EAAkB;AACrE,QAAIiU,aAAa,GAAGjU,MAAM,CAAC6I,gBAAP,KAA4B,KAAK5M,eAAL,CAAqBoH,OAArB,CAA6BrD,MAA7B,CAA5B,GAAmE,IAAvF;AACA,QAAIkU,UAAU,GAAGlU,MAAM,CAACqR,aAAP,KAAyB,KAAKlV,YAAL,CAAkBkH,OAAlB,CAA0BrD,MAA1B,CAAzB,GAA6D,IAA9E;AACA,QAAIgO,OAAO,GAAGhO,MAAM,CAACgK,aAAP,KAAyBhK,MAAM,CAACiK,UAAP,EAAzB,GAA+C,IAA7D;AACA,WAAO;AACHkK,MAAAA,KAAK,EAAEnU,MAAM,CAACoU,QAAP,EADJ;AAEHC,MAAAA,IAAI,EAAE,CAACrU,MAAM,CAACqS,SAAP,EAFJ;AAGHrE,MAAAA,OAAO,EAAEA,OAHN;AAIH7C,MAAAA,KAAK,EAAEnL,MAAM,CAACsH,cAAP,EAJJ;AAKH4M,MAAAA,UAAU,EAAEA,UALT;AAMHtD,MAAAA,MAAM,EAAE5Q,MAAM,CAAC2S,SAAP,EANL;AAOHsB,MAAAA,aAAa,EAAEA;AAPZ,KAAP;AASH,GAbD;;AAcA3Y,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2X,cAA3B,GAA4C,YAAY;AACpD,QAAIjZ,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkB,KAAK5W,cAAvB,CAAJ,EAA4C;AACxC,aAAO,EAAP;AACH;;AACD,QAAI6W,kBAAkB,GAAG,KAAK7W,cAAL,CAAoB6C,GAApB,CAAwB,KAAKwT,yBAAL,CAA+B7M,IAA/B,CAAoC,IAApC,CAAxB,CAAzB;AACA,QAAIsN,oBAAoB,GAAG,KAAKV,gBAAL,CACvB;AADuB,MAErB,KAAKA,gBAAL,CAAsBvT,GAAtB,CAA0B,KAAKwT,yBAAL,CAA+B7M,IAA/B,CAAoC,IAApC,CAA1B,CAFqB,CAGvB;AAHuB,MAIrB,EAJN;AAKA,QAAIuN,eAAe,GAAGD,oBAAoB,CAAC3P,MAArB,CAA4B0P,kBAA5B,CAAtB;;AACA,QAAI,CAAC,KAAKlY,SAAV,EAAqB;AACjB,WAAKqY,oBAAL,CAA0BD,eAA1B;AACH;;AACD,WAAOA,eAAP;AACH,GAfD;;AAgBApZ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgY,oBAA3B,GAAkD,UAAUD,eAAV,EAA2B;AACzE,QAAIE,aAAa,GAAG,KAAKhS,WAAL,CAAiBpC,GAAjB,CAAqB,UAAUR,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACoU,QAAP,EAAP;AAA2B,KAApE,CAApB;AACAM,IAAAA,eAAe,CAACG,IAAhB,CAAqB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACzC,UAAIC,IAAI,GAAGJ,aAAa,CAACvR,OAAd,CAAsByR,KAAK,CAACX,KAA5B,CAAX;AACA,UAAIc,IAAI,GAAGL,aAAa,CAACvR,OAAd,CAAsB0R,KAAK,CAACZ,KAA5B,CAAX;AACA,aAAOa,IAAI,GAAGC,IAAd;AACH,KAJD;AAKH,GAPD;;AAQA3Z,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+B,gBAA3B,GAA8C,UAAUwW,uBAAV,EAAmC5X,MAAnC,EAA2C;AACrF;AACA;AACA;AACA,QAAI4X,uBAAuB,KAAK,KAAK,CAArC,EAAwC;AAAEA,MAAAA,uBAAuB,GAAG,KAA1B;AAAkC;;AAC5E,QAAI5X,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB,KAL2C,CAMrF;;;AACA,QAAIK,cAAc,GAAG,KAAKO,kBAAL,CAAwB,KAAKH,iBAA7B,CAArB;AACA,QAAIoX,YAAY,GAAG,EAAnB,CARqF,CASrF;AACA;AACA;;AACA,QAAIC,gBAAgB,GAAG,IAAvB;AACA,QAAIC,aAAa,GAAG,IAApB;;AACA,QAAI1X,cAAJ,EAAoB;AAChBA,MAAAA,cAAc,CAACkE,OAAf,CAAuB,UAAU7B,MAAV,EAAkB;AACrC,YAAIiU,aAAa,GAAGjU,MAAM,CAAC+B,SAAP,GAAmBkS,aAAvC;AACA,YAAIqB,QAAQ,GAAGtV,MAAM,CAAC+B,SAAP,GAAmBuT,QAAlC;AACA,YAAIpB,UAAU,GAAGlU,MAAM,CAAC+B,SAAP,GAAmBmS,UAApC;AACA,YAAIlT,KAAK,GAAGhB,MAAM,CAAC+B,SAAP,GAAmBf,KAA/B;AACA,YAAIuU,SAAS,GAAG;AACZpB,UAAAA,KAAK,EAAEnU,MAAM,CAACoU,QAAP,EADK;AAEZpG,UAAAA,OAAO,EAAEhO,MAAM,CAAC+B,SAAP,GAAmBiM,OAFhB;AAGZqG,UAAAA,IAAI,EAAErU,MAAM,CAAC+B,SAAP,GAAmBsS,IAHb;AAIZzD,UAAAA,MAAM,EAAE5Q,MAAM,CAAC+B,SAAP,GAAmB6O,MAJf;AAKZqD,UAAAA,aAAa,EAAEA,aALH;AAMZC,UAAAA,UAAU,EAAElU,MAAM,CAAC+B,SAAP,GAAmBmS,UANnB;AAOZ/I,UAAAA,KAAK,EAAEnL,MAAM,CAAC+B,SAAP,GAAmBoJ;AAPd,SAAhB;;AASA,YAAI9P,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkBN,aAAlB,KAAoCqB,QAAxC,EAAkD;AAC9CC,UAAAA,SAAS,CAACtB,aAAV,GAA0BmB,gBAAgB,EAA1C;AACH;;AACD,YAAI/Z,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkBL,UAAlB,KAAiClT,KAArC,EAA4C;AACxCuU,UAAAA,SAAS,CAACrB,UAAV,GAAuBmB,aAAa,EAApC;AACH;;AACDF,QAAAA,YAAY,CAAC9U,IAAb,CAAkBkV,SAAlB;AACH,OArBD;AAsBH;;AACD,SAAKC,cAAL,CAAoBL,YAApB,EAAkCD,uBAAlC,EAA2D5X,MAA3D;AACH,GAvCD;;AAwCAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6Y,cAA3B,GAA4C,UAAUL,YAAV,EAAwBD,uBAAxB,EAAiD5X,MAAjD,EAAyD;AACjG,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAIiS,uBAAuB,KAAK,KAAK,CAArC,EAAwC;AAAEA,MAAAA,uBAAuB,GAAG,KAA1B;AAAkC;;AAC5E,QAAI5X,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIjC,OAAO,CAAC8E,CAAR,CAAUgI,cAAV,CAAyB,KAAKxK,cAA9B,CAAJ,EAAmD;AAC/C,aAAO,KAAP;AACH;;AACD,QAAI8X,iBAAiB,GAAG,KAAKnB,cAAL,EAAxB;AACA,SAAKjY,sBAAL,GAA8B,IAA9B,CARiG,CASjG;;AACA,QAAIqZ,kBAAkB,GAAG,KAAK/X,cAAL,CAAoBuR,KAApB,EAAzB;AACA,SAAKjT,eAAL,GAAuB,EAAvB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,QAAIwZ,OAAO,GAAG,IAAd;AACA,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,YAAY,GAAG,EAAnB;AACA,QAAIC,qBAAqB,GAAG,EAA5B;;AACA,QAAIX,YAAJ,EAAkB;AACdA,MAAAA,YAAY,CAACtT,OAAb,CAAqB,UAAUkU,KAAV,EAAiB;AAClC;AACA,YAAI1a,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB6C,KAAK,CAAC+S,aAAN,CAAoBD,KAAK,CAAC5B,KAA1B,CAAjB,CAAJ,EAAwD;AACpD2B,UAAAA,qBAAqB,CAACzV,IAAtB,CAA2B0V,KAA3B;AACA;AACH;;AACD,YAAI/V,MAAM,GAAGiD,KAAK,CAACvB,gBAAN,CAAuBqU,KAAK,CAAC5B,KAA7B,CAAb;;AACA,YAAI,CAACnU,MAAL,EAAa;AACTiB,UAAAA,OAAO,CAACC,IAAR,CAAa,qBAAqB6U,KAAK,CAAC5B,KAA3B,GAAmC,YAAhD;AACAwB,UAAAA,OAAO,GAAG,KAAV;AACH,SAHD,MAIK;AACD1S,UAAAA,KAAK,CAACgT,uBAAN,CAA8BjW,MAA9B,EAAsC+V,KAAtC,EAA6CH,eAA7C,EAA8DC,YAA9D,EAA4EvY,MAA5E;;AACAjC,UAAAA,OAAO,CAAC8E,CAAR,CAAUmI,eAAV,CAA0BoN,kBAA1B,EAA8C1V,MAA9C;AACH;AACJ,OAfD;AAgBH,KAnCgG,CAoCjG;;;AACA0V,IAAAA,kBAAkB,CAAC7T,OAAnB,CAA2B,KAAKqU,qBAAL,CAA2B/O,IAA3B,CAAgC,IAAhC,CAA3B,EArCiG,CAsCjG;;AACA,SAAKlL,eAAL,CAAqB4Y,IAArB,CAA0B,KAAKsB,0BAAL,CAAgChP,IAAhC,CAAqC,IAArC,EAA2CyO,eAA3C,CAA1B;AACA,SAAKzZ,YAAL,CAAkB0Y,IAAlB,CAAuB,KAAKsB,0BAAL,CAAgChP,IAAhC,CAAqC,IAArC,EAA2C0O,YAA3C,CAAvB;AACA,SAAKvX,iBAAL,GAzCiG,CA0CjG;;AACAwX,IAAAA,qBAAqB,CAACjU,OAAtB,CAA8B,UAAU0T,SAAV,EAAqB;AAC/C,UAAIa,OAAO,GAAGnT,KAAK,CAAC+S,aAAN,CAAoBT,SAAS,CAACpB,KAA9B,CAAd;;AACAlR,MAAAA,KAAK,CAACgT,uBAAN,CAA8BG,OAA9B,EAAuCb,SAAvC,EAAkDK,eAAlD,EAAmEC,YAAnE,EAAiFvY,MAAjF;AACH,KAHD;;AAIA,QAAI6X,YAAJ,EAAkB;AACd,UAAIkB,eAAe,GAAGlB,YAAY,CAAC3U,GAAb,CAAiB,UAAU+U,SAAV,EAAqB;AAAE,eAAOA,SAAS,CAACpB,KAAjB;AAAyB,OAAjE,CAAtB;AACA,WAAKvR,WAAL,CAAiBiS,IAAjB,CAAsB,UAAUyB,IAAV,EAAgBC,IAAhB,EAAsB;AACxC,YAAIC,MAAM,GAAGH,eAAe,CAAChT,OAAhB,CAAwBiT,IAAI,CAAC7V,KAAL,EAAxB,CAAb;AACA,YAAIgW,MAAM,GAAGJ,eAAe,CAAChT,OAAhB,CAAwBkT,IAAI,CAAC9V,KAAL,EAAxB,CAAb;AACA,eAAO+V,MAAM,GAAGC,MAAhB;AACH,OAJD;AAKH,KAtDgG,CAuDjG;AACA;AACA;AACA;;;AACA,SAAKC,oBAAL;AACA,SAAKnY,sBAAL,CAA4BjB,MAA5B;;AACA,QAAI,CAAC4X,uBAAL,EAA8B;AAC1B,UAAIyB,OAAO,GAAG;AACV/X,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBC,+BADZ;AAEVC,QAAAA,GAAG,EAAE,KAAKC,OAFA;AAGVC,QAAAA,SAAS,EAAE,KAAKA,SAHN;AAIV3B,QAAAA,MAAM,EAAEA;AAJE,OAAd;AAMA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgCwX,OAAhC;AACH;;AACD,SAAKC,iBAAL,CAAuBnB,iBAAvB,EAA0CnY,MAA1C;AACA,WAAOqY,OAAP;AACH,GAxED;;AAyEAra,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bia,iBAA3B,GAA+C,UAAUnB,iBAAV,EAA6BnY,MAA7B,EAAqC;AAChF,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKpG,kBAAL,CAAwBga,8BAAxB,EAAJ,EAA8D;AAC1D;AACH;;AACD,QAAIC,gBAAgB,GAAG,KAAKxC,cAAL,EAAvB,CALgF,CAMhF;;AACA,QAAIyC,wBAAwB,GAAG,UAAU7O,SAAV,EAAqB8O,QAArB,EAA+BlT,OAA/B,EAAwC;AACnE,UAAImT,SAAS,GAAG5b,OAAO,CAAC8E,CAAR,CAAU+B,aAAV,CAAwBuT,iBAAiB,CAACjV,GAAlB,CAAsBwW,QAAtB,EAAgCnC,IAAhC,EAAxB,EAAgEiC,gBAAgB,CAACtW,GAAjB,CAAqBwW,QAArB,EAA+BnC,IAA/B,EAAhE,CAAhB;;AACA,UAAIoC,SAAJ,EAAe;AACX;AACH,OAJkE,CAKnE;;;AACA,UAAI7V,KAAK,GAAG;AACRxC,QAAAA,IAAI,EAAEsJ,SADE;AAERpE,QAAAA,OAAO,EAAEA,OAFD;AAGR9D,QAAAA,MAAM,EAAE8D,OAAO,CAAC/K,MAAR,KAAmB,CAAnB,GAAuB+K,OAAO,CAAC,CAAD,CAA9B,GAAoC,IAHpC;AAIR/E,QAAAA,GAAG,EAAEkE,KAAK,CAACjE,OAJH;AAKRC,QAAAA,SAAS,EAAEgE,KAAK,CAAChE,SALT;AAMR3B,QAAAA,MAAM,EAAEA;AANA,OAAZ;;AAQA2F,MAAAA,KAAK,CAAC/D,YAAN,CAAmBC,aAAnB,CAAiCiC,KAAjC;AACH,KAfD,CAPgF,CAuBhF;;;AACA,QAAI8V,iBAAiB,GAAG,UAAUC,gBAAV,EAA4B;AAChD,UAAIC,cAAc,GAAG,EAArB;AACA,UAAIC,oBAAoB,GAAG,EAA3B;AACA5B,MAAAA,iBAAiB,CAAC5T,OAAlB,CAA0B,UAAUsE,GAAV,EAAe;AACrCkR,QAAAA,oBAAoB,CAAClR,GAAG,CAACgO,KAAL,CAApB,GAAkChO,GAAlC;AACH,OAFD;;AAGAlD,MAAAA,KAAK,CAACL,WAAN,CAAkBf,OAAlB,CAA0B,UAAU7B,MAAV,EAAkB;AACxC,YAAIsX,cAAc,GAAGD,oBAAoB,CAACrX,MAAM,CAACoU,QAAP,EAAD,CAAzC;;AACA,YAAI,CAACkD,cAAD,IAAmBH,gBAAgB,CAACG,cAAD,EAAiBtX,MAAjB,CAAvC,EAAiE;AAC7DoX,UAAAA,cAAc,CAAC/W,IAAf,CAAoBL,MAApB;AACH;AACJ,OALD;;AAMA,aAAOoX,cAAP;AACH,KAbD,CAxBgF,CAsChF;;;AACA,QAAIG,mBAAmB,GAAG,UAAUC,EAAV,EAAc;AAAE,aAAOA,EAAE,CAACrD,KAAH,GAAW,GAAX,GAAiBqD,EAAE,CAACxJ,OAA3B;AAAqC,KAA/E;;AACA+I,IAAAA,wBAAwB,CAACnc,QAAQ,CAACiE,MAAT,CAAgBiL,0BAAjB,EAA6CyN,mBAA7C,EAAkE,KAAKrb,YAAvE,CAAxB;;AACA,QAAIub,mBAAmB,GAAG,UAAUD,EAAV,EAAc;AAAE,aAAOA,EAAE,CAACrD,KAAH,GAAW,GAAX,GAAiBqD,EAAE,CAACtD,UAA3B;AAAwC,KAAlF;;AACA6C,IAAAA,wBAAwB,CAACnc,QAAQ,CAACiE,MAAT,CAAgByK,0BAAjB,EAA6CmO,mBAA7C,EAAkE,KAAKtb,YAAvE,CAAxB;;AACA,QAAIub,sBAAsB,GAAG,UAAUF,EAAV,EAAc;AAAE,aAAOA,EAAE,CAACrD,KAAH,GAAW,GAAX,GAAiBqD,EAAE,CAACvD,aAA3B;AAA2C,KAAxF;;AACA8C,IAAAA,wBAAwB,CAACnc,QAAQ,CAACiE,MAAT,CAAgB6J,8BAAjB,EAAiDgP,sBAAjD,EAAyE,KAAKzb,eAA9E,CAAxB,CA5CgF,CA6ChF;;AACA,QAAI0b,qBAAqB,GAAG,UAAUH,EAAV,EAAc3e,CAAd,EAAiB;AAAE,aAAO2e,EAAE,CAAC5G,MAAH,KAAc/X,CAAC,CAAC8Z,SAAF,EAArB;AAAqC,KAApF;;AACA,SAAKiF,sBAAL,CAA4BV,iBAAiB,CAACS,qBAAD,CAA7C,EAAsEra,MAAtE;;AACA,QAAIua,yBAAyB,GAAG,UAAUL,EAAV,EAAc3e,CAAd,EAAiB;AAAE,aAAO2e,EAAE,CAACnD,IAAH,KAAYxb,CAAC,CAACwZ,SAAF,EAAnB;AAAmC,KAAtF;;AACA,QAAIyF,IAAI,GAAGZ,iBAAiB,CAACW,yBAAD,CAA5B;AACA,SAAKE,uBAAL,CAA6BD,IAA7B,EAAmCxa,MAAnC;;AACA,QAAI0a,qBAAqB,GAAG,UAAUR,EAAV,EAAc3e,CAAd,EAAiB;AAAE,aAAO2e,EAAE,CAACrM,KAAH,KAAatS,CAAC,CAACyO,cAAF,EAApB;AAAyC,KAAxF;;AACA,SAAK2Q,sBAAL,CAA4Bf,iBAAiB,CAACc,qBAAD,CAA7C,EAAsE1a,MAAtE,EApDgF,CAqDhF;;AACA,SAAK4a,qBAAL,CAA2BzC,iBAA3B,EAA8CnY,MAA9C;AACH,GAvDD;;AAwDAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bib,sBAA3B,GAAoD,UAAUR,cAAV,EAA0B9Z,MAA1B,EAAkC;AAClF,QAAI8Z,cAAc,CAACre,MAAf,GAAwB,CAA5B,EAA+B;AAC3B,UAAIof,OAAO,GAAG;AACVvZ,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgU,mBADZ;AAEVjC,QAAAA,MAAM,EAAE,IAFE;AAGV9M,QAAAA,OAAO,EAAEsT,cAHC;AAIVpX,QAAAA,MAAM,EAAE,IAJE;AAKVjB,QAAAA,GAAG,EAAE,KAAKC,OALA;AAMVC,QAAAA,SAAS,EAAE,KAAKA,SANN;AAOV3B,QAAAA,MAAM,EAAEA;AAPE,OAAd;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgCgZ,OAAhC;AACH;AACJ,GAbD;;AAcA7c,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bob,uBAA3B,GAAqD,UAAUX,cAAV,EAA0B9Z,MAA1B,EAAkC;AACnF,QAAI8Z,cAAc,CAACre,MAAf,GAAwB,CAA5B,EAA+B;AAC3B,UAAIqf,QAAQ,GAAG;AACXxZ,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgByT,oBADX;AAEXH,QAAAA,OAAO,EAAEkG,SAFE;AAGXvU,QAAAA,OAAO,EAAEsT,cAHE;AAIXpX,QAAAA,MAAM,EAAE,IAJG;AAKXjB,QAAAA,GAAG,EAAE,KAAKC,OALC;AAMXC,QAAAA,SAAS,EAAE,KAAKA,SANL;AAOX3B,QAAAA,MAAM,EAAEA;AAPG,OAAf;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgCiZ,QAAhC;AACH;AACJ,GAbD;;AAcA9c,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bsb,sBAA3B,GAAoD,UAAUb,cAAV,EAA0B9Z,MAA1B,EAAkC;AAClF,QAAI8Z,cAAc,CAACre,MAAf,GAAwB,CAA5B,EAA+B;AAC3B,UAAIuf,QAAQ,GAAG;AACX1Z,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgF,oBADX;AAEXC,QAAAA,OAAO,EAAEsT,cAFE;AAGXpX,QAAAA,MAAM,EAAE,IAHG;AAIX+D,QAAAA,QAAQ,EAAE,IAJC;AAKXhF,QAAAA,GAAG,EAAE,KAAKC,OALC;AAMXC,QAAAA,SAAS,EAAE,KAAKA,SANL;AAOX3B,QAAAA,MAAM,EAAEA;AAPG,OAAf;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgCmZ,QAAhC;AACH;AACJ,GAbD;;AAcAhd,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bub,qBAA3B,GAAmD,UAAUzC,iBAAV,EAA6BnY,MAA7B,EAAqC;AACpF,QAAIib,YAAY,GAAG,EAAnB;AACA,QAAIzB,gBAAgB,GAAG,KAAKxC,cAAL,EAAvB;;AACA,QAAIkE,OAAO,GAAG,UAAUlf,CAAV,EAAa;AACvB,UAAImf,MAAM,GAAGhD,iBAAiB,CAACnc,CAAD,CAA9B;AACA,UAAIof,KAAK,GAAG5B,gBAAgB,CAACxd,CAAD,CAA5B,CAFuB,CAGvB;;AACA,UAAI,CAACmf,MAAD,IAAWC,KAAK,CAACrE,IAArB,EAA2B;AACvB,eAAO,UAAP;AACH;;AACD,UAAIoE,MAAM,CAACtE,KAAP,KAAiBuE,KAAK,CAACvE,KAA3B,EAAkC;AAC9B,YAAIwE,SAAS,GAAG,UAAU3Y,MAAV,EAAkB;AAAE,iBAAOA,MAAM,CAACoU,QAAP,OAAsBsE,KAAK,CAACvE,KAAnC;AAA2C,SAA/E;;AACA,YAAIyE,WAAW,GAAGvd,OAAO,CAAC8E,CAAR,CAAU0Y,IAAV,CAAeC,MAAM,CAAChd,mBAAtB,EAA2C6c,SAA3C,CAAlB;;AACAJ,QAAAA,YAAY,CAAClY,IAAb,CAAkBuY,WAAlB;AACH;AACJ,KAZD;;AAaA,QAAIE,MAAM,GAAG,IAAb;;AACA,SAAK,IAAIxf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwd,gBAAgB,CAAC/d,MAArC,EAA6CO,CAAC,EAA9C,EAAkD;AAC9Ckf,MAAAA,OAAO,CAAClf,CAAD,CAAP;AACH;;AACD,QAAIif,YAAY,CAACxf,MAAb,GAAsB,CAA1B,EAA6B;AACzB,UAAIggB,QAAQ,GAAG;AACXna,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBkQ,kBADX;AAEXjL,QAAAA,OAAO,EAAEyU,YAFE;AAGXvY,QAAAA,MAAM,EAAE,IAHG;AAIXoO,QAAAA,OAAO,EAAEiK,SAJE;AAKXtZ,QAAAA,GAAG,EAAE,KAAKC,OALC;AAMXC,QAAAA,SAAS,EAAE,KAAKA,SANL;AAOX3B,QAAAA,MAAM,EAAEA;AAPG,OAAf;AASA,WAAK4B,YAAL,CAAkBC,aAAlB,CAAgC4Z,QAAhC;AACH;AACJ,GAhCD;;AAiCAzd,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwZ,0BAA3B,GAAwD,UAAU6C,OAAV,EAAmB1C,IAAnB,EAAyBC,IAAzB,EAA+B;AACnF,QAAIC,MAAM,GAAGwC,OAAO,CAAC1C,IAAI,CAAC7V,KAAL,EAAD,CAApB;AACA,QAAIgW,MAAM,GAAGuC,OAAO,CAACzC,IAAI,CAAC9V,KAAL,EAAD,CAApB;AACA,WAAO+V,MAAM,GAAGC,MAAhB;AACH,GAJD;;AAKAnb,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuZ,qBAA3B,GAAmD,UAAUlW,MAAV,EAAkB1C,MAAlB,EAA0B;AACzE0C,IAAAA,MAAM,CAAC+I,UAAP,CAAkB,KAAlB,EAAyBzL,MAAzB;AACA0C,IAAAA,MAAM,CAACqK,UAAP,CAAkB,IAAlB;AACArK,IAAAA,MAAM,CAAC4S,SAAP,CAAiB,IAAjB;AACA5S,IAAAA,MAAM,CAAC2I,iBAAP,CAAyB,KAAzB,EAAgCrL,MAAhC;AACA0C,IAAAA,MAAM,CAACqJ,cAAP,CAAsB,KAAtB,EAA6B/L,MAA7B;AACA0C,IAAAA,MAAM,CAAC+J,cAAP,CAAsB,KAAtB,EAA6BzM,MAA7B;AACH,GAPD;;AAQAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsZ,uBAA3B,GAAqD,UAAUjW,MAAV,EAAkBuV,SAAlB,EAA6BK,eAA7B,EAA8CC,YAA9C,EAA4DvY,MAA5D,EAAoE;AACrH,QAAI,CAAC0C,MAAL,EAAa;AACT;AACH,KAHoH,CAIrH;;;AACAA,IAAAA,MAAM,CAAC+I,UAAP,CAAkB,CAACwM,SAAS,CAAClB,IAA7B,EAAmC/W,MAAnC,EALqH,CAMrH;;AACA0C,IAAAA,MAAM,CAAC4S,SAAP,CAAiB2C,SAAS,CAAC3E,MAA3B,EAPqH,CAQrH;;AACA,QAAIqI,WAAW,GAAG,KAAKpc,kBAAL,CAAwBqc,cAAxB,EAAlB;;AACA,QAAI3D,SAAS,CAACpK,KAAV,IAAmB8N,WAAnB,IACC1D,SAAS,CAACpK,KAAV,IAAmB8N,WADxB,EACsC;AAClCjZ,MAAAA,MAAM,CAAC2D,cAAP,CAAsB4R,SAAS,CAACpK,KAAhC,EAAuC7N,MAAvC;AACH;;AACD,QAAI,OAAOiY,SAAS,CAACvH,OAAjB,KAA6B,QAAjC,EAA2C;AACvChO,MAAAA,MAAM,CAACqK,UAAP,CAAkBkL,SAAS,CAACvH,OAA5B;AACAhO,MAAAA,MAAM,CAAC+J,cAAP,CAAsB,IAAtB,EAA4BzM,MAA5B;AACA,WAAKpB,YAAL,CAAkBmE,IAAlB,CAAuBL,MAAvB;AACH,KAJD,MAKK;AACD,UAAI3E,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiBmV,SAAS,CAACvH,OAA3B,CAAJ,EAAyC;AACrC/M,QAAAA,OAAO,CAACC,IAAR,CAAa,gFACT,mGADS,GAET,0EAFJ;AAGH;;AACDlB,MAAAA,MAAM,CAACqK,UAAP,CAAkB,IAAlB;AACArK,MAAAA,MAAM,CAAC+J,cAAP,CAAsB,KAAtB,EAA6BzM,MAA7B;AACH;;AACD,QAAI,OAAOiY,SAAS,CAACtB,aAAjB,KAAmC,QAAvC,EAAiD;AAC7C,WAAKhY,eAAL,CAAqBoE,IAArB,CAA0BL,MAA1B;AACAA,MAAAA,MAAM,CAAC2I,iBAAP,CAAyB,IAAzB,EAA+BrL,MAA/B;AACAsY,MAAAA,eAAe,CAAC5V,MAAM,CAACS,KAAP,EAAD,CAAf,GAAkC8U,SAAS,CAACtB,aAA5C;AACH,KAJD,MAKK;AACDjU,MAAAA,MAAM,CAAC2I,iBAAP,CAAyB,KAAzB,EAAgCrL,MAAhC;AACH;;AACD,QAAI,OAAOiY,SAAS,CAACrB,UAAjB,KAAgC,QAApC,EAA8C;AAC1C,WAAK/X,YAAL,CAAkBkE,IAAlB,CAAuBL,MAAvB;AACAA,MAAAA,MAAM,CAACqJ,cAAP,CAAsB,IAAtB,EAA4B/L,MAA5B;AACAuY,MAAAA,YAAY,CAAC7V,MAAM,CAACS,KAAP,EAAD,CAAZ,GAA+B8U,SAAS,CAACrB,UAAzC;AACH,KAJD,MAKK;AACDlU,MAAAA,MAAM,CAACqJ,cAAP,CAAsB,KAAtB,EAA6B/L,MAA7B;AACH;AACJ,GA5CD;;AA6CAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgS,cAA3B,GAA4C,UAAU3L,IAAV,EAAgB;AACxD,WAAO,KAAKmW,UAAL,CAAgBnW,IAAhB,EAAsB,KAAK+H,aAAL,CAAmB5D,IAAnB,CAAwB,IAAxB,CAAtB,CAAP;AACH,GAFD;;AAGA7L,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bwc,UAA3B,GAAwC,UAAUnW,IAAV,EAAgBoW,oBAAhB,EAAsC;AAC1E,QAAIC,YAAY,GAAG,EAAnB;;AACA,QAAIrW,IAAJ,EAAU;AACNA,MAAAA,IAAI,CAACnB,OAAL,CAAa,UAAUlJ,GAAV,EAAe;AACxB,YAAIqH,MAAM,GAAGoZ,oBAAoB,CAACzgB,GAAD,CAAjC;;AACA,YAAIqH,MAAJ,EAAY;AACRqZ,UAAAA,YAAY,CAAChZ,IAAb,CAAkBL,MAAlB;AACH;AACJ,OALD;AAMH;;AACD,WAAOqZ,YAAP;AACH,GAXD,CAthD8C,CAkiD9C;;;AACA/d,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2c,uBAA3B,GAAqD,UAAU3gB,GAAV,EAAe;AAChE,QAAIA,GAAG,IAAI,IAAX,EAAiB;AACb,aAAO,IAAP;AACH;;AACD,QAAIqH,MAAM,GAAG,KAAK+K,aAAL,CAAmBpS,GAAnB,CAAb;;AACA,QAAI,CAACqH,MAAL,EAAa;AACTiB,MAAAA,OAAO,CAACC,IAAR,CAAa,oCAAoCvI,GAAjD;AACH;;AACD,WAAOqH,MAAP;AACH,GATD;;AAUA1E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+E,gBAA3B,GAA8C,UAAU/I,GAAV,EAAe;AACzD,WAAO,KAAK4gB,SAAL,CAAe5gB,GAAf,EAAoB,KAAKgF,cAAzB,CAAP;AACH,GAFD;;AAGArC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BoO,aAA3B,GAA2C,UAAUpS,GAAV,EAAe;AACtD,WAAO,KAAK4gB,SAAL,CAAe5gB,GAAf,EAAoB,KAAKiK,WAAzB,CAAP;AACH,GAFD;;AAGAtH,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4c,SAA3B,GAAuC,UAAU5gB,GAAV,EAAe6gB,UAAf,EAA2B;AAC9D,QAAI,CAAC7gB,GAAL,EAAU;AACN,aAAO,IAAP;AACH;;AACD,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkgB,UAAU,CAACzgB,MAA/B,EAAuCO,CAAC,EAAxC,EAA4C;AACxC,UAAI,KAAKmgB,YAAL,CAAkBD,UAAU,CAAClgB,CAAD,CAA5B,EAAiCX,GAAjC,CAAJ,EAA2C;AACvC,eAAO6gB,UAAU,CAAClgB,CAAD,CAAjB;AACH;AACJ;;AACD,WAAO,KAAK0c,aAAL,CAAmBrd,GAAnB,CAAP;AACH,GAVD;;AAWA2C,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BqZ,aAA3B,GAA2C,UAAUrd,GAAV,EAAe;AACtD,QAAIsK,KAAK,GAAG,IAAZ;;AACA,QAAI,CAAC,KAAK8Q,gBAAN,IAA0B,CAAC1Y,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB,KAAK2T,gBAAtB,CAA3B,IAAsE1Y,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkB,KAAKR,gBAAvB,CAA1E,EAAoH;AAChH,aAAO,IAAP;AACH;;AACD,WAAO1Y,OAAO,CAAC8E,CAAR,CAAU0Y,IAAV,CAAe,KAAK9E,gBAApB,EAAsC,UAAU2F,QAAV,EAAoB;AAC7D,aAAOzW,KAAK,CAACwW,YAAN,CAAmBC,QAAnB,EAA6B/gB,GAA7B,CAAP;AACH,KAFM,CAAP;AAGH,GARD;;AASA2C,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8c,YAA3B,GAA0C,UAAUzZ,MAAV,EAAkBrH,GAAlB,EAAuB;AAC7D,QAAIghB,aAAa,GAAG3Z,MAAM,KAAKrH,GAA/B;AACA,QAAIihB,aAAa,GAAG5Z,MAAM,CAAC+B,SAAP,OAAuBpJ,GAA3C;AACA,QAAIkhB,SAAS,GAAG7Z,MAAM,CAACoU,QAAP,MAAqBzb,GAArC;AACA,WAAOghB,aAAa,IAAIC,aAAjB,IAAkCC,SAAzC;AACH,GALD;;AAMAve,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bmd,uBAA3B,GAAqD,UAAU9Z,MAAV,EAAkB+Z,QAAlB,EAA4BC,cAA5B,EAA4C;AAC7F,QAAIA,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAAEA,MAAAA,cAAc,GAAG,KAAjB;AAAyB;;AAC1D,QAAI,CAACha,MAAL,EAAa;AACT,aAAO,IAAP;AACH;;AACD,QAAIia,UAAU,GAAG,KAAKC,aAAL,CAAmBla,MAAM,CAAC+B,SAAP,EAAnB,EAAuC/B,MAAvC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D+Z,QAA3D,CAAjB;;AACA,QAAIC,cAAJ,EAAoB;AAChB,aAAO,KAAKG,yBAAL,CAA+Bna,MAA/B,EAAuCia,UAAvC,CAAP;AACH,KAFD,MAGK;AACD,aAAOA,UAAP;AACH;AACJ,GAZD;;AAaA3e,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Byd,oCAA3B,GAAkE,UAAUxK,WAAV,EAAuByK,mBAAvB,EAA4CN,QAA5C,EAAsD;AACpH,QAAIO,WAAW,GAAGD,mBAAmB,GAAGA,mBAAmB,CAACvK,cAApB,EAAH,GAA0C,IAA/E;;AACA,QAAIwK,WAAJ,EAAiB;AACb,aAAO,KAAKJ,aAAL,CAAmBI,WAAnB,EAAgC,IAAhC,EAAsC1K,WAAtC,EAAmDyK,mBAAnD,EAAwEN,QAAxE,CAAP;AACH,KAFD,MAGK;AACD,aAAO,IAAP;AACH;AACJ,GARD;;AASAze,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4d,4BAA3B,GAA0D,UAAU3K,WAAV,EAAuBmK,QAAvB,EAAiC;AACvF,WAAO,KAAKK,oCAAL,CAA0CxK,WAA1C,EAAuDA,WAAW,CAAC4D,sBAAZ,EAAvD,EAA6FuG,QAA7F,CAAP;AACH,GAFD,CAnmD8C,CAsmD9C;;;AACAze,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bud,aAA3B,GAA2C,UAAUM,MAAV,EAAkBxa,MAAlB,EAA0B4P,WAA1B,EAAuCyK,mBAAvC,EAA4DN,QAA5D,EAAsE;AAC7G,QAAIU,iBAAiB,GAAGD,MAAM,CAACC,iBAA/B;;AACA,QAAIA,iBAAJ,EAAuB;AACnB,UAAIC,MAAM,GAAG;AACTF,QAAAA,MAAM,EAAEA,MADC;AAETxa,QAAAA,MAAM,EAAEA,MAFC;AAGT4P,QAAAA,WAAW,EAAEA,WAHJ;AAITyK,QAAAA,mBAAmB,EAAEA,mBAJZ;AAKTN,QAAAA,QAAQ,EAAEA,QALD;AAMThb,QAAAA,GAAG,EAAE,KAAKlC,kBAAL,CAAwB8d,MAAxB,EANI;AAOTC,QAAAA,OAAO,EAAE,KAAK/d,kBAAL,CAAwBge,UAAxB;AAPA,OAAb;;AASA,UAAI,OAAOJ,iBAAP,KAA6B,UAAjC,EAA6C;AACzC;AACA,eAAOA,iBAAiB,CAACC,MAAD,CAAxB;AACH,OAHD,MAIK,IAAI,OAAOD,iBAAP,KAA6B,QAAjC,EAA2C;AAC5C;AACA,eAAO,KAAKK,iBAAL,CAAuBC,QAAvB,CAAgCN,iBAAhC,EAAmDC,MAAnD,CAAP;AACH,OAHI,MAIA;AACDzZ,QAAAA,OAAO,CAACC,IAAR,CAAa,2DAAb;AACA,eAAO,EAAP;AACH;AACJ,KAtBD,MAuBK,IAAIsZ,MAAM,CAACP,UAAP,IAAqB,IAAzB,EAA+B;AAChC,aAAOO,MAAM,CAACP,UAAd;AACH,KAFI,MAGA,IAAIO,MAAM,CAACQ,KAAX,EAAkB;AACnB,aAAO3f,OAAO,CAAC8E,CAAR,CAAU8a,oBAAV,CAA+BT,MAAM,CAACQ,KAAtC,CAAP;AACH,KAFI,MAGA;AACD,aAAO,EAAP;AACH;AACJ,GAlCD;AAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA1f,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bwd,yBAA3B,GAAuD,UAAUna,MAAV,EAAkBia,UAAlB,EAA8B;AACjF,QAAI,KAAKpd,kBAAL,CAAwBqe,yBAAxB,EAAJ,EAAyD;AACrD,aAAOjB,UAAP;AACH,KAHgF,CAIjF;;;AACA,QAAIjY,gBAAgB,GAAGhC,MAAM,CAAC+B,SAAP,GAAmBC,gBAA1C;;AACA,QAAImZ,uBAAuB,GAAG9f,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB4B,gBAAjB,CAA9B;;AACA,QAAIgM,OAAO,GAAG,IAAd;AACA,QAAIoN,YAAJ,CARiF,CASjF;;AACA,QAAID,uBAAJ,EAA6B;AACzBnN,MAAAA,OAAO,GAAGhM,gBAAgB,GAAGA,gBAAgB,CAACiI,UAAjB,EAAH,GAAmC,IAA7D;AACAmR,MAAAA,YAAY,GAAG,IAAf;AACH,KAHD,MAIK;AACD,UAAIC,aAAa,GAAGrb,MAAM,CAACgK,aAAP,EAApB;AACA,UAAIsR,kBAAkB,GAAG,KAAKhf,SAAL,IAAkB,CAAC,KAAK2V,eAAL,EAA5C;;AACA,UAAIoJ,aAAa,IAAIC,kBAArB,EAAyC;AACrCtN,QAAAA,OAAO,GAAGhO,MAAM,CAACiK,UAAP,EAAV;AACAmR,QAAAA,YAAY,GAAG,IAAf;AACH,OAHD,MAIK;AACDA,QAAAA,YAAY,GAAG,KAAf;AACH;AACJ;;AACD,QAAIA,YAAJ,EAAkB;AACd,UAAIG,aAAa,GAAI,OAAOvN,OAAP,KAAmB,QAApB,GAAgCA,OAAhC,GAA0C,MAA9D;AACA,UAAIwN,cAAc,GAAG,KAAK3e,kBAAL,CAAwB4e,iBAAxB,EAArB;AACA,UAAIC,uBAAuB,GAAGF,cAAc,CAACD,aAAD,EAAgBA,aAAhB,CAA5C;AACA,aAAOG,uBAAuB,GAAG,GAA1B,GAAgCzB,UAAhC,GAA6C,GAApD;AACH,KALD,MAMK;AACD,aAAOA,UAAP;AACH;AACJ,GAlCD,CAtqD8C,CAysD9C;AACA;;;AACA3e,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Bgf,cAA3B,GAA4C,UAAUxH,KAAV,EAAiByH,UAAjB,EAA6B;AACrE,QAAI,CAACzH,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,QAAIA,KAAK,YAAYla,aAAa,CAAC4hB,WAAnC,EAAgD;AAC5C,aAAO1H,KAAP;AACH;;AACD,QAAI2H,eAAe,GAAG,KAAKpX,2BAAL,EAAtB;AACA,QAAIqX,eAAe,GAAG,OAAOH,UAAP,KAAsB,QAA5C;AACA,QAAI1b,MAAM,GAAG,IAAb;AACA,SAAKuP,WAAL,CAAiBuM,6BAAjB,CAA+CF,eAA/C,EAAgE,UAAUxX,KAAV,EAAiB;AAC7E,UAAIA,KAAK,YAAYrK,aAAa,CAAC4hB,WAAnC,EAAgD;AAC5C,YAAIjM,WAAW,GAAGtL,KAAlB;AACA,YAAI2X,OAAO,GAAG,KAAK,CAAnB;;AACA,YAAIF,eAAJ,EAAqB;AACjBE,UAAAA,OAAO,GAAG9H,KAAK,KAAKvE,WAAW,CAACsM,UAAZ,EAAV,IAAsCN,UAAU,KAAKhM,WAAW,CAACuM,aAAZ,EAA/D;AACH,SAFD,MAGK;AACDF,UAAAA,OAAO,GAAG9H,KAAK,KAAKvE,WAAW,CAACsM,UAAZ,EAApB;AACH;;AACD,YAAID,OAAJ,EAAa;AACT/b,UAAAA,MAAM,GAAG0P,WAAT;AACH;AACJ;AACJ,KAdD;AAeA,WAAO1P,MAAP;AACH,GA1BD;;AA2BA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2Byf,OAA3B,GAAqC,YAAY;AAC7C,WAAO,KAAKhgB,KAAZ;AACH,GAFD;;AAGAd,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0B,kBAA3B,GAAgD,UAAUf,MAAV,EAAkBI,iBAAlB,EAAqC;AACjF,SAAKxB,YAAL,GAAoB,KAAKmgB,cAAL,CAAoB3e,iBAApB,EAAuC,KAAKxB,YAA5C,EAA0D,UAAUiK,GAAV,EAAemW,IAAf,EAAqB;AAAE,aAAOnW,GAAG,CAAC4D,cAAJ,CAAmBuS,IAAnB,EAAyBhf,MAAzB,CAAP;AAA0C,KAA3H,EACpB;AACA,gBAAY;AAAE,aAAO,IAAP;AAAc,KAFR,EAGpB;AACA,cAAUkd,MAAV,EAAkB;AAAE,aAAO,CAAC,CAACA,MAAM,CAACxM,OAAhB;AAA0B,KAJ1B,CAApB,CADiF,CAMjF;;AACA,SAAK9R,YAAL,CAAkB2F,OAAlB,CAA0B,UAAUsE,GAAV,EAAe;AACrC,UAAI,CAACA,GAAG,CAAC8D,UAAJ,EAAL,EAAuB;AACnB9D,QAAAA,GAAG,CAACkE,UAAJ,CAAelE,GAAG,CAACpE,SAAJ,GAAgBiM,OAA/B;AACH;AACJ,KAJD;AAKH,GAZD;;AAaA1S,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwB,sBAA3B,GAAoD,UAAUb,MAAV,EAAkBI,iBAAlB,EAAqC;AACrF,SAAKzB,eAAL,GAAuB,KAAKogB,cAAL,CAAoB3e,iBAApB,EAAuC,KAAKzB,eAA5C,EAA6D,UAAUkK,GAAV,EAAemW,IAAf,EAAqB;AAAE,aAAOnW,GAAG,CAACwC,iBAAJ,CAAsB2T,IAAtB,EAA4Bhf,MAA5B,CAAP;AAA6C,KAAjI,EAAmI,UAAUkd,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACvG,aAAd;AAA8B,KAArL,EAAuL,UAAUuG,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAAClF,QAAd;AAAyB,KAApO,CAAvB;AACH,GAFD;;AAGAha,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0f,cAA3B,GAA4C,UAAU3e,iBAAV,EAA6B6e,YAA7B,EAA2CC,WAA3C,EAAwDC,YAAxD,EAAsEC,YAAtE,EAAoF;AAC5H,QAAIzZ,KAAK,GAAG,IAAZ;;AACA,QAAI,CAACsZ,YAAL,EAAmB;AACfA,MAAAA,YAAY,GAAG,EAAf;AACH,KAJ2H,CAK5H;;;AACA,QAAII,uBAAuB,GAAG,UAAUxW,GAAV,EAAe;AAAE,aAAOlD,KAAK,CAACtF,cAAN,CAAqB0F,OAArB,CAA6B8C,GAA7B,KAAqC,CAA5C;AAAgD,KAA/F;;AACA,QAAIyW,yBAAyB,GAAG,UAAUzW,GAAV,EAAe;AAAE,aAAOlD,KAAK,CAACtF,cAAN,CAAqB0F,OAArB,CAA6B8C,GAA7B,IAAoC,CAA3C;AAA+C,KAAhG;;AACA,QAAI0W,UAAU,GAAG,UAAU1W,GAAV,EAAe;AAAE,aAAO,CAACzI,iBAAD,IAAsBA,iBAAiB,CAAC2F,OAAlB,CAA0B8C,GAA1B,IAAiC,CAA9D;AAAkE,KAApG;;AACA,QAAI2W,WAAW,GAAGP,YAAY,CAACQ,MAAb,CAAoBH,yBAApB,CAAlB;AACA,QAAII,YAAY,GAAGT,YAAY,CAACQ,MAAb,CAAoBJ,uBAApB,CAAnB;AACA,QAAIM,cAAc,GAAG,KAAKtf,cAAL,CAAoBof,MAApB,CAA2BF,UAA3B,CAArB;AACAC,IAAAA,WAAW,CAACjb,OAAZ,CAAoB,UAAUsE,GAAV,EAAe;AAAE,aAAOqW,WAAW,CAACrW,GAAD,EAAM,KAAN,CAAlB;AAAiC,KAAtE;AACA,QAAI+W,OAAO,GAAG,EAAd,CAb4H,CAc5H;AACA;;AACAD,IAAAA,cAAc,CAACpb,OAAf,CAAuB,UAAUsE,GAAV,EAAe;AAClC,UAAIgH,KAAK,GAAGsP,YAAY,CAACtW,GAAG,CAACpE,SAAJ,EAAD,CAAxB;;AACA,UAAI,OAAOoL,KAAP,KAAiB,QAArB,EAA+B;AAC3B+P,QAAAA,OAAO,CAAC7c,IAAR,CAAa8F,GAAb;AACH;AACJ,KALD,EAhB4H,CAsB5H;;AACA+W,IAAAA,OAAO,CAACrI,IAAR,CAAa,UAAUyB,IAAV,EAAgBC,IAAhB,EAAsB;AAC/B,UAAIC,MAAM,GAAGiG,YAAY,CAACnG,IAAI,CAACvU,SAAL,EAAD,CAAzB;AACA,UAAI0U,MAAM,GAAGgG,YAAY,CAAClG,IAAI,CAACxU,SAAL,EAAD,CAAzB;;AACA,UAAIyU,MAAM,KAAKC,MAAf,EAAuB;AACnB,eAAO,CAAP;AACH,OAFD,MAGK,IAAID,MAAM,GAAGC,MAAb,EAAqB;AACtB,eAAO,CAAC,CAAR;AACH,OAFI,MAGA;AACD,eAAO,CAAP;AACH;AACJ,KAZD,EAvB4H,CAoC5H;AACA;;AACAwG,IAAAA,cAAc,CAACpb,OAAf,CAAuB,UAAUsE,GAAV,EAAe;AAClC,UAAIgX,YAAY,GAAGT,YAAY,CAACvW,GAAG,CAACpE,SAAJ,EAAD,CAA/B;;AACA,UAAIob,YAAJ,EAAkB;AACd;AACA,YAAID,OAAO,CAAC7Z,OAAR,CAAgB8C,GAAhB,KAAwB,CAA5B,EAA+B;AAC3B;AACH;;AACD+W,QAAAA,OAAO,CAAC7c,IAAR,CAAa8F,GAAb;AACH;AACJ,KATD;AAUA+W,IAAAA,OAAO,CAACrb,OAAR,CAAgB,UAAUsE,GAAV,EAAe;AAAE,aAAOqW,WAAW,CAACrW,GAAD,EAAM,IAAN,CAAlB;AAAgC,KAAjE;AACA,QAAIiX,GAAG,GAAGJ,YAAY,CAAClY,MAAb,CAAoBoY,OAApB,CAAV;AACA,WAAOE,GAAP;AACH,GAnDD;;AAoDA9hB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByB,mBAA3B,GAAiD,UAAUd,MAAV,EAAkBI,iBAAlB,EAAqC;AAClF,SAAKvB,YAAL,GAAoB,KAAKkgB,cAAL,CAAoB3e,iBAApB,EAAuC,KAAKvB,YAA5C,EAA0D,UAAUgK,GAAV,EAAemW,IAAf,EAAqB;AAAE,aAAOnW,GAAG,CAACkD,cAAJ,CAAmBiT,IAAnB,EAAyBhf,MAAzB,CAAP;AAA0C,KAA3H,EAA6H,UAAUkd,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACtG,UAAd;AAA2B,KAA5K,EAA8K,UAAUsG,MAAV,EAAkB;AAAE,aAAOA,MAAM,CAACxZ,KAAd;AAAsB,KAAxN,CAApB;AACH,GAFD;;AAGA1F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0gB,qBAA3B,GAAmD,UAAU/f,MAAV,EAAkB;AACjE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIggB,UAAU,GAAG,EAAjB;AACA,SAAK7N,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoD,KAAK3R,iBAAzD,EAA4E,UAAUuG,KAAV,EAAiB;AACzF,UAAIA,KAAK,YAAYzJ,qBAAqB,CAAC2J,mBAA3C,EAAgE;AAC5D,YAAI+Y,UAAU,GAAG;AACbC,UAAAA,OAAO,EAAElZ,KAAK,CAAC4X,UAAN,EADI;AAEbuB,UAAAA,IAAI,EAAEnZ,KAAK,CAACwL,cAAN,GAAuB4N;AAFhB,SAAjB;AAIAJ,QAAAA,UAAU,CAACjd,IAAX,CAAgBkd,UAAhB;AACH;AACJ,KARD;AASA,SAAKI,mBAAL,CAAyBL,UAAzB,EAAqChgB,MAArC;AACH,GAbD;;AAcAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BihB,mBAA3B,GAAiD,YAAY;AACzD,QAAIC,gBAAgB,GAAG,EAAvB;AACA,SAAKpO,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoD,KAAKC,gBAAzD,EAA2E,UAAUmO,IAAV,EAAgB;AACvF,UAAIA,IAAI,YAAYjjB,qBAAqB,CAAC2J,mBAA1C,EAA+D;AAC3D,YAAI6V,mBAAmB,GAAGyD,IAA1B;AACAD,QAAAA,gBAAgB,CAACxd,IAAjB,CAAsB;AAClBmd,UAAAA,OAAO,EAAEnD,mBAAmB,CAAC6B,UAApB,EADS;AAElBuB,UAAAA,IAAI,EAAEpD,mBAAmB,CAAC0D,UAApB;AAFY,SAAtB;AAIH;AACJ,KARD;AASA,WAAOF,gBAAP;AACH,GAZD;;AAaAviB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BghB,mBAA3B,GAAiD,UAAUL,UAAV,EAAsBhgB,MAAtB,EAA8B;AAC3E,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,SAAKkR,sBAAL,CAA4BC,KAA5B;AACA,QAAIuP,cAAc,GAAG,EAArB;AACAV,IAAAA,UAAU,CAACzb,OAAX,CAAmB,UAAU0T,SAAV,EAAqB;AACpC,UAAI0I,QAAQ,GAAG1I,SAAS,CAACiI,OAAzB;AACA,UAAIU,QAAQ,GAAG3I,SAAS,CAACkI,IAAzB;;AACA,UAAIpD,mBAAmB,GAAGpX,KAAK,CAACuQ,sBAAN,CAA6ByK,QAA7B,CAA1B;;AACA,UAAI,CAAC5D,mBAAL,EAA0B;AACtB;AACH;;AACD,UAAIA,mBAAmB,CAAC0D,UAApB,OAAqCG,QAAzC,EAAmD;AAC/C;AACH;;AACDjb,MAAAA,KAAK,CAACX,MAAN,CAAa6b,GAAb,CAAiB,uBAAuB9D,mBAAmB,CAAC6B,UAApB,EAAvB,GAA0D,GAA1D,GAAgEgC,QAAhE,GAA2E,GAA5F;;AACA7D,MAAAA,mBAAmB,CAAC+D,WAApB,CAAgCF,QAAhC;AACAF,MAAAA,cAAc,CAAC3d,IAAf,CAAoBga,mBAApB;AACH,KAbD;AAcA,SAAKgE,+BAAL,CAAqC/gB,MAArC;AACA,SAAKkF,8BAAL,CAAoClF,MAApC;AACA0gB,IAAAA,cAAc,CAACnc,OAAf,CAAuB,UAAUwY,mBAAV,EAA+B;AAClD,UAAIjZ,KAAK,GAAG;AACRxC,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgByf,yBADd;AAER1O,QAAAA,WAAW,EAAEyK,mBAFL;AAGRtb,QAAAA,GAAG,EAAEkE,KAAK,CAACjE,OAHH;AAIRC,QAAAA,SAAS,EAAEgE,KAAK,CAAChE;AAJT,OAAZ;;AAMAgE,MAAAA,KAAK,CAAC/D,YAAN,CAAmBC,aAAnB,CAAiCiC,KAAjC;AACH,KARD;AASA,SAAKoN,sBAAL,CAA4BQ,MAA5B;AACH,GA/BD,CA30D8C,CA22D9C;;;AACA1T,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4hB,oBAA3B,GAAkD,UAAU5lB,GAAV,EAAeulB,QAAf,EAAyB5gB,MAAzB,EAAiC;AAC/E,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIkhB,WAAJ;;AACA,QAAI7lB,GAAG,YAAYkC,qBAAqB,CAAC2J,mBAAzC,EAA8D;AAC1Dga,MAAAA,WAAW,GAAG7lB,GAAG,CAAC8H,KAAJ,EAAd;AACH,KAFD,MAGK;AACD+d,MAAAA,WAAW,GAAG7lB,GAAd;AACH;;AACD,SAAKglB,mBAAL,CAAyB,CAAC;AAAEH,MAAAA,OAAO,EAAEgB,WAAX;AAAwBf,MAAAA,IAAI,EAAES;AAA9B,KAAD,CAAzB,EAAqE5gB,MAArE;AACH,GAVD;;AAWAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6W,sBAA3B,GAAoD,UAAU7a,GAAV,EAAe;AAC/D,QAAIA,GAAG,YAAYkC,qBAAqB,CAAC2J,mBAAzC,EAA8D;AAC1D,aAAO7L,GAAP;AACH;;AACD,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzBsI,MAAAA,OAAO,CAAC6L,KAAR,CAAc,qCAAd;AACH,KAN8D,CAO/D;;;AACA,QAAIsQ,GAAG,GAAG,IAAV;AACA,SAAK3N,WAAL,CAAiBC,4BAAjB,CAA8C,IAA9C,EAAoD,KAAKC,gBAAzD,EAA2E,UAAUmO,IAAV,EAAgB;AACvF,UAAIA,IAAI,YAAYjjB,qBAAqB,CAAC2J,mBAA1C,EAA+D;AAC3D,YAAI6V,mBAAmB,GAAGyD,IAA1B;;AACA,YAAIzD,mBAAmB,CAAC5Z,KAApB,OAAgC9H,GAApC,EAAyC;AACrCykB,UAAAA,GAAG,GAAG/C,mBAAN;AACH;AACJ;AACJ,KAPD;AAQA,WAAO+C,GAAP;AACH,GAlBD;;AAmBA9hB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B8hB,0BAA3B,GAAwD,YAAY;AAChE,QAAIxb,KAAK,GAAG,IAAZ;;AACA,QAAIyb,iBAAJ;;AACA,QAAI,KAAKpiB,SAAL,IAAkB,CAAC,KAAKb,uBAA5B,EAAqD;AACjD;AACA;AACAijB,MAAAA,iBAAiB,GAAGrjB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiB,KAAKna,WAAtB,EAAmC,UAAU5C,MAAV,EAAkB;AACrE,YAAI2e,cAAc,GAAG1b,KAAK,CAAC8Q,gBAAN,IAA0B9Q,KAAK,CAAC8Q,gBAAN,CAAuB1Q,OAAvB,CAA+BrD,MAA/B,KAA0C,CAAzF;AACA,YAAI4e,UAAU,GAAG3b,KAAK,CAAC/G,YAAN,IAAsB+G,KAAK,CAAC/G,YAAN,CAAmBmH,OAAnB,CAA2BrD,MAA3B,KAAsC,CAA7E;AACA,eAAO2e,cAAc,IAAIC,UAAzB;AACH,OAJmB,CAApB;AAKH,KARD,MASK;AACD;AACA;AACAF,MAAAA,iBAAiB,GAAGrjB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiB,KAAKna,WAAtB,EAAmC,UAAU5C,MAAV,EAAkB;AACrE;AACA,YAAI2e,cAAc,GAAG1b,KAAK,CAAC8Q,gBAAN,IAA0B9Q,KAAK,CAAC8Q,gBAAN,CAAuB1Q,OAAvB,CAA+BrD,MAA/B,KAA0C,CAAzF;AACA,eAAO2e,cAAc,IAAI3e,MAAM,CAACqS,SAAP,EAAzB;AACH,OAJmB,CAApB;AAKH;;AACD,WAAOqM,iBAAP;AACH,GAtBD;;AAuBApjB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BkiB,wBAA3B,GAAsD,UAAU/a,OAAV,EAAmB;AACrE,QAAI5D,MAAM,GAAG,KAAb;AACA4D,IAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAUsE,GAAV,EAAe;AAC3B,UAAI9K,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB+F,GAAG,CAACpE,SAAJ,GAAgBsE,OAAjC,CAAJ,EAA+C;AAC3CnG,QAAAA,MAAM,GAAG,IAAT;AACH;AACJ,KAJD;AAKA,WAAOA,MAAP;AACH,GARD;;AASA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BmiB,+BAA3B,GAA6D,YAAY;AACrE,QAAI7b,KAAK,GAAG,IAAZ;;AACA,SAAK8b,mBAAL,GAA2B,EAA3B;;AACA,QAAIC,SAAS,GAAG,UAAU7Y,GAAV,EAAe;AAC3B,UAAIqU,MAAM,GAAGrU,GAAG,CAACpE,SAAJ,EAAb;;AACA,UAAIyY,MAAM,IAAInf,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiBoa,MAAM,CAACyE,YAAxB,CAAd,EAAqD;AACjDhc,QAAAA,KAAK,CAAC8b,mBAAN,CAA0B1e,IAA1B,CAA+B8F,GAA/B;AACH;AACJ,KALD;;AAMA,SAAKvD,WAAL,CAAiBf,OAAjB,CAAyBmd,SAAzB;;AACA,QAAI,KAAKjL,gBAAT,EAA2B;AACvB,WAAKA,gBAAL,CAAsBlS,OAAtB,CAA8Bmd,SAA9B;AACH;AACJ,GAbD;;AAcA1jB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BuiB,sBAA3B,GAAoD,YAAY;AAC5D,WAAO,KAAKH,mBAAZ;AACH,GAFD;;AAGAzjB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4B,sBAA3B,GAAoD,UAAUjB,MAAV,EAAkB;AAClE,QAAIohB,iBAAiB,GAAG,KAAKD,0BAAL,EAAxB;AACA,SAAKU,mBAAL,CAAyBT,iBAAzB;AACA,SAAKI,+BAAL,GAHkE,CAIlE;;AACA,SAAKT,+BAAL,CAAqC/gB,MAArC,EALkE,CAMlE;;AACA,SAAKkF,8BAAL,CAAoClF,MAApC;AACH,GARD;;AASAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByiB,yBAA3B,GAAuD,YAAY;AAC/D,WAAO,KAAK3jB,uBAAZ;AACH,GAFD;;AAGAH,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0iB,mBAA3B,GAAiD,UAAUC,OAAV,EAAmBhiB,MAAnB,EAA2B;AACxE,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIiiB,cAAc,GAAGD,OAAO,IAAIA,OAAO,CAACvmB,MAAR,GAAiB,CAAjD,CAFwE,CAGxE;;AACA,QAAI,CAACwmB,cAAD,IAAmB,CAAC,KAAK9jB,uBAA7B,EAAsD;AAClD;AACH;;AACD,QAAI8jB,cAAJ,EAAoB;AAChB,WAAKC,iCAAL,CAAuCF,OAAvC;AACA,UAAI1hB,kBAAkB,GAAG,KAAKC,aAAL,CAAmBC,gBAAnB,CAAoCwhB,OAApC,EAA6C,KAA7C,CAAzB;AACA,WAAKG,qBAAL,GAA6B7hB,kBAAkB,CAACI,UAAhD;AACA,WAAKxC,uBAAL,GAA+BoC,kBAAkB,CAACK,QAAnB,GAA8B,CAA7D;AACA,WAAK2D,gBAAL,GAAwB,KAAK1D,kBAAL,CAAwB,KAAKuhB,qBAA7B,CAAxB;AACA,WAAKhkB,uBAAL,GAA+B,IAA/B;AACH,KAPD,MAQK;AACD,WAAKgkB,qBAAL,GAA6B,IAA7B;AACA,WAAKjkB,uBAAL,GAA+B,CAAC,CAAhC;AACA,WAAKoG,gBAAL,GAAwB,IAAxB;AACA,WAAKnG,uBAAL,GAA+B,KAA/B;AACH;;AACD,SAAK6C,iBAAL;AACA,SAAKC,sBAAL,CAA4BjB,MAA5B;AACH,GAvBD;;AAwBAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6iB,iCAA3B,GAA+D,UAAUF,OAAV,EAAmB;AAC9E,QAAIrX,cAAc,GAAG,KAAKpL,kBAAL,CAAwB6iB,6BAAxB,EAArB;AACA,QAAIC,aAAa,GAAG,KAAK9iB,kBAAL,CAAwB+iB,kCAAxB,EAApB;;AACA,QAAI,CAAC3X,cAAD,IAAmB,CAAC0X,aAAxB,EAAuC;AACnC,aAAOtH,SAAP;AACH;;AACD,QAAIiH,OAAJ,EAAa;AACTO,MAAAA,gBAAgB,CAACP,OAAD,CAAhB;AACH;;AACD,aAASO,gBAAT,CAA0BC,QAA1B,EAAoC;AAChCA,MAAAA,QAAQ,CAACje,OAAT,CAAiB,UAAUke,cAAV,EAA0B;AACvC,YAAIC,OAAO,GAAG3kB,OAAO,CAAC8E,CAAR,CAAUC,MAAV,CAAiB2f,cAAc,CAACE,QAAhC,CAAd;;AACA,YAAID,OAAJ,EAAa;AACT,cAAI1F,WAAW,GAAGyF,cAAlB;;AACA,cAAIJ,aAAJ,EAAmB;AACfA,YAAAA,aAAa,CAACrF,WAAD,CAAb;AACH;;AACDuF,UAAAA,gBAAgB,CAACvF,WAAW,CAAC2F,QAAb,CAAhB;AACH,SAND,MAOK;AACD,cAAIzF,MAAM,GAAGuF,cAAb;;AACA,cAAI9X,cAAJ,EAAoB;AAChBA,YAAAA,cAAc,CAACuS,MAAD,CAAd;AACH;AACJ;AACJ,OAfD;AAgBH;AACJ,GA3BD,CA/9D8C,CA2/D9C;;;AACAlf,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2B,iBAA3B,GAA+C,YAAY;AACvD,QAAI,KAAK4hB,kBAAT,EAA6B;AACzB,WAAKC,gBAAL,GAAwB,KAAKvd,WAA7B;AACH;;AACD,QAAI,KAAKhB,gBAAL,IAAyB,KAAK6d,qBAAlC,EAAyD;AACrD,WAAK9P,gBAAL,GAAwB,KAAK8P,qBAAL,CAA2BvQ,KAA3B,EAAxB;AACA,WAAKxT,kBAAL,GAA0B,KAAKF,uBAA/B;AACA,WAAKoH,WAAL,GAAmB,KAAKhB,gBAAL,CAAsBsN,KAAtB,EAAnB;AACA,WAAKgR,kBAAL,GAA0B,KAA1B;AACH,KALD,MAMK;AACD,WAAKvQ,gBAAL,GAAwB,KAAK5R,iBAAL,CAAuBmR,KAAvB,EAAxB;AACA,WAAKxT,kBAAL,GAA0B,KAAKH,qBAA/B;AACA,WAAKqH,WAAL,GAAmB,KAAKjF,cAAL,CAAoBuR,KAApB,EAAnB;AACA,WAAKgR,kBAAL,GAA0B,IAA1B,CAJC,CAKD;AACA;AACA;;AACA,WAAKE,4BAAL;AACH;;AACD,SAAKC,yBAAL;AACA,SAAK9gB,oBAAL,GAA4B,KAAKqD,WAAL,CAAiBma,MAAjB,CAAwB,UAAU5W,GAAV,EAAe;AAAE,aAAOA,GAAG,CAACpE,SAAJ,GAAgBue,UAAvB;AAAoC,KAA7E,CAA5B;AACA,SAAK5J,oBAAL;AACA,SAAK6J,uBAAL;AACA,SAAKC,qBAAL;AACA,SAAK7a,aAAL,GAAqB,KAAKkZ,wBAAL,CAA8B,KAAKjc,WAAnC,CAArB;AACA,QAAIxB,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgB4hB,0BADd;AAER1hB,MAAAA,GAAG,EAAE,KAAKC,OAFF;AAGRC,MAAAA,SAAS,EAAE,KAAKA;AAHR,KAAZ;AAKA,SAAKC,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GAhCD;;AAiCA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2ByjB,4BAA3B,GAA0D,YAAY;AAClE,QAAInd,KAAK,GAAG,IAAZ;;AACA,QAAI5H,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkB,KAAK4L,gBAAvB,CAAJ,EAA8C;AAC1C;AACH,KAJiE,CAKlE;AACA;;;AACA,QAAIO,WAAW,GAAG,IAAlB;AACA,SAAK9d,WAAL,CAAiBf,OAAjB,CAAyB,UAAUsE,GAAV,EAAe;AACpC,UAAIlD,KAAK,CAACkd,gBAAN,CAAuB9c,OAAvB,CAA+B8C,GAA/B,KAAuC,CAA3C,EAA8C;AAC1Cua,QAAAA,WAAW,GAAG,KAAd;AACH;AACJ,KAJD;;AAKA,QAAIA,WAAJ,EAAiB;AACb;AACH,KAfiE,CAgBlE;AACA;;;AACA,QAAIC,cAAc,GAAG,KAAKR,gBAAL,CAAsBpD,MAAtB,CAA6B,UAAU5W,GAAV,EAAe;AAAE,aAAOlD,KAAK,CAACL,WAAN,CAAkBS,OAAlB,CAA0B8C,GAA1B,KAAkC,CAAzC;AAA6C,KAA3F,CAArB;AACA,QAAIya,cAAc,GAAG,KAAKhe,WAAL,CAAiBma,MAAjB,CAAwB,UAAU5W,GAAV,EAAe;AAAE,aAAOwa,cAAc,CAACtd,OAAf,CAAuB8C,GAAvB,IAA8B,CAArC;AAAyC,KAAlF,CAArB,CAnBkE,CAoBlE;;AACA,QAAI0a,cAAc,GAAGF,cAAc,CAACzR,KAAf,EAArB;AACA0R,IAAAA,cAAc,CAAC/e,OAAf,CAAuB,UAAUif,MAAV,EAAkB;AACrC,UAAIC,MAAM,GAAGD,MAAM,CAACE,iBAAP,EAAb,CADqC,CAErC;;AACA,UAAI,CAACD,MAAL,EAAa;AACTF,QAAAA,cAAc,CAACxgB,IAAf,CAAoBygB,MAApB;AACA;AACH,OANoC,CAOrC;AACA;;;AACA,UAAIG,QAAQ,GAAG,EAAf;;AACA,aAAO,CAACA,QAAQ,CAACloB,MAAV,IAAoBgoB,MAA3B,EAAmC;AAC/B,YAAIG,QAAQ,GAAGH,MAAM,CAAC/Q,cAAP,EAAf;AACAkR,QAAAA,QAAQ,CAACrf,OAAT,CAAiB,UAAUsf,OAAV,EAAmB;AAChC,cAAIC,sBAAsB,GAAGP,cAAc,CAACxd,OAAf,CAAuB8d,OAAvB,KAAmC,CAAhE;AACA,cAAIE,eAAe,GAAGJ,QAAQ,CAAC5d,OAAT,CAAiB8d,OAAjB,IAA4B,CAAlD;;AACA,cAAIC,sBAAsB,IAAIC,eAA9B,EAA+C;AAC3CJ,YAAAA,QAAQ,CAAC5gB,IAAT,CAAc8gB,OAAd;AACH;AACJ,SAND;AAOAJ,QAAAA,MAAM,GAAGA,MAAM,CAACC,iBAAP,EAAT;AACH,OApBoC,CAqBrC;;;AACA,UAAI,CAACC,QAAQ,CAACloB,MAAd,EAAsB;AAClB8nB,QAAAA,cAAc,CAACxgB,IAAf,CAAoBygB,MAApB;AACA;AACH,OAzBoC,CA0BrC;;;AACA,UAAI9H,OAAO,GAAGiI,QAAQ,CAACzgB,GAAT,CAAa,UAAU2F,GAAV,EAAe;AAAE,eAAO0a,cAAc,CAACxd,OAAf,CAAuB8C,GAAvB,CAAP;AAAqC,OAAnE,CAAd;AACA,UAAImb,SAAS,GAAGhb,IAAI,CAAC6J,GAAL,CAASC,KAAT,CAAe9J,IAAf,EAAqB0S,OAArB,CAAhB;;AACA3d,MAAAA,OAAO,CAAC8E,CAAR,CAAUohB,eAAV,CAA0BV,cAA1B,EAA0CC,MAA1C,EAAkDQ,SAAS,GAAG,CAA9D;AACH,KA9BD;AA+BA,SAAK1e,WAAL,GAAmBie,cAAnB;AACH,GAtDD;;AAuDAvlB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6kB,4BAA3B,GAA0D,YAAY;AAClE,WAAO,KAAKjmB,qBAAL,GAA6B,CAApC;AACH,GAFD,CAplE8C,CAulE9C;AACA;AACA;AACA;AACA;;;AACAD,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4jB,uBAA3B,GAAqD,YAAY;AAC7D,QAAI,KAAKxM,gBAAT,EAA2B;AACvB,WAAKjC,qBAAL,GAA6B,KAAKnU,cAAL,CAAoBmH,MAApB,CAA2B,KAAKiP,gBAAhC,CAA7B;AACH,KAFD,MAGK;AACD,WAAKjC,qBAAL,GAA6B,KAAKnU,cAAlC;AACH;AACJ,GAPD;;AAQArC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B+Z,oBAA3B,GAAkD,YAAY;AAC1D,QAAI+K,MAAM,GAAG,KAAK7e,WAAL,CAAiBma,MAAjB,CAAwB,UAAUlkB,CAAV,EAAa;AAAE,aAAOA,CAAC,CAACkJ,SAAF,GAAcwN,YAArB;AAAoC,KAA3E,CAAb;AACA,QAAImS,QAAQ,GAAG,KAAK9e,WAAL,CAAiBma,MAAjB,CAAwB,UAAUlkB,CAAV,EAAa;AAAE,aAAO,CAACA,CAAC,CAACkJ,SAAF,GAAcwN,YAAtB;AAAqC,KAA5E,CAAf;AACA,SAAK3M,WAAL,GAAmB6e,MAAM,CAAC3c,MAAP,CAAc4c,QAAd,CAAnB;AACH,GAJD;;AAKApmB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0jB,yBAA3B,GAAuD,YAAY;AAC/D;AACA,SAAKsB,8BAAL;;AACA,QAAItmB,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkB,KAAKR,gBAAvB,CAAJ,EAA8C;AAC1C;AACH;;AACD,SAAKnR,WAAL,GAAmB,KAAKmR,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBjP,MAAtB,CAA6B,KAAKlC,WAAlC,CAAxB,GAAyE,KAAKA,WAAjG;AACA,QAAIgf,mBAAmB,GAAG,KAAK/jB,aAAL,CAAmBgkB,mBAAnB,CAAuC,KAAK9N,gBAA5C,EAA8D,KAAKpE,gBAAnE,CAA1B;AACA,SAAKA,gBAAL,GAAwBiS,mBAAmB,CAAC9c,MAApB,CAA2B,KAAK6K,gBAAhC,CAAxB;AACH,GATD,CAzmE8C,CAmnE9C;AACA;AACA;AACA;AACA;;;AACArU,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B6jB,qBAA3B,GAAmD,YAAY;AAC3D,SAAK7b,uBAAL,GAA+B,EAA/B;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,yBAAL,GAAiC,EAAjC;AACA,SAAKid,uBAAL,GAA+B,EAA/B;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,yBAAL,GAAiC,EAAjC;AACA,SAAKrmB,oBAAL,GAA4B,EAA5B;AACA,SAAKC,qBAAL,GAA6B,EAA7B;AACA,SAAKC,sBAAL,GAA8B,EAA9B;AACA,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,0BAAL,GAAkC,EAAlC;AACH,GAZD;;AAaAT,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0hB,+BAA3B,GAA6D,UAAU/gB,MAAV,EAAkB;AAC3E,SAAK2kB,wCAAL;AACA,SAAKC,+BAAL,CAAqC5kB,MAArC;AACA,SAAKqD,iBAAL;AACA,SAAKkN,gBAAL,GAJ2E,CAK3E;;AACA,QAAIzM,KAAK,GAAG;AACRxC,MAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBsjB,+BADd;AAERpjB,MAAAA,GAAG,EAAE,KAAKC,OAFF;AAGRC,MAAAA,SAAS,EAAE,KAAKA;AAHR,KAAZ;AAKA,SAAKC,YAAL,CAAkBC,aAAlB,CAAgCiC,KAAhC;AACH,GAZD;;AAaA9F,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BulB,+BAA3B,GAA6D,UAAU5kB,MAAV,EAAkB;AAC3E,SAAK8kB,qBAAL,CAA2B,KAAKzd,uBAAhC,EAAyD,KAAKhJ,oBAA9D;AACA,SAAKymB,qBAAL,CAA2B,KAAKvd,yBAAhC,EAA2D,KAAKhJ,sBAAhE;AACA,SAAKumB,qBAAL,CAA2B,KAAKxd,wBAAhC,EAA0D,KAAKhJ,qBAA/D;AACA,SAAKymB,wBAAL;AACA,SAAKzU,aAAL,CAAmBtQ,MAAnB;AACH,GAND;;AAOAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0lB,wBAA3B,GAAsD,YAAY;AAC9D,QAAI,KAAKxlB,kBAAL,CAAwB6C,WAAxB,EAAJ,EAA2C;AACvC,WAAK5D,mBAAL,GAA2B,KAAKF,qBAAL,CACtBkJ,MADsB,CACf,KAAKjJ,sBADU,EAEtBiJ,MAFsB,CAEf,KAAKnJ,oBAFU,CAA3B;AAGH,KAJD,MAKK;AACD,WAAKG,mBAAL,GAA2B,KAAKH,oBAAL,CACtBmJ,MADsB,CACf,KAAKjJ,sBADU,EAEtBiJ,MAFsB,CAEf,KAAKlJ,qBAFU,CAA3B;AAGH;AACJ,GAXD,CAzpE8C,CAqqE9C;;;AACAN,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BiR,aAA3B,GAA2C,UAAUtQ,MAAV,EAAkB;AACzD,SAAKglB,sBAAL,CAA4BhlB,MAA5B;AACA,SAAKilB,qBAAL;AACH,GAHD;;AAIAjnB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B2lB,sBAA3B,GAAoD,UAAUhlB,MAAV,EAAkB;AAClE,QAAI2F,KAAK,GAAG,IAAZ,CADkE,CAElE;;;AACA,QAAIuf,UAAU,GAAG,KAAK7kB,cAAL,CAAoBuR,KAApB,CAA0B,CAA1B,CAAjB,CAHkE,CAIlE;;AACA,QAAIuT,QAAQ,GAAG,KAAK5lB,kBAAL,CAAwB6C,WAAxB,EAAf;AACA,KAAC,KAAK/D,oBAAN,EAA4B,KAAKC,qBAAjC,EAAwD,KAAKC,sBAA7D,EAAqFgG,OAArF,CAA6F,UAAUiC,OAAV,EAAmB;AAC5G,UAAI2e,QAAJ,EAAc;AACV;AACA,YAAIC,MAAM,GAAGzf,KAAK,CAAC2E,oBAAN,CAA2B9D,OAA3B,CAAb;;AACAA,QAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAU7B,MAAV,EAAkB;AAC9B0iB,UAAAA,MAAM,IAAI1iB,MAAM,CAACsH,cAAP,EAAV;AACAtH,UAAAA,MAAM,CAAC2iB,OAAP,CAAeD,MAAf,EAAuBplB,MAAvB;AACH,SAHD;AAIH,OAPD,MAQK;AACD;AACA,YAAIslB,MAAM,GAAG,CAAb;AACA9e,QAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAU7B,MAAV,EAAkB;AAC9BA,UAAAA,MAAM,CAAC2iB,OAAP,CAAeC,MAAf,EAAuBtlB,MAAvB;AACAslB,UAAAA,MAAM,IAAI5iB,MAAM,CAACsH,cAAP,EAAV;AACH,SAHD;AAIH;;AACDjM,MAAAA,OAAO,CAAC8E,CAAR,CAAU0iB,kBAAV,CAA6BL,UAA7B,EAAyC1e,OAAzC;AACH,KAlBD,EANkE,CAyBlE;AACA;AACA;;AACA0e,IAAAA,UAAU,CAAC3gB,OAAX,CAAmB,UAAU7B,MAAV,EAAkB;AACjCA,MAAAA,MAAM,CAAC2iB,OAAP,CAAe,IAAf,EAAqBrlB,MAArB;AACH,KAFD;AAGH,GA/BD;;AAgCAhC,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B4lB,qBAA3B,GAAmD,YAAY;AAC3D;AACA,KAAC,KAAK5d,uBAAN,EAA+B,KAAKC,wBAApC,EAA8D,KAAKC,yBAAnE,EAA8FhD,OAA9F,CAAsG,UAAUiC,OAAV,EAAmB;AACrHA,MAAAA,OAAO,CAACjC,OAAR,CAAgB,UAAU7B,MAAV,EAAkB;AAC9B,YAAIA,MAAM,YAAY/F,aAAa,CAAC4hB,WAApC,EAAiD;AAC7C,cAAIjM,WAAW,GAAG5P,MAAlB;AACA4P,UAAAA,WAAW,CAACkT,SAAZ;AACH;AACJ,OALD;AAMH,KAPD;AAQH,GAVD;;AAWAxnB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BylB,qBAA3B,GAAmD,UAAUW,mBAAV,EAA+Bjd,gBAA/B,EAAiD;AAChGA,IAAAA,gBAAgB,CAAC/M,MAAjB,GAA0B,CAA1B;AACA,SAAK0W,WAAL,CAAiBuT,mCAAjB,CAAqDD,mBAArD,EAA0E,UAAUze,KAAV,EAAiB;AACvF,UAAIA,KAAK,YAAYnK,QAAQ,CAACoK,MAA9B,EAAsC;AAClCuB,QAAAA,gBAAgB,CAACzF,IAAjB,CAAsBiE,KAAtB;AACH;AACJ,KAJD;AAKH,GAPD;;AAQAhJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsmB,mCAA3B,GAAiE,YAAY;AACzE,QAAI,KAAKlmB,4BAAT,EAAuC;AACnC;AACA,WAAKf,gCAAL,GAAwC,KAAKH,sBAA7C;AACH,KAHD,MAIK;AACD;AACA,WAAKG,gCAAL,GAAwC,KAAKknB,8BAAL,EAAxC;AACH;;AACD,SAAKnnB,0BAAL,GAAkC,KAAKC,gCAAL,CAC7B8I,MAD6B,CACtB,KAAKnJ,oBADiB,EAE7BmJ,MAF6B,CAEtB,KAAKlJ,qBAFiB,CAAlC,CATyE,CAYzE;AACA;;AACA,QAAIsE,MAAM,GAAG,EAAb;AACA,SAAKnE,0BAAL,CAAgC8F,OAAhC,CAAwC,UAAUsE,GAAV,EAAe;AACnDjG,MAAAA,MAAM,CAACiG,GAAG,CAAC1F,KAAJ,EAAD,CAAN,GAAsB,IAAtB;AACH,KAFD;AAGA,WAAOP,MAAP;AACH,GAnBD;;AAoBA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwmB,wBAA3B,GAAsD,UAAUvkB,IAAV,EAAgBwkB,IAAhB,EAAsB;AACxE,QAAIljB,MAAJ;;AACA,YAAQtB,IAAR;AACI,WAAKzE,QAAQ,CAACoK,MAAT,CAAgBc,WAArB;AACInF,QAAAA,MAAM,GAAG,KAAK4hB,uBAAL,CAA6BsB,IAA7B,CAAT;AACA;;AACJ,WAAKjpB,QAAQ,CAACoK,MAAT,CAAgBe,YAArB;AACIpF,QAAAA,MAAM,GAAG,KAAK6hB,wBAAL,CAA8BqB,IAA9B,CAAT;AACA;;AACJ;AACIljB,QAAAA,MAAM,GAAG,KAAK8hB,yBAAL,CAA+BoB,IAA/B,CAAT;AACA;AATR;;AAWA,QAAI/nB,OAAO,CAAC8E,CAAR,CAAUoU,OAAV,CAAkBrU,MAAlB,CAAJ,EAA+B;AAC3BA,MAAAA,MAAM,GAAG,EAAT;AACH;;AACD,WAAOA,MAAP;AACH,GAjBD;;AAkBA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2B0mB,4BAA3B,GAA0D,UAAUC,aAAV,EAAyB;AAC/E;AACA;AACA,SAAKxB,uBAAL,GAA+B,EAA/B;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,yBAAL,GAAiC,EAAjC;AACAuB,IAAAA,SAAS,CAAC,KAAK5e,uBAAN,EAA+B,KAAKmd,uBAApC,EAA6D,CAA7D,CAAT;AACAyB,IAAAA,SAAS,CAAC,KAAK3e,wBAAN,EAAgC,KAAKmd,wBAArC,EAA+D,CAA/D,CAAT;AACAwB,IAAAA,SAAS,CAAC,KAAK1e,yBAAN,EAAiC,KAAKmd,yBAAtC,EAAiE,CAAjE,CAAT;;AACA,aAASuB,SAAT,CAAmBtD,QAAnB,EAA6B/f,MAA7B,EAAqCkjB,IAArC,EAA2C;AACvC,UAAII,WAAW,GAAG,KAAlB;;AACA,WAAK,IAAIlqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2mB,QAAQ,CAAClnB,MAA7B,EAAqCO,CAAC,EAAtC,EAA0C;AACtC;AACA,YAAIgL,KAAK,GAAG2b,QAAQ,CAAC3mB,CAAD,CAApB;AACA,YAAImqB,WAAW,GAAG,KAAK,CAAvB;;AACA,YAAInf,KAAK,YAAYnK,QAAQ,CAACoK,MAA9B,EAAsC;AAClC;AACAkf,UAAAA,WAAW,GAAGH,aAAa,CAAChf,KAAK,CAAC7D,KAAN,EAAD,CAAb,KAAiC,IAA/C;AACH,SAHD,MAIK;AACD;AACA,cAAImP,WAAW,GAAGtL,KAAlB;AACAmf,UAAAA,WAAW,GAAGF,SAAS,CAAC3T,WAAW,CAAC8T,oBAAZ,EAAD,EAAqCxjB,MAArC,EAA6CkjB,IAAI,GAAG,CAApD,CAAvB;AACH;;AACD,YAAIK,WAAJ,EAAiB;AACbD,UAAAA,WAAW,GAAG,IAAd;;AACA,cAAI,CAACtjB,MAAM,CAACkjB,IAAD,CAAX,EAAmB;AACfljB,YAAAA,MAAM,CAACkjB,IAAD,CAAN,GAAe,EAAf;AACH;;AACDljB,UAAAA,MAAM,CAACkjB,IAAD,CAAN,CAAa/iB,IAAb,CAAkBiE,KAAlB;AACH;AACJ;;AACD,aAAOkf,WAAP;AACH;AACJ,GAlCD;;AAmCAloB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgE,iBAA3B,GAA+C,YAAY;AACvD,QAAI2iB,aAAa,GAAG,KAAKL,mCAAL,EAApB;AACA,SAAKI,4BAAL,CAAkCC,aAAlC;AACH,GAHD;;AAIAhoB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BumB,8BAA3B,GAA4D,YAAY;AACpE,WAAO7nB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiB,KAAKlhB,sBAAtB,EAA8C,KAAKqL,kBAAL,CAAwBC,IAAxB,CAA6B,IAA7B,CAA9C,CAAP;AACH,GAFD,CA1yE8C,CA6yE9C;;;AACA7L,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BgnB,gBAA3B,GAA8C,UAAUC,SAAV,EAAqBtmB,MAArB,EAA6B;AACvE,QAAI2F,KAAK,GAAG,IAAZ;;AACA,QAAI3F,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB,KAF6B,CAGvE;;;AACA,QAAIxB,mBAAmB,GAAG,KAAKoI,sBAAL,EAA1B;;AACA,QAAI0f,SAAS,IAAI,CAAb,IAAkB9nB,mBAAmB,CAAC/C,MAApB,KAA+B,CAArD,EAAwD;AACpD;AACH;;AACD,QAAI8qB,eAAe,GAAGxoB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiBjhB,mBAAjB,EAAsC,UAAUkE,MAAV,EAAkB;AAC1E,aAAOA,MAAM,CAAC+B,SAAP,GAAmB+hB,iBAAnB,KAAyC,IAAhD;AACH,KAFqB,CAAtB;;AAGA,QAAIC,YAAY,GAAG1oB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiBjhB,mBAAjB,EAAsC,UAAUkE,MAAV,EAAkB;AACvE,aAAOA,MAAM,CAAC+B,SAAP,GAAmB+hB,iBAAnB,KAAyC,IAAhD;AACH,KAFkB,CAAnB,CAXuE,CAcvE;;;AACA,QAAIE,kBAAkB,GAAGD,YAAY,CAAC7U,KAAb,CAAmB,CAAnB,CAAzB;AACA,QAAI+U,gBAAgB,GAAG,KAAvB;;AACA,WAAO,CAACA,gBAAR,EAA0B;AACtBA,MAAAA,gBAAgB,GAAG,IAAnB;AACA,UAAIC,eAAe,GAAGN,SAAS,GAAG,KAAKhc,oBAAL,CAA0Bic,eAA1B,CAAlC;;AACA,UAAIK,eAAe,IAAI,CAAvB,EAA0B;AACtB;AACAH,QAAAA,YAAY,CAACliB,OAAb,CAAqB,UAAU7B,MAAV,EAAkB;AACnCA,UAAAA,MAAM,CAACmkB,UAAP,CAAkB7mB,MAAlB;AACH,SAFD;AAGH,OALD,MAMK;AACD,YAAI8mB,KAAK,GAAGF,eAAe,GAAG,KAAKtc,oBAAL,CAA0Bmc,YAA1B,CAA9B,CADC,CAED;AACA;;AACA,YAAIM,gBAAgB,GAAGH,eAAvB,CAJC,CAKD;;AACA,aAAK,IAAI5qB,CAAC,GAAGyqB,YAAY,CAAChrB,MAAb,GAAsB,CAAnC,EAAsCO,CAAC,IAAI,CAA3C,EAA8CA,CAAC,EAA/C,EAAmD;AAC/C,cAAI0G,MAAM,GAAG+jB,YAAY,CAACzqB,CAAD,CAAzB;AACA,cAAImK,QAAQ,GAAG6C,IAAI,CAACmH,KAAL,CAAWzN,MAAM,CAACsH,cAAP,KAA0B8c,KAArC,CAAf;;AACA,cAAI3gB,QAAQ,GAAGzD,MAAM,CAAC2K,WAAP,EAAf,EAAqC;AACjC3K,YAAAA,MAAM,CAACmkB,UAAP,CAAkB7mB,MAAlB;AACAgnB,YAAAA,eAAe,CAACtkB,MAAD,CAAf;AACAikB,YAAAA,gBAAgB,GAAG,KAAnB;AACH,WAJD,MAKK,IAAIjkB,MAAM,CAAC4K,gBAAP,CAAwBnH,QAAxB,CAAJ,EAAuC;AACxCzD,YAAAA,MAAM,CAAC2D,cAAP,CAAsB3D,MAAM,CAAC6K,WAAP,EAAtB,EAA4CvN,MAA5C;AACAgnB,YAAAA,eAAe,CAACtkB,MAAD,CAAf;AACAikB,YAAAA,gBAAgB,GAAG,KAAnB;AACH,WAJI,MAKA;AACD,gBAAIM,SAAS,GAAGjrB,CAAC,KAAK,CAAtB;;AACA,gBAAIirB,SAAJ,EAAe;AACXvkB,cAAAA,MAAM,CAAC2D,cAAP,CAAsB0gB,gBAAtB,EAAwC/mB,MAAxC;AACH,aAFD,MAGK;AACD0C,cAAAA,MAAM,CAAC2D,cAAP,CAAsBF,QAAtB,EAAgCnG,MAAhC;AACH;AACJ;;AACD+mB,UAAAA,gBAAgB,IAAI5gB,QAApB;AACH;AACJ;AACJ;;AACD,SAAKmK,aAAL,CAAmBtQ,MAAnB;AACA,SAAKuQ,gBAAL;AACAmW,IAAAA,kBAAkB,CAACniB,OAAnB,CAA2B,UAAU7B,MAAV,EAAkB;AACzC,UAAIoB,KAAK,GAAG;AACRxC,QAAAA,IAAI,EAAEhE,QAAQ,CAACiE,MAAT,CAAgBgF,oBADd;AAER7D,QAAAA,MAAM,EAAEA,MAFA;AAGR8D,QAAAA,OAAO,EAAE,CAAC9D,MAAD,CAHD;AAIR+D,QAAAA,QAAQ,EAAE,IAJF;AAKRhF,QAAAA,GAAG,EAAEkE,KAAK,CAACjE,OALH;AAMRC,QAAAA,SAAS,EAAEgE,KAAK,CAAChE,SANT;AAOR3B,QAAAA,MAAM,EAAE;AAPA,OAAZ;;AASA2F,MAAAA,KAAK,CAAC/D,YAAN,CAAmBC,aAAnB,CAAiCiC,KAAjC;AACH,KAXD;;AAYA,aAASkjB,eAAT,CAAyBtkB,MAAzB,EAAiC;AAC7B3E,MAAAA,OAAO,CAAC8E,CAAR,CAAUmI,eAAV,CAA0Byb,YAA1B,EAAwC/jB,MAAxC;;AACA6jB,MAAAA,eAAe,CAACxjB,IAAhB,CAAqBL,MAArB;AACH;AACJ,GA5ED;;AA6EA1E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwiB,mBAA3B,GAAiD,UAAUqF,cAAV,EAA0B;AACvE,QAAIC,kBAAkB,GAAGppB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiByH,cAAjB,EAAiC,UAAUxkB,MAAV,EAAkB;AACxE,aAAOA,MAAM,CAAC2S,SAAP,OAAuB,MAA9B;AACH,KAFwB,CAAzB;;AAGA,QAAI+R,mBAAmB,GAAGrpB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiByH,cAAjB,EAAiC,UAAUxkB,MAAV,EAAkB;AACzE,aAAOA,MAAM,CAAC2S,SAAP,OAAuB,OAA9B;AACH,KAFyB,CAA1B;;AAGA,QAAIgS,oBAAoB,GAAGtpB,OAAO,CAAC8E,CAAR,CAAU4c,MAAV,CAAiByH,cAAjB,EAAiC,UAAUxkB,MAAV,EAAkB;AAC1E,aAAOA,MAAM,CAAC2S,SAAP,OAAuB,MAAvB,IAAiC3S,MAAM,CAAC2S,SAAP,OAAuB,OAA/D;AACH,KAF0B,CAA3B;;AAGA,QAAIiS,sBAAsB,GAAG,IAAI9pB,wBAAwB,CAAC+pB,sBAA7B,EAA7B;AACA,SAAKlgB,uBAAL,GAA+B,KAAKmgB,qBAAL,CAA2BC,qBAA3B,CAAiDN,kBAAjD,EAAqE,KAAK9U,gBAA1E,EAA4FiV,sBAA5F,EAAoHzqB,QAAQ,CAACoK,MAAT,CAAgBc,WAApI,EAAiJ,KAAKV,uBAAtJ,CAA/B;AACA,SAAKC,wBAAL,GAAgC,KAAKkgB,qBAAL,CAA2BC,qBAA3B,CAAiDL,mBAAjD,EAAsE,KAAK/U,gBAA3E,EAA6FiV,sBAA7F,EAAqHzqB,QAAQ,CAACoK,MAAT,CAAgBe,YAArI,EAAmJ,KAAKV,wBAAxJ,CAAhC;AACA,SAAKC,yBAAL,GAAiC,KAAKigB,qBAAL,CAA2BC,qBAA3B,CAAiDJ,oBAAjD,EAAuE,KAAKhV,gBAA5E,EAA8FiV,sBAA9F,EAAsH,IAAtH,EAA4H,KAAK/f,yBAAjI,CAAjC;AACH,GAdD;;AAeAvJ,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BslB,wCAA3B,GAAsE,YAAY;AAC9E,QAAInG,eAAe,GAAG,KAAKpX,2BAAL,EAAtB;AACA,SAAK+K,WAAL,CAAiBuM,6BAAjB,CAA+CF,eAA/C,EAAgE,UAAUxX,KAAV,EAAiB;AAC7E,UAAIA,KAAK,YAAYrK,aAAa,CAAC4hB,WAAnC,EAAgD;AAC5C,YAAIjM,WAAW,GAAGtL,KAAlB;AACAsL,QAAAA,WAAW,CAACoV,yBAAZ;AACH;AACJ,KALD;AAMH,GARD;;AASA1pB,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BsoB,mBAA3B,GAAiD,YAAY;AACzD,WAAO,KAAKlR,gBAAZ;AACH,GAFD;;AAGAzY,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BglB,8BAA3B,GAA4D,YAAY;AACpE,QAAI,CAAC,KAAKtlB,sBAAV,EAAkC;AAC9B;AACH;;AACD,SAAKA,sBAAL,GAA8B,KAA9B;AACA,QAAI6oB,iBAAiB,GAAG,KAAKroB,kBAAL,CAAwBsoB,mBAAxB,CAA4C,KAAK7oB,SAAjD,CAAxB,CALoE,CAMpE;AACA;AACA;;AACA,QAAI8oB,uBAAuB,GAAG,KAAKvoB,kBAAL,CAAwBwoB,yBAAxB,MAAuD,CAAC,KAAK/oB,SAA3F;AACA,QAAIgpB,gBAAgB,GAAG,KAAKzoB,kBAAL,CAAwB0oB,kBAAxB,EAAvB;AACA,QAAIC,cAAc,GAAG,KAAKvpB,eAAL,CAAqBlD,MAArB,GAA8B,CAA9B,IAAmC,KAAKmE,aAA7D;AACA,QAAIuoB,eAAe,GAAGD,cAAc,IAAI,CAACJ,uBAAnB,IAA8C,CAACF,iBAA/C,IAAoE,CAACI,gBAA3F;;AACA,QAAIG,eAAJ,EAAqB;AACjB,UAAIC,gBAAgB,GAAG,KAAKC,mBAAL,CAAyBC,sBAAzB,CAAgD,KAAK3pB,eAArD,CAAvB;AACA,UAAI4pB,iBAAiB,GAAG,CAAC,KAAKC,aAAL,CAAmBJ,gBAAnB,EAAqC,KAAK3R,gBAA1C,CAAzB;;AACA,UAAI8R,iBAAJ,EAAuB;AACnB,aAAK9R,gBAAL,GAAwB2R,gBAAxB;AACH;AACJ,KAND,MAOK;AACD,WAAK3R,gBAAL,GAAwB,IAAxB;AACH;AACJ,GAvBD;;AAwBAzY,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BmpB,aAA3B,GAA2C,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AAC/D,QAAIC,WAAW,GAAG,CAACF,KAAD,IAAU,CAACC,KAA7B;;AACA,QAAIC,WAAJ,EAAiB;AACb,aAAO,IAAP;AACH;;AACD,QAAIC,qBAAqB,GAAG,CAACH,KAAD,IAAU,CAACC,KAAvC;;AACA,QAAIE,qBAAJ,EAA2B;AACvB,aAAO,KAAP;AACH;;AACD,QAAIH,KAAK,CAAChtB,MAAN,KAAiBitB,KAAK,CAACjtB,MAA3B,EAAmC;AAC/B,aAAO,KAAP;AACH;;AACD,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGysB,KAAK,CAAChtB,MAA1B,EAAkCO,CAAC,EAAnC,EAAuC;AACnC,UAAIgd,IAAI,GAAGyP,KAAK,CAACzsB,CAAD,CAAhB;AACA,UAAIid,IAAI,GAAGyP,KAAK,CAAC1sB,CAAD,CAAhB;;AACA,UAAIgd,IAAI,CAAClC,QAAL,OAAoBmC,IAAI,CAACnC,QAAL,EAAxB,EAAyC;AACrC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GApBD;;AAqBA9Y,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BiL,oBAA3B,GAAkD,UAAU4R,UAAV,EAAsB;AACpE,QAAItZ,MAAM,GAAG,CAAb;;AACA,SAAK,IAAI5G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkgB,UAAU,CAACzgB,MAA/B,EAAuCO,CAAC,EAAxC,EAA4C;AACxC4G,MAAAA,MAAM,IAAIsZ,UAAU,CAAClgB,CAAD,CAAV,CAAcgO,cAAd,EAAV;AACH;;AACD,WAAOpH,MAAP;AACH,GAND;;AAOA5E,EAAAA,gBAAgB,CAACqB,SAAjB,CAA2BwpB,mBAA3B,GAAiD,YAAY;AACzD,WAAO,KAAKxW,gBAAZ;AACH,GAFD;;AAGAnX,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,oBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBY,oBAAoB,CAACisB,kBAArC,CAFH,CAAD,EAGP/qB,gBAAgB,CAACqB,SAHV,EAGqB,oBAHrB,EAG2C,KAAK,CAHhD,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,mBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBa,mBAAmB,CAACisB,iBAApC,CAFH,CAAD,EAGPhrB,gBAAgB,CAACqB,SAHV,EAGqB,mBAHrB,EAG0C,KAAK,CAH/C,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,eAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBc,eAAe,CAACisB,aAAhC,CAFH,CAAD,EAGPjrB,gBAAgB,CAACqB,SAHV,EAGqB,eAHrB,EAGsC,KAAK,CAH3C,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,uBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBe,uBAAuB,CAACisB,qBAAxC,CAFH,CAAD,EAGPlrB,gBAAgB,CAACqB,SAHV,EAGqB,uBAHrB,EAG8C,KAAK,CAHnD,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,qBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBgB,qBAAqB,CAACisB,mBAAtC,CAFH,CAAD,EAGPnrB,gBAAgB,CAACqB,SAHV,EAGqB,qBAHrB,EAG4C,KAAK,CAHjD,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,cAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBiB,cAAc,CAACisB,YAA/B,CAFH,CAAD,EAGPprB,gBAAgB,CAACqB,SAHV,EAGqB,cAHrB,EAGqC,KAAK,CAH1C,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,aAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBkB,aAAa,CAACisB,WAA9B,CAFH,CAAD,EAGPrrB,gBAAgB,CAACqB,SAHV,EAGqB,aAHrB,EAGoC,KAAK,CAHzC,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,SAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBuB,SAAS,CAAC6rB,OAA1B,CAFH,CAAD,EAGPtrB,gBAAgB,CAACqB,SAHV,EAGqB,SAHrB,EAGgC,KAAK,CAHrC,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,wBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgBwB,wBAAwB,CAAC6rB,sBAAzC,CAFH,CAAD,EAGPvrB,gBAAgB,CAACqB,SAHV,EAGqB,wBAHrB,EAG+C,KAAK,CAHpD,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,qBAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgByB,qBAAqB,CAAC6rB,mBAAtC,CAFH,CAAD,EAGPxrB,gBAAgB,CAACqB,SAHV,EAGqB,qBAHrB,EAG4C,KAAK,CAHjD,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACgsB,QAAV,CAAmB,gBAAnB,CADO,EAEPvtB,UAAU,CAAC,aAAD,EAAgBP,MAAhB,CAFH,CAAD,EAGPqC,gBAAgB,CAACqB,SAHV,EAGqB,gBAHrB,EAGuC,KAAK,CAH5C,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACgsB,QAAV,CAAmB,YAAnB,CADO,EAEPvtB,UAAU,CAAC,aAAD,EAAgB0B,YAAY,CAAC8rB,UAA7B,CAFH,CAAD,EAGP1rB,gBAAgB,CAACqB,SAHV,EAGqB,YAHrB,EAGmC,KAAK,CAHxC,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,WAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgB4B,WAAW,CAAC6rB,SAA5B,CAFH,CAAD,EAGP3rB,gBAAgB,CAACqB,SAHV,EAGqB,WAHrB,EAGkC,KAAK,CAHvC,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACqrB,SAAV,CAAoB,SAApB,CADO,EAEP5sB,UAAU,CAAC,aAAD,EAAgB2B,SAAS,CAAC+rB,OAA1B,CAFH,CAAD,EAGP5rB,gBAAgB,CAACqB,SAHV,EAGqB,SAHrB,EAGgC,KAAK,CAHrC,CAAV;;AAIAnE,EAAAA,UAAU,CAAC,CACPuC,SAAS,CAACosB,aADH,EAEP3tB,UAAU,CAAC,aAAD,EAAgB4tB,QAAhB,CAFH,EAGP5tB,UAAU,CAAC,mBAAD,EAAsB,EAAtB,CAHH,EAIPA,UAAU,CAAC,mBAAD,EAAsB,KAAK,CAA3B,CAJH,CAAD,EAKP8B,gBAAgB,CAACqB,SALV,EAKqB,MALrB,EAK6B,IAL7B,CAAV;;AAMAnE,EAAAA,UAAU,CAAC,CACPoB,OAAO,CAAC,CAAD,EAAImB,SAAS,CAACssB,SAAV,CAAoB,eAApB,CAAJ,CADA,EAEP7tB,UAAU,CAAC,aAAD,EAAgB4tB,QAAhB,CAFH,EAGP5tB,UAAU,CAAC,mBAAD,EAAsB,CAACmB,QAAQ,CAAC2sB,aAAV,CAAtB,CAHH,EAIP9tB,UAAU,CAAC,mBAAD,EAAsB,KAAK,CAA3B,CAJH,CAAD,EAKP8B,gBAAgB,CAACqB,SALV,EAKqB,UALrB,EAKiC,IALjC,CAAV;;AAMArB,EAAAA,gBAAgB,GAAG9C,UAAU,CAAC,CAC1BuC,SAAS,CAACwsB,IAAV,CAAe,kBAAf,CAD0B,CAAD,EAE1BjsB,gBAF0B,CAA7B;AAGA,SAAOA,gBAAP;AACH,CArhFqC,EAAtC;;AAshFAvB,OAAO,CAACuB,gBAAR,GAA2BA,gBAA3B","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar columnGroup_1 = require(\"../entities/columnGroup\");\nvar column_1 = require(\"../entities/column\");\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar expressionService_1 = require(\"../valueService/expressionService\");\nvar columnFactory_1 = require(\"./columnFactory\");\nvar displayedGroupCreator_1 = require(\"./displayedGroupCreator\");\nvar autoWidthCalculator_1 = require(\"../rendering/autoWidthCalculator\");\nvar eventService_1 = require(\"../eventService\");\nvar columnUtils_1 = require(\"./columnUtils\");\nvar logger_1 = require(\"../logger\");\nvar events_1 = require(\"../events\");\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\nvar groupInstanceIdCreator_1 = require(\"./groupInstanceIdCreator\");\nvar context_1 = require(\"../context/context\");\nvar columnAnimationService_1 = require(\"../rendering/columnAnimationService\");\nvar autoGroupColService_1 = require(\"./autoGroupColService\");\nvar valueCache_1 = require(\"../valueService/valueCache\");\nvar gridApi_1 = require(\"../gridApi\");\nvar columnApi_1 = require(\"./columnApi\");\nvar utils_1 = require(\"../utils\");\nvar ColumnController = /** @class */ (function () {\n    function ColumnController() {\n        // header row count, based on user provided columns\n        this.primaryHeaderRowCount = 0;\n        this.secondaryHeaderRowCount = 0;\n        this.secondaryColumnsPresent = false;\n        // header row count, either above, or based on pivoting if we are pivoting\n        this.gridHeaderRowCount = 0;\n        // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above\n        // displayed trees, however it also takes into account if the groups are open or not.\n        this.displayedLeftColumns = [];\n        this.displayedRightColumns = [];\n        this.displayedCenterColumns = [];\n        // all three lists above combined\n        this.allDisplayedColumns = [];\n        // same as above, except trimmed down to only columns within the viewport\n        this.allDisplayedVirtualColumns = [];\n        this.allDisplayedCenterVirtualColumns = [];\n        this.rowGroupColumns = [];\n        this.valueColumns = [];\n        this.pivotColumns = [];\n        this.ready = false;\n        this.autoGroupsNeedBuilding = false;\n        this.pivotMode = false;\n        this.bodyWidth = 0;\n        this.leftWidth = 0;\n        this.rightWidth = 0;\n        this.bodyWidthDirty = true;\n    }\n    ColumnController.prototype.init = function () {\n        var pivotMode = this.gridOptionsWrapper.isPivotMode();\n        this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n        if (this.isPivotSettingAllowed(pivotMode)) {\n            this.pivotMode = pivotMode;\n        }\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n    };\n    ColumnController.prototype.setColumnDefs = function (columnDefs, source) {\n        if (source === void 0) { source = \"api\"; }\n        var colsPreviouslyExisted = !!this.columnDefs;\n        this.columnDefs = columnDefs;\n        // always invalidate cache on changing columns, as the column id's for the new columns\n        // could overlap with the old id's, so the cache would return old values for new columns.\n        this.valueCache.expire();\n        // NOTE ==================\n        // we should be destroying the existing columns and groups if they exist, for example, the original column\n        // group adds a listener to the columns, it should be also removing the listeners\n        this.autoGroupsNeedBuilding = true;\n        var oldPrimaryColumns = this.primaryColumns;\n        var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryColumns);\n        this.primaryColumnTree = balancedTreeResult.columnTree;\n        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n        this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        this.extractRowGroupColumns(source, oldPrimaryColumns);\n        this.extractPivotColumns(source, oldPrimaryColumns);\n        this.createValueColumns(source, oldPrimaryColumns);\n        this.ready = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        this.checkDisplayedVirtualColumns();\n        if (this.gridOptionsWrapper.isDeltaColumnMode() && colsPreviouslyExisted) {\n            this.resetColumnState(true, source);\n        }\n        var eventEverythingChanged = {\n            type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(eventEverythingChanged);\n        var newColumnsLoadedEvent = {\n            type: events_1.Events.EVENT_NEW_COLUMNS_LOADED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(newColumnsLoadedEvent);\n    };\n    ColumnController.prototype.isAutoRowHeightActive = function () {\n        return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n    };\n    ColumnController.prototype.getAllAutoRowHeightCols = function () {\n        return this.autoRowHeightColumns;\n    };\n    ColumnController.prototype.setVirtualViewportLeftAndRight = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n            this.viewportRight = this.bodyWidth - this.scrollPosition;\n        }\n        else {\n            this.viewportLeft = this.scrollPosition;\n            this.viewportRight = this.scrollWidth + this.scrollPosition;\n        }\n    };\n    // used by clipboard service, to know what columns to paste into\n    ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {\n        var currentColumn = column;\n        var result = [];\n        while (currentColumn && utils_1._.exists(currentColumn)) {\n            result.push(currentColumn);\n            currentColumn = this.getDisplayedColAfter(currentColumn);\n        }\n        return result;\n    };\n    // checks what columns are currently displayed due to column virtualisation. fires an event\n    // if the list of columns has changed.\n    // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n    ColumnController.prototype.checkDisplayedVirtualColumns = function () {\n        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n        if (utils_1._.exists(this.displayedCenterColumns)) {\n            var hashBefore = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');\n            this.updateVirtualSets();\n            var hashAfter = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');\n            if (hashBefore !== hashAfter) {\n                var event_1 = {\n                    type: events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n                    api: this.gridApi,\n                    columnApi: this.columnApi\n                };\n                this.eventService.dispatchEvent(event_1);\n            }\n        }\n    };\n    ColumnController.prototype.setVirtualViewportPosition = function (scrollWidth, scrollPosition) {\n        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n            this.scrollWidth = scrollWidth;\n            this.scrollPosition = scrollPosition;\n            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n            // virtual columns again\n            this.bodyWidthDirty = true;\n            this.setVirtualViewportLeftAndRight();\n            if (this.ready) {\n                this.checkDisplayedVirtualColumns();\n            }\n        }\n    };\n    ColumnController.prototype.isPivotMode = function () {\n        return this.pivotMode;\n    };\n    ColumnController.prototype.isPivotSettingAllowed = function (pivot) {\n        if (pivot) {\n            if (this.gridOptionsWrapper.isTreeData()) {\n                console.warn(\"ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        else {\n            return true;\n        }\n    };\n    ColumnController.prototype.setPivotMode = function (pivotMode, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (pivotMode === this.pivotMode) {\n            return;\n        }\n        if (!this.isPivotSettingAllowed(this.pivotMode)) {\n            return;\n        }\n        this.pivotMode = pivotMode;\n        // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n        // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n        this.autoGroupsNeedBuilding = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n        if (!this.secondaryColumnsPresent) {\n            return null;\n        }\n        var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n        var foundColumn = null;\n        if (this.secondaryColumns) {\n            this.secondaryColumns.forEach(function (column) {\n                var thisPivotKeys = column.getColDef().pivotKeys;\n                var pivotValueColumn = column.getColDef().pivotValueColumn;\n                var pivotKeyMatches = utils_1._.compareArrays(thisPivotKeys, pivotKeys);\n                var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n                if (pivotKeyMatches && pivotValueMatches) {\n                    foundColumn = column;\n                }\n            });\n        }\n        return foundColumn;\n    };\n    ColumnController.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ColumnController');\n    };\n    ColumnController.prototype.setFirstRightAndLastLeftPinned = function (source) {\n        var lastLeft;\n        var firstRight;\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;\n            firstRight = this.displayedRightColumns ? utils_1._.last(this.displayedRightColumns) : null;\n        }\n        else {\n            lastLeft = this.displayedLeftColumns ? utils_1._.last(this.displayedLeftColumns) : null;\n            firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;\n        }\n        this.gridColumns.forEach(function (column) {\n            column.setLastLeftPinned(column === lastLeft, source);\n            column.setFirstRightPinned(column === firstRight, source);\n        });\n    };\n    ColumnController.prototype.autoSizeColumns = function (keys, source) {\n        // because of column virtualisation, we can only do this function on columns that are\n        // actually rendered, as non-rendered columns (outside the viewport and not rendered\n        // due to column virtualisation) are not present. this can result in all rendered columns\n        // getting narrowed, which in turn introduces more rendered columns on the RHS which\n        // did not get autosized in the original run, leaving the visible grid with columns on\n        // the LHS sized, but RHS no. so we keep looping through teh visible columns until\n        // no more cols are available (rendered) to be resized\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        // keep track of which cols we have resized in here\n        var columnsAutosized = [];\n        // initialise with anything except 0 so that while loop executes at least once\n        var changesThisTimeAround = -1;\n        while (changesThisTimeAround !== 0) {\n            changesThisTimeAround = 0;\n            this.actionOnGridColumns(keys, function (column) {\n                // if already autosized, skip it\n                if (columnsAutosized.indexOf(column) >= 0) {\n                    return false;\n                }\n                // get how wide this col should be\n                var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column);\n                // preferredWidth = -1 if this col is not on the screen\n                if (preferredWidth > 0) {\n                    var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n                    column.setActualWidth(newWidth, source);\n                    columnsAutosized.push(column);\n                    changesThisTimeAround++;\n                }\n                return true;\n            }, source);\n        }\n        if (columnsAutosized.length > 0) {\n            var event_2 = {\n                type: events_1.Events.EVENT_COLUMN_RESIZED,\n                columns: columnsAutosized,\n                column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,\n                finished: true,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: \"autosizeColumns\"\n            };\n            this.eventService.dispatchEvent(event_2);\n        }\n    };\n    ColumnController.prototype.autoSizeColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.autoSizeColumns([key], source);\n        }\n    };\n    ColumnController.prototype.autoSizeAllColumns = function (source) {\n        if (source === void 0) { source = \"api\"; }\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        this.autoSizeColumns(allDisplayedColumns, source);\n    };\n    ColumnController.prototype.getColumnsFromTree = function (rootColumns) {\n        var result = [];\n        recursiveFindColumns(rootColumns);\n        return result;\n        function recursiveFindColumns(childColumns) {\n            for (var i = 0; i < childColumns.length; i++) {\n                var child = childColumns[i];\n                if (child instanceof column_1.Column) {\n                    result.push(child);\n                }\n                else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                    recursiveFindColumns(child.getChildren());\n                }\n            }\n        }\n    };\n    ColumnController.prototype.getAllDisplayedColumnGroups = function () {\n        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {\n            return this.displayedLeftColumnTree\n                .concat(this.displayedCentreColumnTree)\n                .concat(this.displayedRightColumnTree);\n        }\n        else {\n            return null;\n        }\n    };\n    // + columnSelectPanel\n    ColumnController.prototype.getPrimaryColumnTree = function () {\n        return this.primaryColumnTree;\n    };\n    // + gridPanel -> for resizing the body and setting top margin\n    ColumnController.prototype.getHeaderRowCount = function () {\n        return this.gridHeaderRowCount;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getLeftDisplayedColumnGroups = function () {\n        return this.displayedLeftColumnTree;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getRightDisplayedColumnGroups = function () {\n        return this.displayedRightColumnTree;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getCenterDisplayedColumnGroups = function () {\n        return this.displayedCentreColumnTree;\n    };\n    ColumnController.prototype.getDisplayedColumnGroups = function (type) {\n        switch (type) {\n            case column_1.Column.PINNED_LEFT:\n                return this.getLeftDisplayedColumnGroups();\n            case column_1.Column.PINNED_RIGHT:\n                return this.getRightDisplayedColumnGroups();\n            default:\n                return this.getCenterDisplayedColumnGroups();\n        }\n    };\n    // gridPanel -> ensureColumnVisible\n    ColumnController.prototype.isColumnDisplayed = function (column) {\n        return this.getAllDisplayedColumns().indexOf(column) >= 0;\n    };\n    // + csvCreator\n    ColumnController.prototype.getAllDisplayedColumns = function () {\n        return this.allDisplayedColumns;\n    };\n    ColumnController.prototype.getAllDisplayedVirtualColumns = function () {\n        return this.allDisplayedVirtualColumns;\n    };\n    ColumnController.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedLeftColumns;\n        }\n        else {\n            return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);\n        }\n    };\n    ColumnController.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedRightColumns;\n        }\n        else {\n            return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);\n        }\n    };\n    ColumnController.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n        var result = [];\n        var lastConsideredCol = null;\n        var _loop_1 = function (i) {\n            var col = displayedColumns[i];\n            var maxAllowedColSpan = displayedColumns.length - i;\n            var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n            var columnsToCheckFilter = [col];\n            if (colSpan > 1) {\n                var colsToRemove = colSpan - 1;\n                for (var j = 1; j <= colsToRemove; j++) {\n                    columnsToCheckFilter.push(displayedColumns[i + j]);\n                }\n                i += colsToRemove;\n            }\n            // see which cols we should take out for column virtualisation\n            var filterPasses;\n            if (filterCallback) {\n                // if user provided a callback, means some columns may not be in the viewport.\n                // the user will NOT provide a callback if we are talking about pinned areas,\n                // as pinned areas have no horizontal scroll and do not virtualise the columns.\n                // if lots of columns, that means column spanning, and we set filterPasses = true\n                // if one or more of the columns spanned pass the filter.\n                filterPasses = false;\n                columnsToCheckFilter.forEach(function (colForFilter) {\n                    if (filterCallback(colForFilter)) {\n                        filterPasses = true;\n                    }\n                });\n            }\n            else {\n                filterPasses = true;\n            }\n            if (filterPasses) {\n                if (result.length === 0 && lastConsideredCol) {\n                    var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n                    if (gapBeforeColumn) {\n                        result.push(lastConsideredCol);\n                    }\n                }\n                result.push(col);\n            }\n            lastConsideredCol = col;\n            out_i_1 = i;\n        };\n        var out_i_1;\n        for (var i = 0; i < displayedColumns.length; i++) {\n            _loop_1(i);\n            i = out_i_1;\n        }\n        return result;\n    };\n    // + rowRenderer\n    // if we are not column spanning, this just returns back the virtual centre columns,\n    // however if we are column spanning, then different rows can have different virtual\n    // columns, so we have to work out the list for each individual row.\n    ColumnController.prototype.getAllDisplayedCenterVirtualColumnsForRow = function (rowNode) {\n        var _this = this;\n        if (!this.colSpanActive) {\n            return this.allDisplayedCenterVirtualColumns;\n        }\n        var emptySpaceBeforeColumn = function (col) { return col.getLeft() > _this.viewportLeft; };\n        // if doing column virtualisation, then we filter based on the viewport.\n        var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedCenterColumns, filterCallback, emptySpaceBeforeColumn);\n    };\n    ColumnController.prototype.isColumnInViewport = function (col) {\n        var columnLeft = col.getLeft();\n        var columnRight = col.getLeft() + col.getActualWidth();\n        // adding 200 for buffer size, so some cols off viewport are rendered.\n        // this helps horizontal scrolling so user rarely sees white space (unless\n        // they scroll horizontally fast). however we are conservative, as the more\n        // buffer the slower the vertical redraw speed\n        var leftBounds = this.viewportLeft - 200;\n        var rightBounds = this.viewportRight + 200;\n        var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n        var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n        return !columnToMuchLeft && !columnToMuchRight;\n    };\n    // used by:\n    // + angularGrid -> setting pinned body width\n    // note: this should be cached\n    ColumnController.prototype.getPinnedLeftContainerWidth = function () {\n        return this.getWidthOfColsInList(this.displayedLeftColumns);\n    };\n    // note: this should be cached\n    ColumnController.prototype.getPinnedRightContainerWidth = function () {\n        return this.getWidthOfColsInList(this.displayedRightColumns);\n    };\n    ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (!keys || utils_1._.missingOrEmpty(keys)) {\n            return;\n        }\n        var atLeastOne = false;\n        keys.forEach(function (key) {\n            var columnToAdd = _this.getPrimaryColumn(key);\n            if (!columnToAdd) {\n                return;\n            }\n            if (actionIsAdd) {\n                if (masterList.indexOf(columnToAdd) >= 0) {\n                    return;\n                }\n                masterList.push(columnToAdd);\n            }\n            else {\n                if (masterList.indexOf(columnToAdd) < 0) {\n                    return;\n                }\n                utils_1._.removeFromArray(masterList, columnToAdd);\n            }\n            columnCallback(columnToAdd);\n            atLeastOne = true;\n        });\n        if (!atLeastOne) {\n            return;\n        }\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: eventType,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.setRowGroupColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.setPrimaryColumnList(colKeys, this.rowGroupColumns, events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n    };\n    ColumnController.prototype.setRowGroupActive = function (active, column, source) {\n        if (active === column.isRowGroupActive()) {\n            return;\n        }\n        column.setRowGroupActive(active, source);\n        if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n            column.setVisible(true, source);\n        }\n    };\n    ColumnController.prototype.addRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.addRowGroupColumns([key], source);\n        }\n    };\n    ColumnController.prototype.addRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnController.prototype.removeRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnController.prototype.removeRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.removeRowGroupColumns([key], source);\n        }\n    };\n    ColumnController.prototype.addPivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) { return column.setPivotActive(true, source); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnController.prototype.setPivotColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.pivotColumns, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n            column.setPivotActive(added, source);\n        }, source);\n    };\n    ColumnController.prototype.addPivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.addPivotColumns([key], source);\n    };\n    ColumnController.prototype.removePivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) { return column.setPivotActive(false, source); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnController.prototype.removePivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removePivotColumns([key], source);\n    };\n    ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n        var _this = this;\n        masterList.length = 0;\n        if (utils_1._.exists(colKeys)) {\n            colKeys.forEach(function (key) {\n                var column = _this.getPrimaryColumn(key);\n                if (column) {\n                    masterList.push(column);\n                }\n            });\n        }\n        this.primaryColumns.forEach(function (column) {\n            var added = masterList.indexOf(column) >= 0;\n            columnCallback(added, column);\n        });\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: eventName,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.setValueColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.valueColumns, events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n    };\n    ColumnController.prototype.setValueActive = function (active, column, source) {\n        if (active === column.isValueActive()) {\n            return;\n        }\n        column.setValueActive(active, source);\n        if (active && !column.getAggFunc()) {\n            var defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n            column.setAggFunc(defaultAggFunc);\n        }\n    };\n    ColumnController.prototype.addValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), events_1.Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    ColumnController.prototype.addValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (colKey) {\n            this.addValueColumns([colKey], source);\n        }\n    };\n    ColumnController.prototype.removeValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removeValueColumns([colKey], source);\n    };\n    ColumnController.prototype.removeValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), events_1.Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    // returns the width we can set to this col, taking into consideration min and max widths\n    ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {\n        if (newWidth < column.getMinWidth()) {\n            newWidth = column.getMinWidth();\n        }\n        if (column.isGreaterThanMax(newWidth)) {\n            newWidth = column.getMaxWidth();\n        }\n        return newWidth;\n    };\n    ColumnController.prototype.getPrimaryOrGridColumn = function (key) {\n        var column = this.getPrimaryColumn(key);\n        if (column) {\n            return column;\n        }\n        else {\n            return this.getGridColumn(key);\n        }\n    };\n    ColumnController.prototype.setColumnWidth = function (key, // @key - the column who's size we want to change\n    newWidth, // @newWidth - width in pixels\n    shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n    finished, // @finished - ends up in the event, tells the user if more events are to come\n    source) {\n        if (source === void 0) { source = \"api\"; }\n        var col = this.getPrimaryOrGridColumn(key);\n        if (!col) {\n            return;\n        }\n        var sets = [];\n        sets.push({\n            width: newWidth,\n            ratios: [1],\n            columns: [col]\n        });\n        // if user wants to do shift resize by default, then we invert the shift operation\n        var defaultIsShift = this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n        if (defaultIsShift) {\n            shiftKey = !shiftKey;\n        }\n        if (shiftKey) {\n            var otherCol = this.getDisplayedColAfter(col);\n            if (!otherCol) {\n                return;\n            }\n            var widthDiff = col.getActualWidth() - newWidth;\n            var otherColWidth = otherCol.getActualWidth() + widthDiff;\n            sets.push({\n                width: otherColWidth,\n                ratios: [1],\n                columns: [otherCol]\n            });\n        }\n        this.resizeColumnSets(sets, finished, source);\n    };\n    ColumnController.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n        var columns = columnResizeSet.columns, width = columnResizeSet.width;\n        // every col has a min width, so sum them all up and see if we have enough room\n        // for all the min widths\n        var minWidthAccumulated = 0;\n        var maxWidthAccumulated = 0;\n        var maxWidthActive = true;\n        columns.forEach(function (col) {\n            minWidthAccumulated += col.getMinWidth();\n            if (col.getMaxWidth() > 0) {\n                maxWidthAccumulated += col.getMaxWidth();\n            }\n            else {\n                // if at least one columns has no max width, it means the group of columns\n                // then has no max width, as at least one column can take as much width as possible\n                maxWidthActive = false;\n            }\n        });\n        var minWidthPasses = width >= minWidthAccumulated;\n        var maxWidthPasses = !maxWidthActive || (width <= maxWidthAccumulated);\n        return minWidthPasses && maxWidthPasses;\n    };\n    // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n    // be resized. this is used for example when user tries to resize a group and holds shift key,\n    // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n    // so that's two sets for this method.\n    ColumnController.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n        var passMinMaxCheck = utils_1._.every(resizeSets, this.checkMinAndMaxWidthsForSet.bind(this));\n        if (!passMinMaxCheck) {\n            // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n            if (finished) {\n                var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n                var event_3 = {\n                    type: events_1.Events.EVENT_COLUMN_RESIZED,\n                    columns: columns,\n                    column: columns && columns.length === 1 ? columns[0] : null,\n                    finished: finished,\n                    api: this.gridApi,\n                    columnApi: this.columnApi,\n                    source: source\n                };\n                this.eventService.dispatchEvent(event_3);\n            }\n            return; // don't resize!\n        }\n        var changedCols = [];\n        var allCols = [];\n        resizeSets.forEach(function (set) {\n            var width = set.width, columns = set.columns, ratios = set.ratios;\n            // keep track of pixels used, and last column gets the remaining,\n            // to cater for rounding errors, and min width adjustments\n            var newWidths = {};\n            var finishedCols = {};\n            columns.forEach(function (col) { return allCols.push(col); });\n            // the loop below goes through each col. if a col exceeds it's min/max width,\n            // it then gets set to its min/max width and the column is removed marked as 'finished'\n            // and the calculation is done again leaving this column out. take for example columns\n            // {A, width: 50, maxWidth: 100}\n            // {B, width: 50}\n            // {C, width: 50}\n            // and then the set is set to width 600 - on the first pass the grid tries to set each column\n            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n            // splitting the remaining 500 pixels.\n            var finishedColsGrew = true;\n            var loopCount = 0;\n            var _loop_2 = function () {\n                loopCount++;\n                if (loopCount > 1000) {\n                    // this should never happen, but in the future, someone might introduce a bug here,\n                    // so we stop the browser from hanging and report bug properly\n                    console.error('ag-Grid: infinite loop in resizeColumnSets');\n                    return \"break\";\n                }\n                finishedColsGrew = false;\n                var subsetCols = [];\n                var subsetRatios = [];\n                var subsetRatioTotal = 0;\n                var pixelsToDistribute = width;\n                columns.forEach(function (col, index) {\n                    var thisColFinished = finishedCols[col.getId()];\n                    if (thisColFinished) {\n                        pixelsToDistribute -= newWidths[col.getId()];\n                    }\n                    else {\n                        subsetCols.push(col);\n                        var ratioThisCol = ratios[index];\n                        subsetRatioTotal += ratioThisCol;\n                        subsetRatios.push(ratioThisCol);\n                    }\n                });\n                // because we are not using all of the ratios (cols can be missing),\n                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n                // and so the ratioScale will be 1.\n                var ratioScale = 1 / subsetRatioTotal;\n                subsetCols.forEach(function (col, index) {\n                    var lastCol = index === (subsetCols.length - 1);\n                    var colNewWidth;\n                    if (lastCol) {\n                        colNewWidth = pixelsToDistribute;\n                    }\n                    else {\n                        colNewWidth = Math.round(ratios[index] * width * ratioScale);\n                        pixelsToDistribute -= colNewWidth;\n                    }\n                    if (colNewWidth < col.getMinWidth()) {\n                        colNewWidth = col.getMinWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    else if (col.getMaxWidth() > 0 && colNewWidth > col.getMaxWidth()) {\n                        colNewWidth = col.getMaxWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    newWidths[col.getId()] = colNewWidth;\n                });\n            };\n            while (finishedColsGrew) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            columns.forEach(function (col) {\n                var newWidth = newWidths[col.getId()];\n                if (col.getActualWidth() !== newWidth) {\n                    col.setActualWidth(newWidth);\n                    changedCols.push(col);\n                }\n            });\n        });\n        // if no cols changed, then no need to update more or send event.\n        var atLeastOneColChanged = changedCols.length > 0;\n        if (atLeastOneColChanged) {\n            this.setLeftValues(source);\n            this.updateBodyWidths();\n            this.checkDisplayedVirtualColumns();\n        }\n        // check for change first, to avoid unnecessary firing of events\n        // however we always fire 'finished' events. this is important\n        // when groups are resized, as if the group is changing slowly,\n        // eg 1 pixel at a time, then each change will fire change events\n        // in all the columns in the group, but only one with get the pixel.\n        if (atLeastOneColChanged || finished) {\n            var event_4 = {\n                type: events_1.Events.EVENT_COLUMN_RESIZED,\n                columns: allCols,\n                column: allCols.length === 1 ? allCols[0] : null,\n                finished: finished,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_4);\n        }\n    };\n    ColumnController.prototype.setColumnAggFunc = function (column, aggFunc, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (column) {\n            column.setAggFunc(aggFunc);\n            var event_5 = {\n                type: events_1.Events.EVENT_COLUMN_VALUE_CHANGED,\n                columns: [column],\n                column: column,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_5);\n        }\n    };\n    ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.rowGroupColumns[fromIndex];\n        this.rowGroupColumns.splice(fromIndex, 1);\n        this.rowGroupColumns.splice(toIndex, 0, column);\n        var event = {\n            type: events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            columns: this.rowGroupColumns,\n            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');\n            return;\n        }\n        // we want to pull all the columns out first and put them into an ordered list\n        var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n        if (failedRules) {\n            return;\n        }\n        utils_1._.moveInArray(this.gridColumns, columnsToMove, toIndex);\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: events_1.Events.EVENT_COLUMN_MOVED,\n            columns: columnsToMove,\n            column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n            toIndex: toIndex,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n        this.columnAnimationService.finish();\n    };\n    ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n        // make a copy of what the grid columns would look like after the move\n        var proposedColumnOrder = this.gridColumns.slice();\n        utils_1._.moveInArray(proposedColumnOrder, columnsToMove, toIndex);\n        // then check that the new proposed order of the columns passes all rules\n        if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n            return false;\n        }\n        if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n            return false;\n        }\n        return true;\n    };\n    ColumnController.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n        var foundNonLocked = false;\n        var rulePassed = true;\n        // go though the cols, see if any non-locked appear before any locked\n        proposedColumnOrder.forEach(function (col) {\n            if (col.getColDef().lockPosition) {\n                if (foundNonLocked) {\n                    rulePassed = false;\n                }\n            }\n            else {\n                foundNonLocked = true;\n            }\n        });\n        return rulePassed;\n    };\n    ColumnController.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n        var rulePassed = true;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n            if (!(child instanceof originalColumnGroup_1.OriginalColumnGroup)) {\n                return;\n            }\n            var columnGroup = child;\n            var marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;\n            if (!marryChildren) {\n                return;\n            }\n            var newIndexes = [];\n            columnGroup.getLeafColumns().forEach(function (col) {\n                var newColIndex = allColumnsCopy.indexOf(col);\n                newIndexes.push(newColIndex);\n            });\n            var maxIndex = Math.max.apply(Math, newIndexes);\n            var minIndex = Math.min.apply(Math, newIndexes);\n            // spread is how far the first column in this group is away from the last column\n            var spread = maxIndex - minIndex;\n            var maxSpread = columnGroup.getLeafColumns().length - 1;\n            // if the columns\n            if (spread > maxSpread) {\n                rulePassed = false;\n            }\n            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n        });\n        return rulePassed;\n    };\n    ColumnController.prototype.moveColumn = function (key, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.moveColumns([key], toIndex, source);\n    };\n    ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.gridColumns[fromIndex];\n        this.moveColumn(column, toIndex, source);\n    };\n    // used by:\n    // + angularGrid -> for setting body width\n    // + rowController -> setting main row widths (when inserting and resizing)\n    // need to cache this\n    ColumnController.prototype.getBodyContainerWidth = function () {\n        return this.bodyWidth;\n    };\n    ColumnController.prototype.getContainerWidth = function (pinned) {\n        switch (pinned) {\n            case column_1.Column.PINNED_LEFT:\n                return this.leftWidth;\n            case column_1.Column.PINNED_RIGHT:\n                return this.rightWidth;\n            default:\n                return this.bodyWidth;\n        }\n    };\n    // after setColumnWidth or updateGroupsAndDisplayedColumns\n    ColumnController.prototype.updateBodyWidths = function () {\n        var newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);\n        var newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);\n        var newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns);\n        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n        // columns, due to RTL inverting the y coordinates\n        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n        var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n        if (atLeastOneChanged) {\n            this.bodyWidth = newBodyWidth;\n            this.leftWidth = newLeftWidth;\n            this.rightWidth = newRightWidth;\n            // when this fires, it is picked up by the gridPanel, which ends up in\n            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()\n            var event_6 = {\n                type: events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_6);\n        }\n    };\n    // + rowController\n    ColumnController.prototype.getValueColumns = function () {\n        return this.valueColumns ? this.valueColumns : [];\n    };\n    // + rowController\n    ColumnController.prototype.getPivotColumns = function () {\n        return this.pivotColumns ? this.pivotColumns : [];\n    };\n    // + clientSideRowModel\n    ColumnController.prototype.isPivotActive = function () {\n        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n    };\n    // + toolPanel\n    ColumnController.prototype.getRowGroupColumns = function () {\n        return this.rowGroupColumns ? this.rowGroupColumns : [];\n    };\n    // + rowController -> while inserting rows\n    ColumnController.prototype.getDisplayedCenterColumns = function () {\n        return this.displayedCenterColumns;\n    };\n    // + rowController -> while inserting rows\n    ColumnController.prototype.getDisplayedLeftColumns = function () {\n        return this.displayedLeftColumns;\n    };\n    ColumnController.prototype.getDisplayedRightColumns = function () {\n        return this.displayedRightColumns;\n    };\n    ColumnController.prototype.getDisplayedColumns = function (type) {\n        switch (type) {\n            case column_1.Column.PINNED_LEFT:\n                return this.getDisplayedLeftColumns();\n            case column_1.Column.PINNED_RIGHT:\n                return this.getDisplayedRightColumns();\n            default:\n                return this.getDisplayedCenterColumns();\n        }\n    };\n    // used by:\n    // + clientSideRowController -> sorting, building quick filter text\n    // + headerRenderer -> sorting (clearing icon)\n    ColumnController.prototype.getAllPrimaryColumns = function () {\n        return this.primaryColumns ? this.primaryColumns.slice() : null;\n    };\n    ColumnController.prototype.getSecondaryColumns = function () {\n        return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n    };\n    ColumnController.prototype.getAllColumnsForQuickFilter = function () {\n        return this.columnsForQuickFilter;\n    };\n    // + moveColumnController\n    ColumnController.prototype.getAllGridColumns = function () {\n        return this.gridColumns;\n    };\n    ColumnController.prototype.isEmpty = function () {\n        return utils_1._.missingOrEmpty(this.gridColumns);\n    };\n    ColumnController.prototype.isRowGroupEmpty = function () {\n        return utils_1._.missingOrEmpty(this.rowGroupColumns);\n    };\n    ColumnController.prototype.setColumnVisible = function (key, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setColumnsVisible([key], visible, source);\n    };\n    ColumnController.prototype.setColumnsVisible = function (keys, visible, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        this.actionOnGridColumns(keys, function (column) {\n            if (column.isVisible() !== visible) {\n                column.setVisible(visible, source);\n                return true;\n            }\n            else {\n                return false;\n            }\n        }, source, function () {\n            var event = {\n                type: events_1.Events.EVENT_COLUMN_VISIBLE,\n                visible: visible,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    ColumnController.prototype.setColumnPinned = function (key, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.setColumnsPinned([key], pinned, source);\n        }\n    };\n    ColumnController.prototype.setColumnsPinned = function (keys, pinned, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n            console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n            return;\n        }\n        this.columnAnimationService.start();\n        var actualPinned;\n        if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {\n            actualPinned = column_1.Column.PINNED_LEFT;\n        }\n        else if (pinned === column_1.Column.PINNED_RIGHT) {\n            actualPinned = column_1.Column.PINNED_RIGHT;\n        }\n        else {\n            actualPinned = null;\n        }\n        this.actionOnGridColumns(keys, function (col) {\n            if (col.getPinned() !== actualPinned) {\n                col.setPinned(actualPinned);\n                return true;\n            }\n            else {\n                return false;\n            }\n        }, source, function () {\n            var event = {\n                type: events_1.Events.EVENT_COLUMN_PINNED,\n                pinned: actualPinned,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    // does an action on a set of columns. provides common functionality for looking up the\n    // columns based on key, getting a list of effected columns, and then updated the event\n    // with either one column (if it was just one col) or a list of columns\n    // used by: autoResize, setVisible, setPinned\n    ColumnController.prototype.actionOnGridColumns = function (// the column keys this action will be on\n    keys, \n    // the action to do - if this returns false, the column was skipped\n    // and won't be included in the event\n    action, \n    // should return back a column event of the right type\n    source, createEvent) {\n        var _this = this;\n        if (utils_1._.missingOrEmpty(keys)) {\n            return;\n        }\n        var updatedColumns = [];\n        keys.forEach(function (key) {\n            var column = _this.getGridColumn(key);\n            if (!column) {\n                return;\n            }\n            // need to check for false with type (ie !== instead of !=)\n            // as not returning anything (undefined) would also be false\n            var resultOfAction = action(column);\n            if (resultOfAction !== false) {\n                updatedColumns.push(column);\n            }\n        });\n        if (updatedColumns.length === 0) {\n            return;\n        }\n        this.updateDisplayedColumns(source);\n        if (utils_1._.exists(createEvent) && createEvent) {\n            var event_7 = createEvent();\n            event_7.columns = updatedColumns;\n            event_7.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n            this.eventService.dispatchEvent(event_7);\n        }\n    };\n    ColumnController.prototype.getDisplayedColBefore = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex > 0) {\n            return allDisplayedColumns[oldIndex - 1];\n        }\n        else {\n            return null;\n        }\n    };\n    // used by:\n    // + rowRenderer -> for navigation\n    ColumnController.prototype.getDisplayedColAfter = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex < (allDisplayedColumns.length - 1)) {\n            return allDisplayedColumns[oldIndex + 1];\n        }\n        else {\n            return null;\n        }\n    };\n    ColumnController.prototype.getDisplayedGroupAfter = function (columnGroup) {\n        // pick one col in this group at random\n        var col = columnGroup.getDisplayedLeafColumns()[0];\n        var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel();\n        while (true) {\n            // keep moving to the next col, until we get to another group\n            col = this.getDisplayedColAfter(col);\n            // if no col after, means no group after\n            if (!col) {\n                return null;\n            }\n            // get group at same level as the one we are looking for\n            var groupPointer = col.getParent();\n            while (groupPointer.getOriginalColumnGroup().getLevel() !== requiredLevel) {\n                groupPointer = groupPointer.getParent();\n            }\n            if (groupPointer !== columnGroup) {\n                return groupPointer;\n            }\n        }\n    };\n    ColumnController.prototype.isPinningLeft = function () {\n        return this.displayedLeftColumns.length > 0;\n    };\n    ColumnController.prototype.isPinningRight = function () {\n        return this.displayedRightColumns.length > 0;\n    };\n    ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n        var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n        if (this.groupAutoColumns && utils_1._.exists(this.groupAutoColumns)) {\n            this.groupAutoColumns.forEach(function (col) { return result.push(col); });\n        }\n        if (this.secondaryColumnsPresent && this.secondaryColumns) {\n            this.secondaryColumns.forEach(function (column) { return result.push(column); });\n        }\n        return result;\n    };\n    ColumnController.prototype.createStateItemFromColumn = function (column) {\n        var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n        var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n        var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n        return {\n            colId: column.getColId(),\n            hide: !column.isVisible(),\n            aggFunc: aggFunc,\n            width: column.getActualWidth(),\n            pivotIndex: pivotIndex,\n            pinned: column.getPinned(),\n            rowGroupIndex: rowGroupIndex\n        };\n    };\n    ColumnController.prototype.getColumnState = function () {\n        if (utils_1._.missing(this.primaryColumns)) {\n            return [];\n        }\n        var primaryColumnState = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n        var groupAutoColumnState = this.groupAutoColumns\n            // if groupAutoCols, then include them\n            ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this))\n            // otherwise no\n            : [];\n        var columnStateList = groupAutoColumnState.concat(primaryColumnState);\n        if (!this.pivotMode) {\n            this.orderColumnStateList(columnStateList);\n        }\n        return columnStateList;\n    };\n    ColumnController.prototype.orderColumnStateList = function (columnStateList) {\n        var gridColumnIds = this.gridColumns.map(function (column) { return column.getColId(); });\n        columnStateList.sort(function (itemA, itemB) {\n            var posA = gridColumnIds.indexOf(itemA.colId);\n            var posB = gridColumnIds.indexOf(itemB.colId);\n            return posA - posB;\n        });\n    };\n    ColumnController.prototype.resetColumnState = function (suppressEverythingEvent, source) {\n        // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n        // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n        // As a work around, developers should just put lockPosition columns first in their colDef list.\n        if (suppressEverythingEvent === void 0) { suppressEverythingEvent = false; }\n        if (source === void 0) { source = \"api\"; }\n        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n        var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        var columnStates = [];\n        // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n        // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n        // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n        var letRowGroupIndex = 1000;\n        var letPivotIndex = 1000;\n        if (primaryColumns) {\n            primaryColumns.forEach(function (column) {\n                var rowGroupIndex = column.getColDef().rowGroupIndex;\n                var rowGroup = column.getColDef().rowGroup;\n                var pivotIndex = column.getColDef().pivotIndex;\n                var pivot = column.getColDef().pivot;\n                var stateItem = {\n                    colId: column.getColId(),\n                    aggFunc: column.getColDef().aggFunc,\n                    hide: column.getColDef().hide,\n                    pinned: column.getColDef().pinned,\n                    rowGroupIndex: rowGroupIndex,\n                    pivotIndex: column.getColDef().pivotIndex,\n                    width: column.getColDef().width\n                };\n                if (utils_1._.missing(rowGroupIndex) && rowGroup) {\n                    stateItem.rowGroupIndex = letRowGroupIndex++;\n                }\n                if (utils_1._.missing(pivotIndex) && pivot) {\n                    stateItem.pivotIndex = letPivotIndex++;\n                }\n                columnStates.push(stateItem);\n            });\n        }\n        this.setColumnState(columnStates, suppressEverythingEvent, source);\n    };\n    ColumnController.prototype.setColumnState = function (columnStates, suppressEverythingEvent, source) {\n        var _this = this;\n        if (suppressEverythingEvent === void 0) { suppressEverythingEvent = false; }\n        if (source === void 0) { source = \"api\"; }\n        if (utils_1._.missingOrEmpty(this.primaryColumns)) {\n            return false;\n        }\n        var columnStateBefore = this.getColumnState();\n        this.autoGroupsNeedBuilding = true;\n        // at the end below, this list will have all columns we got no state for\n        var columnsWithNoState = this.primaryColumns.slice();\n        this.rowGroupColumns = [];\n        this.valueColumns = [];\n        this.pivotColumns = [];\n        var success = true;\n        var rowGroupIndexes = {};\n        var pivotIndexes = {};\n        var autoGroupColumnStates = [];\n        if (columnStates) {\n            columnStates.forEach(function (state) {\n                // auto group columns are re-created so deferring syncing with ColumnState\n                if (utils_1._.exists(_this.getAutoColumn(state.colId))) {\n                    autoGroupColumnStates.push(state);\n                    return;\n                }\n                var column = _this.getPrimaryColumn(state.colId);\n                if (!column) {\n                    console.warn('ag-grid: column ' + state.colId + ' not found');\n                    success = false;\n                }\n                else {\n                    _this.syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, source);\n                    utils_1._.removeFromArray(columnsWithNoState, column);\n                }\n            });\n        }\n        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n        columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));\n        // sort the lists according to the indexes that were provided\n        this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));\n        this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));\n        this.updateGridColumns();\n        // sync newly created auto group columns with ColumnState\n        autoGroupColumnStates.forEach(function (stateItem) {\n            var autoCol = _this.getAutoColumn(stateItem.colId);\n            _this.syncColumnWithStateItem(autoCol, stateItem, rowGroupIndexes, pivotIndexes, source);\n        });\n        if (columnStates) {\n            var orderOfColIds_1 = columnStates.map(function (stateItem) { return stateItem.colId; });\n            this.gridColumns.sort(function (colA, colB) {\n                var indexA = orderOfColIds_1.indexOf(colA.getId());\n                var indexB = orderOfColIds_1.indexOf(colB.getId());\n                return indexA - indexB;\n            });\n        }\n        // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n        // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n        // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n        // is less sexy for the code here, but it keeps consistency.\n        this.putFixedColumnsFirst();\n        this.updateDisplayedColumns(source);\n        if (!suppressEverythingEvent) {\n            var event_8 = {\n                type: events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_8);\n        }\n        this.raiseColumnEvents(columnStateBefore, source);\n        return success;\n    };\n    ColumnController.prototype.raiseColumnEvents = function (columnStateBefore, source) {\n        var _this = this;\n        if (this.gridOptionsWrapper.isSuppressSetColumnStateEvents()) {\n            return;\n        }\n        var columnStateAfter = this.getColumnState();\n        // raises generic ColumnEvents where all columns are returned rather than what has changed\n        var raiseEventWithAllColumns = function (eventType, idMapper, columns) {\n            var unchanged = utils_1._.compareArrays(columnStateBefore.map(idMapper).sort(), columnStateAfter.map(idMapper).sort());\n            if (unchanged) {\n                return;\n            }\n            // returning all columns rather than what has changed!\n            var event = {\n                type: eventType,\n                columns: columns,\n                column: columns.length === 1 ? columns[0] : null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            _this.eventService.dispatchEvent(event);\n        };\n        // determines which columns have changed according to supplied predicate\n        var getChangedColumns = function (changedPredicate) {\n            var changedColumns = [];\n            var columnStateBeforeMap = {};\n            columnStateBefore.forEach(function (col) {\n                columnStateBeforeMap[col.colId] = col;\n            });\n            _this.gridColumns.forEach(function (column) {\n                var colStateBefore = columnStateBeforeMap[column.getColId()];\n                if (!colStateBefore || changedPredicate(colStateBefore, column)) {\n                    changedColumns.push(column);\n                }\n            });\n            return changedColumns;\n        };\n        // generic ColumnEvents which return current column list\n        var valueColumnIdMapper = function (cs) { return cs.colId + '-' + cs.aggFunc; };\n        raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, valueColumnIdMapper, this.valueColumns);\n        var pivotColumnIdMapper = function (cs) { return cs.colId + '-' + cs.pivotIndex; };\n        raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, pivotColumnIdMapper, this.pivotColumns);\n        var rowGroupColumnIdMapper = function (cs) { return cs.colId + '-' + cs.rowGroupIndex; };\n        raiseEventWithAllColumns(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, rowGroupColumnIdMapper, this.rowGroupColumns);\n        // specific ColumnEvents which return what's changed\n        var pinnedChangePredicate = function (cs, c) { return cs.pinned !== c.getPinned(); };\n        this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n        var visibilityChangePredicate = function (cs, c) { return cs.hide === c.isVisible(); };\n        var cols = getChangedColumns(visibilityChangePredicate);\n        this.raiseColumnVisibleEvent(cols, source);\n        var resizeChangePredicate = function (cs, c) { return cs.width !== c.getActualWidth(); };\n        this.raiseColumnResizeEvent(getChangedColumns(resizeChangePredicate), source);\n        // special handling for moved column events\n        this.raiseColumnMovedEvent(columnStateBefore, source);\n    };\n    ColumnController.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n        if (changedColumns.length > 0) {\n            var event_9 = {\n                type: events_1.Events.EVENT_COLUMN_PINNED,\n                pinned: null,\n                columns: changedColumns,\n                column: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_9);\n        }\n    };\n    ColumnController.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n        if (changedColumns.length > 0) {\n            var event_10 = {\n                type: events_1.Events.EVENT_COLUMN_VISIBLE,\n                visible: undefined,\n                columns: changedColumns,\n                column: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_10);\n        }\n    };\n    ColumnController.prototype.raiseColumnResizeEvent = function (changedColumns, source) {\n        if (changedColumns.length > 0) {\n            var event_11 = {\n                type: events_1.Events.EVENT_COLUMN_RESIZED,\n                columns: changedColumns,\n                column: null,\n                finished: true,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_11);\n        }\n    };\n    ColumnController.prototype.raiseColumnMovedEvent = function (columnStateBefore, source) {\n        var movedColumns = [];\n        var columnStateAfter = this.getColumnState();\n        var _loop_3 = function (i) {\n            var before = columnStateBefore[i];\n            var after = columnStateAfter[i];\n            // don't consider column if reintroduced or hidden\n            if (!before || after.hide) {\n                return \"continue\";\n            }\n            if (before.colId !== after.colId) {\n                var predicate = function (column) { return column.getColId() === after.colId; };\n                var movedColumn = utils_1._.find(this_1.allDisplayedColumns, predicate);\n                movedColumns.push(movedColumn);\n            }\n        };\n        var this_1 = this;\n        for (var i = 0; i < columnStateAfter.length; i++) {\n            _loop_3(i);\n        }\n        if (movedColumns.length > 0) {\n            var event_12 = {\n                type: events_1.Events.EVENT_COLUMN_MOVED,\n                columns: movedColumns,\n                column: null,\n                toIndex: undefined,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_12);\n        }\n    };\n    ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {\n        var indexA = indexes[colA.getId()];\n        var indexB = indexes[colB.getId()];\n        return indexA - indexB;\n    };\n    ColumnController.prototype.syncColumnWithNoState = function (column, source) {\n        column.setVisible(false, source);\n        column.setAggFunc(null);\n        column.setPinned(null);\n        column.setRowGroupActive(false, source);\n        column.setPivotActive(false, source);\n        column.setValueActive(false, source);\n    };\n    ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes, source) {\n        if (!column) {\n            return;\n        }\n        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n        column.setVisible(!stateItem.hide, source);\n        // sets pinned to 'left' or 'right'\n        column.setPinned(stateItem.pinned);\n        // if width provided and valid, use it, otherwise stick with the old width\n        var minColWidth = this.gridOptionsWrapper.getMinColWidth();\n        if (stateItem.width && minColWidth &&\n            (stateItem.width >= minColWidth)) {\n            column.setActualWidth(stateItem.width, source);\n        }\n        if (typeof stateItem.aggFunc === 'string') {\n            column.setAggFunc(stateItem.aggFunc);\n            column.setValueActive(true, source);\n            this.valueColumns.push(column);\n        }\n        else {\n            if (utils_1._.exists(stateItem.aggFunc)) {\n                console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +\n                    'functions, register the functions first before using them in get/set state. This is because it is' +\n                    'intended for the column state to be stored and retrieved as simple JSON.');\n            }\n            column.setAggFunc(null);\n            column.setValueActive(false, source);\n        }\n        if (typeof stateItem.rowGroupIndex === 'number') {\n            this.rowGroupColumns.push(column);\n            column.setRowGroupActive(true, source);\n            rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;\n        }\n        else {\n            column.setRowGroupActive(false, source);\n        }\n        if (typeof stateItem.pivotIndex === 'number') {\n            this.pivotColumns.push(column);\n            column.setPivotActive(true, source);\n            pivotIndexes[column.getId()] = stateItem.pivotIndex;\n        }\n        else {\n            column.setPivotActive(false, source);\n        }\n    };\n    ColumnController.prototype.getGridColumns = function (keys) {\n        return this.getColumns(keys, this.getGridColumn.bind(this));\n    };\n    ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {\n        var foundColumns = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var column = columnLookupCallback(key);\n                if (column) {\n                    foundColumns.push(column);\n                }\n            });\n        }\n        return foundColumns;\n    };\n    // used by growGroupPanel\n    ColumnController.prototype.getColumnWithValidation = function (key) {\n        if (key == null) {\n            return null;\n        }\n        var column = this.getGridColumn(key);\n        if (!column) {\n            console.warn('ag-Grid: could not find column ' + key);\n        }\n        return column;\n    };\n    ColumnController.prototype.getPrimaryColumn = function (key) {\n        return this.getColumn(key, this.primaryColumns);\n    };\n    ColumnController.prototype.getGridColumn = function (key) {\n        return this.getColumn(key, this.gridColumns);\n    };\n    ColumnController.prototype.getColumn = function (key, columnList) {\n        if (!key) {\n            return null;\n        }\n        for (var i = 0; i < columnList.length; i++) {\n            if (this.columnsMatch(columnList[i], key)) {\n                return columnList[i];\n            }\n        }\n        return this.getAutoColumn(key);\n    };\n    ColumnController.prototype.getAutoColumn = function (key) {\n        var _this = this;\n        if (!this.groupAutoColumns || !utils_1._.exists(this.groupAutoColumns) || utils_1._.missing(this.groupAutoColumns)) {\n            return null;\n        }\n        return utils_1._.find(this.groupAutoColumns, function (groupCol) {\n            return _this.columnsMatch(groupCol, key);\n        });\n    };\n    ColumnController.prototype.columnsMatch = function (column, key) {\n        var columnMatches = column === key;\n        var colDefMatches = column.getColDef() === key;\n        var idMatches = column.getColId() == key;\n        return columnMatches || colDefMatches || idMatches;\n    };\n    ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n        if (includeAggFunc === void 0) { includeAggFunc = false; }\n        if (!column) {\n            return null;\n        }\n        var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n        if (includeAggFunc) {\n            return this.wrapHeaderNameWithAggFunc(column, headerName);\n        }\n        else {\n            return headerName;\n        }\n    };\n    ColumnController.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n        var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n        if (colGroupDef) {\n            return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n        }\n        else {\n            return null;\n        }\n    };\n    ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n        return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n    };\n    // location is where the column is going to appear, ie who is calling us\n    ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n        var headerValueGetter = colDef.headerValueGetter;\n        if (headerValueGetter) {\n            var params = {\n                colDef: colDef,\n                column: column,\n                columnGroup: columnGroup,\n                originalColumnGroup: originalColumnGroup,\n                location: location,\n                api: this.gridOptionsWrapper.getApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            if (typeof headerValueGetter === 'function') {\n                // valueGetter is a function, so just call it\n                return headerValueGetter(params);\n            }\n            else if (typeof headerValueGetter === 'string') {\n                // valueGetter is an expression, so execute the expression\n                return this.expressionService.evaluate(headerValueGetter, params);\n            }\n            else {\n                console.warn('ag-grid: headerValueGetter must be a function or a string');\n                return '';\n            }\n        }\n        else if (colDef.headerName != null) {\n            return colDef.headerName;\n        }\n        else if (colDef.field) {\n            return utils_1._.camelCaseToHumanText(colDef.field);\n        }\n        else {\n            return '';\n        }\n    };\n    /*\n        private getHeaderGroupName(columnGroup: ColumnGroup): string {\n            let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n            let headerValueGetter = colGroupDef.headerValueGetter;\n\n            if (headerValueGetter) {\n                let params = {\n                    columnGroup: columnGroup,\n                    colDef: colGroupDef,\n                    api: this.gridOptionsWrapper.getApi(),\n                    context: this.gridOptionsWrapper.getContext()\n                };\n\n                if (typeof headerValueGetter === 'function') {\n                    // valueGetter is a function, so just call it\n                    return headerValueGetter(params);\n                } else if (typeof headerValueGetter === 'string') {\n                    // valueGetter is an expression, so execute the expression\n                    return this.expressionService.evaluate(headerValueGetter, params);\n                } else {\n                    console.warn('ag-grid: headerValueGetter must be a function or a string');\n                    return '';\n                }\n            } else {\n                return colGroupDef.headerName;\n            }\n        }\n    */\n    ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n            return headerName;\n        }\n        // only columns with aggregation active can have aggregations\n        var pivotValueColumn = column.getColDef().pivotValueColumn;\n        var pivotActiveOnThisColumn = utils_1._.exists(pivotValueColumn);\n        var aggFunc = null;\n        var aggFuncFound;\n        // otherwise we have a measure that is active, and we are doing aggregation on it\n        if (pivotActiveOnThisColumn) {\n            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n            aggFuncFound = true;\n        }\n        else {\n            var measureActive = column.isValueActive();\n            var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n            if (measureActive && aggregationPresent) {\n                aggFunc = column.getAggFunc();\n                aggFuncFound = true;\n            }\n            else {\n                aggFuncFound = false;\n            }\n        }\n        if (aggFuncFound) {\n            var aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';\n            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            return aggFuncStringTranslated + \"(\" + headerName + \")\";\n        }\n        else {\n            return headerName;\n        }\n    };\n    // returns the group with matching colId and instanceId. If instanceId is missing,\n    // matches only on the colId.\n    ColumnController.prototype.getColumnGroup = function (colId, instanceId) {\n        if (!colId) {\n            return null;\n        }\n        if (colId instanceof columnGroup_1.ColumnGroup) {\n            return colId;\n        }\n        var allColumnGroups = this.getAllDisplayedColumnGroups();\n        var checkInstanceId = typeof instanceId === 'number';\n        var result = null;\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof columnGroup_1.ColumnGroup) {\n                var columnGroup = child;\n                var matched = void 0;\n                if (checkInstanceId) {\n                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n                }\n                else {\n                    matched = colId === columnGroup.getGroupId();\n                }\n                if (matched) {\n                    result = columnGroup;\n                }\n            }\n        });\n        return result;\n    };\n    ColumnController.prototype.isReady = function () {\n        return this.ready;\n    };\n    ColumnController.prototype.createValueColumns = function (source, oldPrimaryColumns) {\n        this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) { return col.setValueActive(flag, source); }, \n        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n        function () { return null; }, \n        // aggFunc is a string, so return it's existence\n        function (colDef) { return !!colDef.aggFunc; });\n        // all new columns added will have aggFunc missing, so set it to what is in the colDef\n        this.valueColumns.forEach(function (col) {\n            if (!col.getAggFunc()) {\n                col.setAggFunc(col.getColDef().aggFunc);\n            }\n        });\n    };\n    ColumnController.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n        this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) { return col.setRowGroupActive(flag, source); }, function (colDef) { return colDef.rowGroupIndex; }, function (colDef) { return colDef.rowGroup; });\n    };\n    ColumnController.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getValueFunc) {\n        var _this = this;\n        if (!previousCols) {\n            previousCols = [];\n        }\n        // remove cols that no longer exist\n        var colPresentInPrimaryFunc = function (col) { return _this.primaryColumns.indexOf(col) >= 0; };\n        var colMissingFromPrimaryFunc = function (col) { return _this.primaryColumns.indexOf(col) < 0; };\n        var colNewFunc = function (col) { return !oldPrimaryColumns || oldPrimaryColumns.indexOf(col) < 0; };\n        var removedCols = previousCols.filter(colMissingFromPrimaryFunc);\n        var existingCols = previousCols.filter(colPresentInPrimaryFunc);\n        var newPrimaryCols = this.primaryColumns.filter(colNewFunc);\n        removedCols.forEach(function (col) { return setFlagFunc(col, false); });\n        var newCols = [];\n        // we only want to work on new columns, as old columns already got processed first time around\n        // pull out items with xxxIndex\n        newPrimaryCols.forEach(function (col) {\n            var index = getIndexFunc(col.getColDef());\n            if (typeof index === 'number') {\n                newCols.push(col);\n            }\n        });\n        // then sort them\n        newCols.sort(function (colA, colB) {\n            var indexA = getIndexFunc(colA.getColDef());\n            var indexB = getIndexFunc(colB.getColDef());\n            if (indexA === indexB) {\n                return 0;\n            }\n            else if (indexA < indexB) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        });\n        // now just pull out items xxx (boolean value), they will be added at the end\n        // after the indexed ones, but in the order the columns appear\n        newPrimaryCols.forEach(function (col) {\n            var booleanValue = getValueFunc(col.getColDef());\n            if (booleanValue) {\n                // if user already specified xxxIndex then we skip it as this col already included\n                if (newCols.indexOf(col) >= 0) {\n                    return;\n                }\n                newCols.push(col);\n            }\n        });\n        newCols.forEach(function (col) { return setFlagFunc(col, true); });\n        var res = existingCols.concat(newCols);\n        return res;\n    };\n    ColumnController.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n        this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) { return col.setPivotActive(flag, source); }, function (colDef) { return colDef.pivotIndex; }, function (colDef) { return colDef.pivot; });\n    };\n    ColumnController.prototype.resetColumnGroupState = function (source) {\n        if (source === void 0) { source = \"api\"; }\n        var stateItems = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                var groupState = {\n                    groupId: child.getGroupId(),\n                    open: child.getColGroupDef().openByDefault\n                };\n                stateItems.push(groupState);\n            }\n        });\n        this.setColumnGroupState(stateItems, source);\n    };\n    ColumnController.prototype.getColumnGroupState = function () {\n        var columnGroupState = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                var originalColumnGroup = node;\n                columnGroupState.push({\n                    groupId: originalColumnGroup.getGroupId(),\n                    open: originalColumnGroup.isExpanded()\n                });\n            }\n        });\n        return columnGroupState;\n    };\n    ColumnController.prototype.setColumnGroupState = function (stateItems, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        var impactedGroups = [];\n        stateItems.forEach(function (stateItem) {\n            var groupKey = stateItem.groupId;\n            var newValue = stateItem.open;\n            var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n            if (!originalColumnGroup) {\n                return;\n            }\n            if (originalColumnGroup.isExpanded() === newValue) {\n                return;\n            }\n            _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n            originalColumnGroup.setExpanded(newValue);\n            impactedGroups.push(originalColumnGroup);\n        });\n        this.updateGroupsAndDisplayedColumns(source);\n        this.setFirstRightAndLastLeftPinned(source);\n        impactedGroups.forEach(function (originalColumnGroup) {\n            var event = {\n                type: events_1.Events.EVENT_COLUMN_GROUP_OPENED,\n                columnGroup: originalColumnGroup,\n                api: _this.gridApi,\n                columnApi: _this.columnApi\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n        this.columnAnimationService.finish();\n    };\n    // called by headerRenderer - when a header is opened or closed\n    ColumnController.prototype.setColumnGroupOpened = function (key, newValue, source) {\n        if (source === void 0) { source = \"api\"; }\n        var keyAsString;\n        if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {\n            keyAsString = key.getId();\n        }\n        else {\n            keyAsString = key;\n        }\n        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);\n    };\n    ColumnController.prototype.getOriginalColumnGroup = function (key) {\n        if (key instanceof originalColumnGroup_1.OriginalColumnGroup) {\n            return key;\n        }\n        if (typeof key !== 'string') {\n            console.error('ag-Grid: group key must be a string');\n        }\n        // otherwise, search for the column group by id\n        var res = null;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                var originalColumnGroup = node;\n                if (originalColumnGroup.getId() === key) {\n                    res = originalColumnGroup;\n                }\n            }\n        });\n        return res;\n    };\n    ColumnController.prototype.calculateColumnsForDisplay = function () {\n        var _this = this;\n        var columnsForDisplay;\n        if (this.pivotMode && !this.secondaryColumnsPresent) {\n            // pivot mode is on, but we are not pivoting, so we only\n            // show columns we are aggregating on\n            columnsForDisplay = utils_1._.filter(this.gridColumns, function (column) {\n                var isAutoGroupCol = _this.groupAutoColumns && _this.groupAutoColumns.indexOf(column) >= 0;\n                var isValueCol = _this.valueColumns && _this.valueColumns.indexOf(column) >= 0;\n                return isAutoGroupCol || isValueCol;\n            });\n        }\n        else {\n            // otherwise continue as normal. this can be working on the primary\n            // or secondary columns, whatever the gridColumns are set to\n            columnsForDisplay = utils_1._.filter(this.gridColumns, function (column) {\n                // keep col if a) it's auto-group or b) it's visible\n                var isAutoGroupCol = _this.groupAutoColumns && _this.groupAutoColumns.indexOf(column) >= 0;\n                return isAutoGroupCol || column.isVisible();\n            });\n        }\n        return columnsForDisplay;\n    };\n    ColumnController.prototype.checkColSpanActiveInCols = function (columns) {\n        var result = false;\n        columns.forEach(function (col) {\n            if (utils_1._.exists(col.getColDef().colSpan)) {\n                result = true;\n            }\n        });\n        return result;\n    };\n    ColumnController.prototype.calculateColumnsForGroupDisplay = function () {\n        var _this = this;\n        this.groupDisplayColumns = [];\n        var checkFunc = function (col) {\n            var colDef = col.getColDef();\n            if (colDef && utils_1._.exists(colDef.showRowGroup)) {\n                _this.groupDisplayColumns.push(col);\n            }\n        };\n        this.gridColumns.forEach(checkFunc);\n        if (this.groupAutoColumns) {\n            this.groupAutoColumns.forEach(checkFunc);\n        }\n    };\n    ColumnController.prototype.getGroupDisplayColumns = function () {\n        return this.groupDisplayColumns;\n    };\n    ColumnController.prototype.updateDisplayedColumns = function (source) {\n        var columnsForDisplay = this.calculateColumnsForDisplay();\n        this.buildDisplayedTrees(columnsForDisplay);\n        this.calculateColumnsForGroupDisplay();\n        // also called when group opened/closed\n        this.updateGroupsAndDisplayedColumns(source);\n        // also called when group opened/closed\n        this.setFirstRightAndLastLeftPinned(source);\n    };\n    ColumnController.prototype.isSecondaryColumnsPresent = function () {\n        return this.secondaryColumnsPresent;\n    };\n    ColumnController.prototype.setSecondaryColumns = function (colDefs, source) {\n        if (source === void 0) { source = \"api\"; }\n        var newColsPresent = colDefs && colDefs.length > 0;\n        // if not cols passed, and we had to cols anyway, then do nothing\n        if (!newColsPresent && !this.secondaryColumnsPresent) {\n            return;\n        }\n        if (newColsPresent) {\n            this.processSecondaryColumnDefinitions(colDefs);\n            var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n            this.secondaryBalancedTree = balancedTreeResult.columnTree;\n            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n            this.secondaryColumnsPresent = true;\n        }\n        else {\n            this.secondaryBalancedTree = null;\n            this.secondaryHeaderRowCount = -1;\n            this.secondaryColumns = null;\n            this.secondaryColumnsPresent = false;\n        }\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n    };\n    ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n        var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n        var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n        if (!columnCallback && !groupCallback) {\n            return undefined;\n        }\n        if (colDefs) {\n            searchForColDefs(colDefs);\n        }\n        function searchForColDefs(colDefs2) {\n            colDefs2.forEach(function (abstractColDef) {\n                var isGroup = utils_1._.exists(abstractColDef.children);\n                if (isGroup) {\n                    var colGroupDef = abstractColDef;\n                    if (groupCallback) {\n                        groupCallback(colGroupDef);\n                    }\n                    searchForColDefs(colGroupDef.children);\n                }\n                else {\n                    var colDef = abstractColDef;\n                    if (columnCallback) {\n                        columnCallback(colDef);\n                    }\n                }\n            });\n        }\n    };\n    // called from: setColumnState, setColumnDefs, setSecondaryColumns\n    ColumnController.prototype.updateGridColumns = function () {\n        if (this.gridColsArePrimary) {\n            this.lastPrimaryOrder = this.gridColumns;\n        }\n        if (this.secondaryColumns && this.secondaryBalancedTree) {\n            this.gridBalancedTree = this.secondaryBalancedTree.slice();\n            this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n            this.gridColumns = this.secondaryColumns.slice();\n            this.gridColsArePrimary = false;\n        }\n        else {\n            this.gridBalancedTree = this.primaryColumnTree.slice();\n            this.gridHeaderRowCount = this.primaryHeaderRowCount;\n            this.gridColumns = this.primaryColumns.slice();\n            this.gridColsArePrimary = true;\n            // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n            // when this happens (eg if user moved a column) rather than revert back to the original column order.\n            // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n            this.orderGridColsLikeLastPrimary();\n        }\n        this.addAutoGroupToGridColumns();\n        this.autoRowHeightColumns = this.gridColumns.filter(function (col) { return col.getColDef().autoHeight; });\n        this.putFixedColumnsFirst();\n        this.setupQuickFilterColumns();\n        this.clearDisplayedColumns();\n        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n        var event = {\n            type: events_1.Events.EVENT_GRID_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.orderGridColsLikeLastPrimary = function () {\n        var _this = this;\n        if (utils_1._.missing(this.lastPrimaryOrder)) {\n            return;\n        }\n        // only do the sort if at least one column is accounted for. columns will be not accounted for\n        // if changing from secondary to primary columns\n        var noColsFound = true;\n        this.gridColumns.forEach(function (col) {\n            if (_this.lastPrimaryOrder.indexOf(col) >= 0) {\n                noColsFound = false;\n            }\n        });\n        if (noColsFound) {\n            return;\n        }\n        // order cols in the same order as before. we need to make sure that all\n        // cols still exists, so filter out any that no longer exist.\n        var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) { return _this.gridColumns.indexOf(col) >= 0; });\n        var newColsOrdered = this.gridColumns.filter(function (col) { return oldColsOrdered.indexOf(col) < 0; });\n        // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n        var newGridColumns = oldColsOrdered.slice();\n        newColsOrdered.forEach(function (newCol) {\n            var parent = newCol.getOriginalParent();\n            // if no parent, means we are not grouping, so just add the column to the end\n            if (!parent) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n            // own) then go up one level and look for siblings there.\n            var siblings = [];\n            while (!siblings.length && parent) {\n                var leafCols = parent.getLeafColumns();\n                leafCols.forEach(function (leafCol) {\n                    var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n                    var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n                    if (presentInNewGriColumns && noYetInSiblings) {\n                        siblings.push(leafCol);\n                    }\n                });\n                parent = parent.getOriginalParent();\n            }\n            // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n            if (!siblings.length) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find index of last column in the group\n            var indexes = siblings.map(function (col) { return newGridColumns.indexOf(col); });\n            var lastIndex = Math.max.apply(Math, indexes);\n            utils_1._.insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n        });\n        this.gridColumns = newGridColumns;\n    };\n    ColumnController.prototype.isPrimaryColumnGroupsPresent = function () {\n        return this.primaryHeaderRowCount > 1;\n    };\n    // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n    // following scenarios:\n    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n    ColumnController.prototype.setupQuickFilterColumns = function () {\n        if (this.groupAutoColumns) {\n            this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n        }\n        else {\n            this.columnsForQuickFilter = this.primaryColumns;\n        }\n    };\n    ColumnController.prototype.putFixedColumnsFirst = function () {\n        var locked = this.gridColumns.filter(function (c) { return c.getColDef().lockPosition; });\n        var unlocked = this.gridColumns.filter(function (c) { return !c.getColDef().lockPosition; });\n        this.gridColumns = locked.concat(unlocked);\n    };\n    ColumnController.prototype.addAutoGroupToGridColumns = function () {\n        // add in auto-group here\n        this.createGroupAutoColumnsIfNeeded();\n        if (utils_1._.missing(this.groupAutoColumns)) {\n            return;\n        }\n        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n        var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n        this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n    };\n    // gets called after we copy down grid columns, to make sure any part of the gui\n    // that tries to draw, eg the header, it will get empty lists of columns rather\n    // than stale columns. for example, the header will received gridColumnsChanged\n    // event, so will try and draw, but it will draw successfully when it acts on the\n    // virtualColumnsChanged event\n    ColumnController.prototype.clearDisplayedColumns = function () {\n        this.displayedLeftColumnTree = [];\n        this.displayedRightColumnTree = [];\n        this.displayedCentreColumnTree = [];\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n        this.displayedLeftColumns = [];\n        this.displayedRightColumns = [];\n        this.displayedCenterColumns = [];\n        this.allDisplayedColumns = [];\n        this.allDisplayedVirtualColumns = [];\n    };\n    ColumnController.prototype.updateGroupsAndDisplayedColumns = function (source) {\n        this.updateOpenClosedVisibilityInColumnGroups();\n        this.updateDisplayedColumnsFromTrees(source);\n        this.updateVirtualSets();\n        this.updateBodyWidths();\n        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n        var event = {\n            type: events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.updateDisplayedColumnsFromTrees = function (source) {\n        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);\n        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);\n        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);\n        this.setupAllDisplayedColumns();\n        this.setLeftValues(source);\n    };\n    ColumnController.prototype.setupAllDisplayedColumns = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.allDisplayedColumns = this.displayedRightColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedLeftColumns);\n        }\n        else {\n            this.allDisplayedColumns = this.displayedLeftColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedRightColumns);\n        }\n    };\n    // sets the left pixel position of each column\n    ColumnController.prototype.setLeftValues = function (source) {\n        this.setLeftValuesOfColumns(source);\n        this.setLeftValuesOfGroups();\n    };\n    ColumnController.prototype.setLeftValuesOfColumns = function (source) {\n        var _this = this;\n        // go through each list of displayed columns\n        var allColumns = this.primaryColumns.slice(0);\n        // let totalColumnWidth = this.getWidthOfColsInList()\n        var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n        [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {\n            if (doingRtl) {\n                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n                var left_1 = _this.getWidthOfColsInList(columns);\n                columns.forEach(function (column) {\n                    left_1 -= column.getActualWidth();\n                    column.setLeft(left_1, source);\n                });\n            }\n            else {\n                // otherwise normal LTR, we start at zero\n                var left_2 = 0;\n                columns.forEach(function (column) {\n                    column.setLeft(left_2, source);\n                    left_2 += column.getActualWidth();\n                });\n            }\n            utils_1._.removeAllFromArray(allColumns, columns);\n        });\n        // items left in allColumns are columns not displayed, so remove the left position. this is\n        // important for the rows, as if a col is made visible, then taken out, then made visible again,\n        // we don't want the animation of the cell floating in from the old position, whatever that was.\n        allColumns.forEach(function (column) {\n            column.setLeft(null, source);\n        });\n    };\n    ColumnController.prototype.setLeftValuesOfGroups = function () {\n        // a groups left value is the lest left value of it's children\n        [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {\n            columns.forEach(function (column) {\n                if (column instanceof columnGroup_1.ColumnGroup) {\n                    var columnGroup = column;\n                    columnGroup.checkLeft();\n                }\n            });\n        });\n    };\n    ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {\n        displayedColumns.length = 0;\n        this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {\n            if (child instanceof column_1.Column) {\n                displayedColumns.push(child);\n            }\n        });\n    };\n    ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {\n        if (this.suppressColumnVirtualisation) {\n            // no virtualisation, so don't filter\n            this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;\n        }\n        else {\n            // filter out what should be visible\n            this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();\n        }\n        this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns\n            .concat(this.displayedLeftColumns)\n            .concat(this.displayedRightColumns);\n        // return map of virtual col id's, for easy lookup when building the groups.\n        // the map will be colId=>true, ie col id's mapping to 'true'.\n        var result = {};\n        this.allDisplayedVirtualColumns.forEach(function (col) {\n            result[col.getId()] = true;\n        });\n        return result;\n    };\n    ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n        var result;\n        switch (type) {\n            case column_1.Column.PINNED_LEFT:\n                result = this.displayedLeftHeaderRows[dept];\n                break;\n            case column_1.Column.PINNED_RIGHT:\n                result = this.displayedRightHeaderRows[dept];\n                break;\n            default:\n                result = this.displayedCentreHeaderRows[dept];\n                break;\n        }\n        if (utils_1._.missing(result)) {\n            result = [];\n        }\n        return result;\n    };\n    ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {\n        // go through each group, see if any of it's cols are displayed, and if yes,\n        // then this group is included\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n        testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);\n        testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);\n        testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);\n        function testGroup(children, result, dept) {\n            var returnValue = false;\n            for (var i = 0; i < children.length; i++) {\n                // see if this item is within viewport\n                var child = children[i];\n                var addThisItem = void 0;\n                if (child instanceof column_1.Column) {\n                    // for column, test if column is included\n                    addThisItem = virtualColIds[child.getId()] === true;\n                }\n                else {\n                    // if group, base decision on children\n                    var columnGroup = child;\n                    addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);\n                }\n                if (addThisItem) {\n                    returnValue = true;\n                    if (!result[dept]) {\n                        result[dept] = [];\n                    }\n                    result[dept].push(child);\n                }\n            }\n            return returnValue;\n        }\n    };\n    ColumnController.prototype.updateVirtualSets = function () {\n        var virtualColIds = this.updateDisplayedCenterVirtualColumns();\n        this.updateDisplayedVirtualGroups(virtualColIds);\n    };\n    ColumnController.prototype.filterOutColumnsWithinViewport = function () {\n        return utils_1._.filter(this.displayedCenterColumns, this.isColumnInViewport.bind(this));\n    };\n    // called from api\n    ColumnController.prototype.sizeColumnsToFit = function (gridWidth, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        // avoid divide by zero\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        if (gridWidth <= 0 || allDisplayedColumns.length === 0) {\n            return;\n        }\n        var colsToNotSpread = utils_1._.filter(allDisplayedColumns, function (column) {\n            return column.getColDef().suppressSizeToFit === true;\n        });\n        var colsToSpread = utils_1._.filter(allDisplayedColumns, function (column) {\n            return column.getColDef().suppressSizeToFit !== true;\n        });\n        // make a copy of the cols that are going to be resized\n        var colsToFireEventFor = colsToSpread.slice(0);\n        var finishedResizing = false;\n        while (!finishedResizing) {\n            finishedResizing = true;\n            var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n            if (availablePixels <= 0) {\n                // no width, set everything to minimum\n                colsToSpread.forEach(function (column) {\n                    column.setMinimum(source);\n                });\n            }\n            else {\n                var scale = availablePixels / this.getWidthOfColsInList(colsToSpread);\n                // we set the pixels for the last col based on what's left, as otherwise\n                // we could be a pixel or two short or extra because of rounding errors.\n                var pixelsForLastCol = availablePixels;\n                // backwards through loop, as we are removing items as we go\n                for (var i = colsToSpread.length - 1; i >= 0; i--) {\n                    var column = colsToSpread[i];\n                    var newWidth = Math.round(column.getActualWidth() * scale);\n                    if (newWidth < column.getMinWidth()) {\n                        column.setMinimum(source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else if (column.isGreaterThanMax(newWidth)) {\n                        column.setActualWidth(column.getMaxWidth(), source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else {\n                        var onLastCol = i === 0;\n                        if (onLastCol) {\n                            column.setActualWidth(pixelsForLastCol, source);\n                        }\n                        else {\n                            column.setActualWidth(newWidth, source);\n                        }\n                    }\n                    pixelsForLastCol -= newWidth;\n                }\n            }\n        }\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n        colsToFireEventFor.forEach(function (column) {\n            var event = {\n                type: events_1.Events.EVENT_COLUMN_RESIZED,\n                column: column,\n                columns: [column],\n                finished: true,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: \"sizeColumnsToFit\"\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n        function moveToNotSpread(column) {\n            utils_1._.removeFromArray(colsToSpread, column);\n            colsToNotSpread.push(column);\n        }\n    };\n    ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {\n        var leftVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n            return column.getPinned() === 'left';\n        });\n        var rightVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n            return column.getPinned() === 'right';\n        });\n        var centerVisibleColumns = utils_1._.filter(visibleColumns, function (column) {\n            return column.getPinned() !== 'left' && column.getPinned() !== 'right';\n        });\n        var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();\n        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, column_1.Column.PINNED_LEFT, this.displayedLeftColumnTree);\n        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, column_1.Column.PINNED_RIGHT, this.displayedRightColumnTree);\n        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedCentreColumnTree);\n    };\n    ColumnController.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n        var allColumnGroups = this.getAllDisplayedColumnGroups();\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof columnGroup_1.ColumnGroup) {\n                var columnGroup = child;\n                columnGroup.calculateDisplayedColumns();\n            }\n        });\n    };\n    ColumnController.prototype.getGroupAutoColumns = function () {\n        return this.groupAutoColumns;\n    };\n    ColumnController.prototype.createGroupAutoColumnsIfNeeded = function () {\n        if (!this.autoGroupsNeedBuilding) {\n            return;\n        }\n        this.autoGroupsNeedBuilding = false;\n        var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode);\n        // we never suppress auto col for pivot mode, as there is no way for user to provide group columns\n        // in pivot mode. pivot mode has auto group column (provide by grid) and value columns (provided by\n        // pivot feature in the grid).\n        var groupSuppressAutoColumn = this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.pivotMode;\n        var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n        var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n        var needAutoColumns = groupingActive && !groupSuppressAutoColumn && !groupFullWidthRow && !groupSuppressRow;\n        if (needAutoColumns) {\n            var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n            var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n            if (autoColsDifferent) {\n                this.groupAutoColumns = newAutoGroupCols;\n            }\n        }\n        else {\n            this.groupAutoColumns = null;\n        }\n    };\n    ColumnController.prototype.autoColsEqual = function (colsA, colsB) {\n        var bothMissing = !colsA && !colsB;\n        if (bothMissing) {\n            return true;\n        }\n        var atLeastOneListMissing = !colsA || !colsB;\n        if (atLeastOneListMissing) {\n            return false;\n        }\n        if (colsA.length !== colsB.length) {\n            return false;\n        }\n        for (var i = 0; i < colsA.length; i++) {\n            var colA = colsA[i];\n            var colB = colsB[i];\n            if (colA.getColId() !== colB.getColId()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    ColumnController.prototype.getWidthOfColsInList = function (columnList) {\n        var result = 0;\n        for (var i = 0; i < columnList.length; i++) {\n            result += columnList[i].getActualWidth();\n        }\n        return result;\n    };\n    ColumnController.prototype.getGridBalancedTree = function () {\n        return this.gridBalancedTree;\n    };\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], ColumnController.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired('expressionService'),\n        __metadata(\"design:type\", expressionService_1.ExpressionService)\n    ], ColumnController.prototype, \"expressionService\", void 0);\n    __decorate([\n        context_1.Autowired('columnFactory'),\n        __metadata(\"design:type\", columnFactory_1.ColumnFactory)\n    ], ColumnController.prototype, \"columnFactory\", void 0);\n    __decorate([\n        context_1.Autowired('displayedGroupCreator'),\n        __metadata(\"design:type\", displayedGroupCreator_1.DisplayedGroupCreator)\n    ], ColumnController.prototype, \"displayedGroupCreator\", void 0);\n    __decorate([\n        context_1.Autowired('autoWidthCalculator'),\n        __metadata(\"design:type\", autoWidthCalculator_1.AutoWidthCalculator)\n    ], ColumnController.prototype, \"autoWidthCalculator\", void 0);\n    __decorate([\n        context_1.Autowired('eventService'),\n        __metadata(\"design:type\", eventService_1.EventService)\n    ], ColumnController.prototype, \"eventService\", void 0);\n    __decorate([\n        context_1.Autowired('columnUtils'),\n        __metadata(\"design:type\", columnUtils_1.ColumnUtils)\n    ], ColumnController.prototype, \"columnUtils\", void 0);\n    __decorate([\n        context_1.Autowired('context'),\n        __metadata(\"design:type\", context_1.Context)\n    ], ColumnController.prototype, \"context\", void 0);\n    __decorate([\n        context_1.Autowired('columnAnimationService'),\n        __metadata(\"design:type\", columnAnimationService_1.ColumnAnimationService)\n    ], ColumnController.prototype, \"columnAnimationService\", void 0);\n    __decorate([\n        context_1.Autowired('autoGroupColService'),\n        __metadata(\"design:type\", autoGroupColService_1.AutoGroupColService)\n    ], ColumnController.prototype, \"autoGroupColService\", void 0);\n    __decorate([\n        context_1.Optional('aggFuncService'),\n        __metadata(\"design:type\", Object)\n    ], ColumnController.prototype, \"aggFuncService\", void 0);\n    __decorate([\n        context_1.Optional('valueCache'),\n        __metadata(\"design:type\", valueCache_1.ValueCache)\n    ], ColumnController.prototype, \"valueCache\", void 0);\n    __decorate([\n        context_1.Autowired('columnApi'),\n        __metadata(\"design:type\", columnApi_1.ColumnApi)\n    ], ColumnController.prototype, \"columnApi\", void 0);\n    __decorate([\n        context_1.Autowired('gridApi'),\n        __metadata(\"design:type\", gridApi_1.GridApi)\n    ], ColumnController.prototype, \"gridApi\", void 0);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], ColumnController.prototype, \"init\", null);\n    __decorate([\n        __param(0, context_1.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], ColumnController.prototype, \"setBeans\", null);\n    ColumnController = __decorate([\n        context_1.Bean('columnController')\n    ], ColumnController);\n    return ColumnController;\n}());\nexports.ColumnController = ColumnController;\n"]},"metadata":{},"sourceType":"script"}