{"ast":null,"code":"/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport { abstract } from '../../util.js';\nimport { scale as scaleCoordinate } from '../../coordinate.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { create as createTransform, apply as applyTransform } from '../../transform.js';\n/**\n * @abstract\n */\n\nvar IntermediateCanvasRenderer =\n/*@__PURE__*/\nfunction (CanvasLayerRenderer) {\n  function IntermediateCanvasRenderer(layer) {\n    CanvasLayerRenderer.call(this, layer);\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    this.coordinateToCanvasPixelTransform = createTransform();\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitCanvasContext_ = null;\n  }\n\n  if (CanvasLayerRenderer) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;\n  IntermediateCanvasRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    this.preCompose(context, frameState);\n    var image = this.getImage();\n\n    if (image) {\n      // clipped rendering if layer extent is set\n      var extent = layerState.extent;\n      var clipped = extent !== undefined && !containsExtent(extent, frameState.extent) && intersects(extent, frameState.extent);\n\n      if (clipped) {\n        this.clip(context, frameState,\n        /** @type {import(\"../../extent.js\").Extent} */\n        extent);\n      }\n\n      var imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n\n      var dx = imageTransform[4];\n      var dy = imageTransform[5];\n      var dw = image.width * imageTransform[0];\n      var dh = image.height * imageTransform[3];\n\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n\n      context.globalAlpha = alpha;\n\n      if (clipped) {\n        context.restore();\n      }\n    }\n\n    this.postCompose(context, frameState, layerState);\n  };\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n\n\n  IntermediateCanvasRenderer.prototype.getImage = function getImage() {\n    return abstract();\n  };\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n\n\n  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform() {\n    return abstract();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n\n    var pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  };\n\n  return IntermediateCanvasRenderer;\n}(CanvasLayerRenderer);\n\nexport default IntermediateCanvasRenderer;","map":{"version":3,"sources":["../../../../src/ol/renderer/canvas/IntermediateCanvas.js"],"names":["super","const"],"mappings":"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","sourcesContent":["/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport {abstract} from '../../util.js';\nimport {scale as scaleCoordinate} from '../../coordinate.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, intersects} from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport {create as createTransform, apply as applyTransform} from '../../transform.js';\n\n/**\n * @abstract\n */\nclass IntermediateCanvasRenderer extends CanvasLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   */\n  constructor(layer) {\n\n    super(layer);\n\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToCanvasPixelTransform = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  composeFrame(frameState, layerState, context) {\n\n    this.preCompose(context, frameState);\n\n    const image = this.getImage();\n    if (image) {\n\n      // clipped rendering if layer extent is set\n      const extent = layerState.extent;\n      const clipped = extent !== undefined &&\n          !containsExtent(extent, frameState.extent) &&\n          intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */ (extent));\n      }\n\n      const imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      const alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n\n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      const dx = imageTransform[4];\n      const dy = imageTransform[5];\n      const dw = image.width * imageTransform[0];\n      const dh = image.height * imageTransform[3];\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height,\n          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n      context.globalAlpha = alpha;\n\n      if (clipped) {\n        context.restore();\n      }\n    }\n\n    this.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n  getImage() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n  getImageTransform() {\n    return abstract();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n\n    const imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  }\n}\n\n\nexport default IntermediateCanvasRenderer;\n"]},"metadata":{},"sourceType":"module"}