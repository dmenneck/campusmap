{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar eventService_1 = require(\"../eventService\");\n\nvar rowComp_1 = require(\"./rowComp\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar events_1 = require(\"../events\");\n\nvar constants_1 = require(\"../constants\");\n\nvar cellComp_1 = require(\"./cellComp\");\n\nvar context_1 = require(\"../context/context\");\n\nvar columnApi_1 = require(\"../columnController/columnApi\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar logger_1 = require(\"../logger\");\n\nvar focusedCellController_1 = require(\"../focusedCellController\");\n\nvar cellNavigationService_1 = require(\"../cellNavigationService\");\n\nvar beanStub_1 = require(\"../context/beanStub\");\n\nvar paginationProxy_1 = require(\"../rowModels/paginationProxy\");\n\nvar gridApi_1 = require(\"../gridApi\");\n\nvar pinnedRowModel_1 = require(\"../rowModels/pinnedRowModel\");\n\nvar beans_1 = require(\"./beans\");\n\nvar animationFrameService_1 = require(\"../misc/animationFrameService\");\n\nvar maxDivHeightScaler_1 = require(\"./maxDivHeightScaler\");\n\nvar utils_1 = require(\"../utils\");\n\nvar rowPosition_1 = require(\"../entities/rowPosition\");\n\nvar RowRenderer =\n/** @class */\nfunction (_super) {\n  __extends(RowRenderer, _super);\n\n  function RowRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.destroyFuncsForColumnListeners = []; // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n\n    _this.rowCompsByIndex = {};\n    _this.floatingTopRowComps = [];\n    _this.floatingBottomRowComps = []; // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n\n    _this.refreshInProgress = false;\n    return _this;\n  }\n\n  RowRenderer.prototype.registerGridCore = function (gridCore) {\n    this.gridCore = gridCore;\n  };\n\n  RowRenderer.prototype.getGridCore = function () {\n    return this.gridCore;\n  };\n\n  RowRenderer.prototype.agWire = function (loggerFactory) {\n    this.logger = loggerFactory.create(\"RowRenderer\");\n  };\n\n  RowRenderer.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n    this.rowContainers = this.gridPanel.getRowContainers();\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n    this.registerCellEventListeners();\n    this.printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n    this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n    this.redrawAfterModelUpdate();\n  }; // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n  // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n  // all active cells.\n\n\n  RowRenderer.prototype.registerCellEventListeners = function () {\n    var _this = this;\n\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_CELL_FOCUSED, function (event) {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onCellFocused(event);\n      });\n    });\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_FLASH_CELLS, function (event) {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onFlashCells(event);\n      });\n    });\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onColumnHover();\n      });\n    }); // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n    // then changing the width of the containers will impact left position. eg the center cols all have their\n    // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n    // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n    // in different containers so doesn't impact.\n\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n      if (_this.printLayout) {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.onLeftChanged();\n        });\n      }\n    });\n    var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n\n    if (rangeSelectionEnabled) {\n      this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.onRangeSelectionChanged();\n        });\n      });\n      this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_MOVED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_PINNED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_VISIBLE, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n    } // add listeners to the grid columns\n\n\n    this.refreshListenersToColumnsForCellComps(); // if the grid columns change, then refresh the listeners again\n\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n  }; // executes all functions in destroyFuncsForColumnListeners and then clears the list\n\n\n  RowRenderer.prototype.removeGridColumnListeners = function () {\n    this.destroyFuncsForColumnListeners.forEach(function (func) {\n      return func();\n    });\n    this.destroyFuncsForColumnListeners.length = 0;\n  }; // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n  // once instead.\n\n\n  RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n    var _this = this;\n\n    this.removeGridColumnListeners();\n    var cols = this.columnController.getAllGridColumns();\n\n    if (!cols) {\n      return;\n    }\n\n    cols.forEach(function (col) {\n      var forEachCellWithThisCol = function (callback) {\n        _this.forEachCellComp(function (cellComp) {\n          if (cellComp.getColumn() === col) {\n            callback(cellComp);\n          }\n        });\n      };\n\n      var leftChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onLeftChanged();\n        });\n      };\n\n      var widthChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onWidthChanged();\n        });\n      };\n\n      var firstRightPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onFirstRightPinnedChanged();\n        });\n      };\n\n      var lastLeftPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onLastLeftPinnedChanged();\n        });\n      };\n\n      col.addEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);\n      col.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n      col.addEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n      col.addEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n      _this.destroyFuncsForColumnListeners.push(function () {\n        col.removeEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);\n        col.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n        col.removeEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n        col.removeEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n      });\n    });\n  };\n\n  RowRenderer.prototype.onDomLayoutChanged = function () {\n    var printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n    var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows(); // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n    // out using absolute positioning when doing print layout\n\n    var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n    this.printLayout = printLayout;\n    this.embedFullWidthRows = embedFullWidthRows;\n\n    if (destroyRows) {\n      this.redrawAfterModelUpdate();\n    }\n  }; // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n\n\n  RowRenderer.prototype.datasourceChanged = function () {\n    this.firstRenderedRow = 0;\n    this.lastRenderedRow = -1;\n    var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n    this.removeRowComps(rowIndexesToRemove);\n  };\n\n  RowRenderer.prototype.onPageLoaded = function (refreshEvent) {\n    if (utils_1._.missing(refreshEvent)) {\n      refreshEvent = {\n        type: events_1.Events.EVENT_MODEL_UPDATED,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        animate: false,\n        keepRenderedRows: false,\n        newData: false,\n        newPage: false\n      };\n    }\n\n    this.onModelUpdated(refreshEvent);\n  };\n\n  RowRenderer.prototype.getAllCellsForColumn = function (column) {\n    var eCells = [];\n\n    utils_1._.iterateObject(this.rowCompsByIndex, callback);\n\n    utils_1._.iterateObject(this.floatingBottomRowComps, callback);\n\n    utils_1._.iterateObject(this.floatingTopRowComps, callback);\n\n    function callback(key, rowComp) {\n      var eCell = rowComp.getCellForCol(column);\n\n      if (eCell) {\n        eCells.push(eCell);\n      }\n    }\n\n    return eCells;\n  };\n\n  RowRenderer.prototype.refreshFloatingRowComps = function () {\n    this.refreshFloatingRows(this.floatingTopRowComps, this.pinnedRowModel.getPinnedTopRowData(), this.rowContainers.floatingTopPinnedLeft, this.rowContainers.floatingTopPinnedRight, this.rowContainers.floatingTop, this.rowContainers.floatingTopFullWidth);\n    this.refreshFloatingRows(this.floatingBottomRowComps, this.pinnedRowModel.getPinnedBottomRowData(), this.rowContainers.floatingBottomPinnedLeft, this.rowContainers.floatingBottomPinnedRight, this.rowContainers.floatingBottom, this.rowContainers.floatingBottomFullWith);\n  };\n\n  RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes, pinnedLeftContainerComp, pinnedRightContainerComp, bodyContainerComp, fullWidthContainerComp) {\n    var _this = this;\n\n    rowComps.forEach(function (row) {\n      row.destroy();\n    });\n    rowComps.length = 0;\n\n    if (rowNodes) {\n      rowNodes.forEach(function (node) {\n        var rowComp = new rowComp_1.RowComp(_this.$scope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, node, _this.beans, false, false, _this.printLayout, _this.embedFullWidthRows);\n        rowComp.init();\n        rowComps.push(rowComp);\n      });\n    }\n\n    this.flushContainers(rowComps);\n  };\n\n  RowRenderer.prototype.onPinnedRowDataChanged = function () {\n    // recycling rows in order to ensure cell editing is not cancelled\n    var params = {\n      recycleRows: true\n    };\n    this.redrawAfterModelUpdate(params);\n  };\n\n  RowRenderer.prototype.onModelUpdated = function (refreshEvent) {\n    var params = {\n      recycleRows: refreshEvent.keepRenderedRows,\n      animate: refreshEvent.animate,\n      newData: refreshEvent.newData,\n      newPage: refreshEvent.newPage,\n      // because this is a model updated event (not pinned rows), we\n      // can skip updating the pinned rows. this is needed so that if user\n      // is doing transaction updates, the pinned rows are not getting constantly\n      // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n      onlyBody: true\n    };\n    this.redrawAfterModelUpdate(params);\n  }; // if the row nodes are not rendered, no index is returned\n\n\n  RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n    var result = [];\n\n    if (utils_1._.missing(rowNodes)) {\n      return result;\n    }\n\n    utils_1._.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {\n      var rowNode = renderedRow.getRowNode();\n\n      if (rowNodes.indexOf(rowNode) >= 0) {\n        result.push(index);\n      }\n    });\n\n    return result;\n  };\n\n  RowRenderer.prototype.redrawRows = function (rowNodes) {\n    if (!rowNodes || rowNodes.length == 0) {\n      return;\n    } // we only need to be worried about rendered rows, as this method is\n    // called to what's rendered. if the row isn't rendered, we don't care\n\n\n    var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes); // remove the rows\n\n    this.removeRowComps(indexesToRemove); // add draw them again\n\n    this.redrawAfterModelUpdate({\n      recycleRows: true\n    });\n  };\n\n  RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n    var focusedCell = params.suppressKeepFocus ? null : this.focusedCellController.getFocusCellToUseAfterRefresh();\n\n    if (utils_1._.missing(focusedCell)) {\n      return null;\n    } // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n    // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n    // cell itself, then the cell can be registered as having focus, however it's the text field that\n    // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n    // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n    // the focus is lost from the text field. we do not want this.\n\n\n    var activeElement = document.activeElement;\n    var domData = this.gridOptionsWrapper.getDomData(activeElement, cellComp_1.CellComp.DOM_DATA_KEY_CELL_COMP);\n\n    var elementIsNotACellDev = utils_1._.missing(domData);\n\n    if (elementIsNotACellDev) {\n      return null;\n    }\n\n    return focusedCell;\n  }; // gets called after changes to the model.\n\n\n  RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    this.getLockOnRefresh();\n    var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n    this.sizeContainerToPageHeight();\n    this.scrollToTopIfNewData(params); // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n    // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n\n    var recycleRows = !this.printLayout && params.recycleRows;\n    var animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n    var rowsToRecycle = this.binRowComps(recycleRows);\n    this.redraw(rowsToRecycle, animate);\n\n    if (!params.onlyBody) {\n      this.refreshFloatingRowComps();\n    }\n\n    this.restoreFocusedCell(focusedCell);\n    this.releaseLockOnRefresh();\n  };\n\n  RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n    var scrollToTop = params.newData || params.newPage;\n    var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n\n    if (scrollToTop && !suppressScrollToTop) {\n      this.gridPanel.scrollToTop();\n    }\n  };\n\n  RowRenderer.prototype.sizeContainerToPageHeight = function () {\n    var containers = [this.rowContainers.body, this.rowContainers.fullWidth, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight];\n\n    if (this.printLayout) {\n      containers.forEach(function (container) {\n        return container.setHeight(null);\n      });\n      return;\n    }\n\n    var containerHeight = this.paginationProxy.getCurrentPageHeight(); // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n    // we still want the scroll to be present, otherwise there would be no way to scroll the header\n    // which might be needed us user wants to access columns\n    // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n    // is no way to remove the filter.\n\n    if (containerHeight === 0) {\n      containerHeight = 1;\n    }\n\n    this.maxDivHeightScaler.setModelHeight(containerHeight);\n    var realHeight = this.maxDivHeightScaler.getUiContainerHeight();\n    containers.forEach(function (container) {\n      return container.setHeight(realHeight);\n    });\n  };\n\n  RowRenderer.prototype.getLockOnRefresh = function () {\n    if (this.refreshInProgress) {\n      throw new Error(\"ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" + \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" + \"this, put the API call into a timeout, eg instead of api.refreshView(), \" + \"call setTimeout(function(){api.refreshView(),0}). To see what part of your code \" + \"that caused the refresh check this stacktrace.\");\n    }\n\n    this.refreshInProgress = true;\n  };\n\n  RowRenderer.prototype.releaseLockOnRefresh = function () {\n    this.refreshInProgress = false;\n  }; // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n  // edited cell).\n\n\n  RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n    if (cellPosition) {\n      this.focusedCellController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n    }\n  };\n\n  RowRenderer.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    this.forEachRowComp(function (key, rowComp) {\n      rowComp.stopEditing(cancel);\n    });\n  };\n\n  RowRenderer.prototype.forEachCellComp = function (callback) {\n    this.forEachRowComp(function (key, rowComp) {\n      return rowComp.forEachCellComp(callback);\n    });\n  };\n\n  RowRenderer.prototype.forEachRowComp = function (callback) {\n    utils_1._.iterateObject(this.rowCompsByIndex, callback);\n\n    utils_1._.iterateObject(this.floatingTopRowComps, callback);\n\n    utils_1._.iterateObject(this.floatingBottomRowComps, callback);\n  };\n\n  RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n    var rowComp = this.rowCompsByIndex[rowIndex];\n\n    if (rowComp) {\n      rowComp.addEventListener(eventName, callback);\n    }\n  };\n\n  RowRenderer.prototype.flashCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      return cellComp.flashCell();\n    });\n  };\n\n  RowRenderer.prototype.refreshCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var refreshCellParams = {\n      forceRefresh: params.force,\n      newData: false\n    };\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      return cellComp.refreshCell(refreshCellParams);\n    });\n  };\n\n  RowRenderer.prototype.getCellRendererInstances = function (params) {\n    var res = [];\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      var cellRenderer = cellComp.getCellRenderer();\n\n      if (cellRenderer) {\n        res.push(cellRenderer);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getCellEditorInstances = function (params) {\n    var res = [];\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      var cellEditor = cellComp.getCellEditor();\n\n      if (cellEditor) {\n        res.push(cellEditor);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getEditingCells = function () {\n    var res = [];\n    this.forEachCellComp(function (cellComp) {\n      if (cellComp.isEditing()) {\n        var cellPosition = cellComp.getCellPosition();\n        res.push(cellPosition);\n      }\n    });\n    return res;\n  }; // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n  // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n\n\n  RowRenderer.prototype.forEachCellCompFiltered = function (rowNodes, columns, callback) {\n    var _this = this;\n\n    var rowIdsMap;\n\n    if (utils_1._.exists(rowNodes)) {\n      rowIdsMap = {\n        top: {},\n        bottom: {},\n        normal: {}\n      };\n      rowNodes.forEach(function (rowNode) {\n        if (rowNode.rowPinned === constants_1.Constants.PINNED_TOP) {\n          rowIdsMap.top[rowNode.id] = true;\n        } else if (rowNode.rowPinned === constants_1.Constants.PINNED_BOTTOM) {\n          rowIdsMap.bottom[rowNode.id] = true;\n        } else {\n          rowIdsMap.normal[rowNode.id] = true;\n        }\n      });\n    }\n\n    var colIdsMap;\n\n    if (utils_1._.exists(columns)) {\n      colIdsMap = {};\n      columns.forEach(function (colKey) {\n        var column = _this.columnController.getGridColumn(colKey);\n\n        if (utils_1._.exists(column)) {\n          colIdsMap[column.getId()] = true;\n        }\n      });\n    }\n\n    var processRow = function (rowComp) {\n      var rowNode = rowComp.getRowNode();\n      var id = rowNode.id;\n      var floating = rowNode.rowPinned; // skip this row if it is missing from the provided list\n\n      if (utils_1._.exists(rowIdsMap)) {\n        if (floating === constants_1.Constants.PINNED_BOTTOM) {\n          if (!rowIdsMap.bottom[id]) {\n            return;\n          }\n        } else if (floating === constants_1.Constants.PINNED_TOP) {\n          if (!rowIdsMap.top[id]) {\n            return;\n          }\n        } else {\n          if (!rowIdsMap.normal[id]) {\n            return;\n          }\n        }\n      }\n\n      rowComp.forEachCellComp(function (cellComp) {\n        var colId = cellComp.getColumn().getId();\n        var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n\n        if (excludeColFromRefresh) {\n          return;\n        }\n\n        callback(cellComp);\n      });\n    };\n\n    utils_1._.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n      processRow(rowComp);\n    });\n\n    if (this.floatingTopRowComps) {\n      this.floatingTopRowComps.forEach(processRow);\n    }\n\n    if (this.floatingBottomRowComps) {\n      this.floatingBottomRowComps.forEach(processRow);\n    }\n  };\n\n  RowRenderer.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n    this.removeRowComps(rowIndexesToRemove);\n  };\n\n  RowRenderer.prototype.binRowComps = function (recycleRows) {\n    var _this = this;\n\n    var indexesToRemove;\n    var rowsToRecycle = {};\n\n    if (recycleRows) {\n      indexesToRemove = [];\n\n      utils_1._.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n        var rowNode = rowComp.getRowNode();\n\n        if (utils_1._.exists(rowNode.id)) {\n          rowsToRecycle[rowNode.id] = rowComp;\n          delete _this.rowCompsByIndex[index];\n        } else {\n          indexesToRemove.push(index);\n        }\n      });\n    } else {\n      indexesToRemove = Object.keys(this.rowCompsByIndex);\n    }\n\n    this.removeRowComps(indexesToRemove);\n    return rowsToRecycle;\n  }; // takes array of row indexes\n\n\n  RowRenderer.prototype.removeRowComps = function (rowsToRemove) {\n    var _this = this; // if no fromIndex then set to -1, which will refresh everything\n    // let realFromIndex = -1;\n\n\n    rowsToRemove.forEach(function (indexToRemove) {\n      var renderedRow = _this.rowCompsByIndex[indexToRemove];\n      renderedRow.destroy();\n      delete _this.rowCompsByIndex[indexToRemove];\n    });\n  }; // gets called when rows don't change, but viewport does, so after:\n  // 1) height of grid body changes, ie number of displayed rows has changed\n  // 2) grid scrolled to new position\n  // 3) ensure index visible (which is a scroll)\n\n\n  RowRenderer.prototype.redrawAfterScroll = function () {\n    this.getLockOnRefresh();\n    this.redraw(null, false, true);\n    this.releaseLockOnRefresh();\n  };\n\n  RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n    // for speedy lookup, dump into map\n    var indexesToDrawMap = {};\n    indexesToDraw.forEach(function (index) {\n      return indexesToDrawMap[index] = true;\n    });\n    var existingIndexes = Object.keys(this.rowCompsByIndex);\n\n    var indexesNotToDraw = utils_1._.filter(existingIndexes, function (index) {\n      return !indexesToDrawMap[index];\n    });\n\n    this.removeRowComps(indexesNotToDraw);\n  };\n\n  RowRenderer.prototype.calculateIndexesToDraw = function () {\n    var _this = this; // all in all indexes in the viewport\n\n\n    var indexesToDraw = utils_1._.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow); // add in indexes of rows we want to keep, because they are currently editing\n\n\n    utils_1._.iterateObject(this.rowCompsByIndex, function (indexStr, rowComp) {\n      var index = Number(indexStr);\n\n      if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n        if (_this.doNotUnVirtualiseRow(rowComp)) {\n          indexesToDraw.push(index);\n        }\n      }\n    });\n\n    indexesToDraw.sort(function (a, b) {\n      return a - b;\n    });\n    return indexesToDraw;\n  };\n\n  RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n    var _this = this;\n\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    if (afterScroll === void 0) {\n      afterScroll = false;\n    }\n\n    this.maxDivHeightScaler.updateOffset();\n    this.workOutFirstAndLastRowsToRender(); // the row can already exist and be in the following:\n    // rowsToRecycle -> if model change, then the index may be different, however row may\n    //                         exist here from previous time (mapped by id).\n    // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n    // this is all the indexes we want, including those that already exist, so this method\n    // will end up going through each index and drawing only if the row doesn't already exist\n\n    var indexesToDraw = this.calculateIndexesToDraw();\n    this.removeRowCompsNotToDraw(indexesToDraw); // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n    // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n\n    if (this.printLayout) {\n      animate = false;\n    } // add in new rows\n\n\n    var nextVmTurnFunctions = [];\n    var rowComps = [];\n    indexesToDraw.forEach(function (rowIndex) {\n      var rowComp = _this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);\n\n      if (utils_1._.exists(rowComp)) {\n        rowComps.push(rowComp);\n\n        utils_1._.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());\n      }\n    });\n    this.flushContainers(rowComps);\n\n    utils_1._.executeNextVMTurn(nextVmTurnFunctions);\n\n    var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n\n    if (useAnimationFrame) {\n      this.beans.taskQueue.addP2Task(this.destroyRowComps.bind(this, rowsToRecycle, animate));\n    } else {\n      this.destroyRowComps(rowsToRecycle, animate);\n    }\n\n    this.checkAngularCompile();\n    this.gridPanel.updateRowCount();\n  };\n\n  RowRenderer.prototype.flushContainers = function (rowComps) {\n    utils_1._.iterateObject(this.rowContainers, function (key, rowContainerComp) {\n      if (rowContainerComp) {\n        rowContainerComp.flushRowTemplates();\n      }\n    });\n\n    rowComps.forEach(function (rowComp) {\n      return rowComp.afterFlush();\n    });\n  };\n\n  RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n    var pinningLeft = this.columnController.isPinningLeft();\n    var pinningRight = this.columnController.isPinningRight();\n    var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n\n    if (atLeastOneChanged) {\n      this.pinningLeft = pinningLeft;\n      this.pinningRight = pinningRight;\n\n      if (this.embedFullWidthRows) {\n        this.redrawFullWidthEmbeddedRows();\n      }\n    }\n  }; // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n  // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n\n\n  RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n    // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n    // embedded, as what appears in each section depends on whether we are pinned or not\n    var rowsToRemove = [];\n\n    utils_1._.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n      if (rowComp.isFullWidth()) {\n        var rowIndex = rowComp.getRowNode().rowIndex;\n        rowsToRemove.push(rowIndex.toString());\n      }\n    });\n\n    this.refreshFloatingRowComps();\n    this.removeRowComps(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.refreshFullWidthRows = function () {\n    var rowsToRemove = [];\n\n    utils_1._.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n      if (rowComp.isFullWidth()) {\n        var fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n\n        if (!fullWidthRowsRefreshed) {\n          var rowIndex = rowComp.getRowNode().rowIndex;\n          rowsToRemove.push(rowIndex.toString());\n        }\n      }\n    });\n\n    this.removeRowComps(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.createOrUpdateRowComp = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n    var rowNode;\n    var rowComp = this.rowCompsByIndex[rowIndex]; // if no row comp, see if we can get it from the previous rowComps\n\n    if (!rowComp) {\n      rowNode = this.paginationProxy.getRow(rowIndex);\n\n      if (utils_1._.exists(rowNode) && utils_1._.exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n        rowComp = rowsToRecycle[rowNode.id];\n        rowsToRecycle[rowNode.id] = null;\n      }\n    }\n\n    var creatingNewRowComp = !rowComp;\n\n    if (creatingNewRowComp) {\n      // create a new one\n      if (!rowNode) {\n        rowNode = this.paginationProxy.getRow(rowIndex);\n      }\n\n      if (utils_1._.exists(rowNode)) {\n        rowComp = this.createRowComp(rowNode, animate, afterScroll);\n      } else {\n        // this should never happen - if somehow we are trying to create\n        // a row for a rowNode that does not exist.\n        return;\n      }\n    } else {\n      // ensure row comp is in right position in DOM\n      rowComp.ensureDomOrder();\n    }\n\n    if (rowNode) {\n      // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n      // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n      rowNode.alreadyRendered = true;\n    }\n\n    this.rowCompsByIndex[rowIndex] = rowComp;\n    return rowComp;\n  };\n\n  RowRenderer.prototype.destroyRowComps = function (rowCompsMap, animate) {\n    var delayedFuncs = [];\n\n    utils_1._.iterateObject(rowCompsMap, function (nodeId, rowComp) {\n      // if row was used, then it's null\n      if (!rowComp) {\n        return;\n      }\n\n      rowComp.destroy(animate);\n\n      utils_1._.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());\n    });\n\n    utils_1._.executeInAWhile(delayedFuncs);\n  };\n\n  RowRenderer.prototype.checkAngularCompile = function () {\n    var _this = this; // if we are doing angular compiling, then do digest the scope here\n\n\n    if (this.gridOptionsWrapper.isAngularCompileRows()) {\n      // we do it in a timeout, in case we are already in an apply\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n    var newFirst;\n    var newLast;\n\n    if (!this.paginationProxy.isRowsToRender()) {\n      newFirst = 0;\n      newLast = -1; // setting to -1 means nothing in range\n    } else if (this.printLayout) {\n      newFirst = this.paginationProxy.getPageFirstRow();\n      newLast = this.paginationProxy.getPageLastRow();\n    } else {\n      var paginationOffset = this.paginationProxy.getPixelOffset();\n      var maxDivHeightScaler = this.maxDivHeightScaler.getOffset();\n      var bodyVRange = this.gridPanel.getVScrollPosition();\n      var bodyTopPixel = bodyVRange.top;\n      var bodyBottomPixel = bodyVRange.bottom;\n      var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n      var firstPixel = bodyTopPixel + paginationOffset + maxDivHeightScaler - bufferPixels;\n      var lastPixel = bodyBottomPixel + paginationOffset + maxDivHeightScaler + bufferPixels;\n      this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n      var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n      var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n      var pageFirstRow = this.paginationProxy.getPageFirstRow();\n      var pageLastRow = this.paginationProxy.getPageLastRow(); // adjust, in case buffer extended actual size\n\n      if (firstRowIndex < pageFirstRow) {\n        firstRowIndex = pageFirstRow;\n      }\n\n      if (lastRowIndex > pageLastRow) {\n        lastRowIndex = pageLastRow;\n      }\n\n      newFirst = firstRowIndex;\n      newLast = lastRowIndex;\n    } // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n    // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n    // killing the browser, we limit the number of rows. just in case some use case we didn't think\n    // of, we also have a property to not do this operation.\n\n\n    var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_NORMAL;\n    var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n    var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n    if (rowLayoutNormal && !suppressRowCountRestriction) {\n      if (newLast - newFirst > rowBufferMaxSize) {\n        newLast = newFirst + rowBufferMaxSize;\n      }\n    }\n\n    var firstDiffers = newFirst !== this.firstRenderedRow;\n    var lastDiffers = newLast !== this.lastRenderedRow;\n\n    if (firstDiffers || lastDiffers) {\n      this.firstRenderedRow = newFirst;\n      this.lastRenderedRow = newLast;\n      var event_1 = {\n        type: events_1.Events.EVENT_VIEWPORT_CHANGED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n\n    if (this.paginationProxy.isRowsToRender()) {\n      var event_2 = {\n        type: events_1.Events.EVENT_FIRST_DATA_RENDERED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEventOnce(event_2);\n    }\n  };\n\n  RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n    // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n    // all the other row models just hard code so the method just returns back false\n    var rowHeightsChanged = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n\n    if (rowHeightsChanged) {\n      // if row heights have changed, we need to resize the containers the rows sit it\n      this.sizeContainerToPageHeight(); // we also need to update heightScaler as this has dependency of row container height\n\n      this.maxDivHeightScaler.updateOffset();\n    }\n  };\n\n  RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n    return this.firstRenderedRow;\n  };\n\n  RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n    return this.lastRenderedRow;\n  }; // check that none of the rows to remove are editing or focused as:\n  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n  //    the edit is reset - so we want to keep it rendered.\n  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n  //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n  //    and then ctrl+c, nothing will happen if cell is removed from dom.\n  // c) if detail record of master detail, as users complained that the context of detail rows\n  //    was getting lost when detail row out of view. eg user expands to show detail row,\n  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n  //    after detail panel is scrolled out of / into view.\n\n\n  RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n    var REMOVE_ROW = false;\n    var KEEP_ROW = true;\n    var rowNode = rowComp.getRowNode();\n    var rowHasFocus = this.focusedCellController.isRowNodeFocused(rowNode);\n    var rowIsEditing = rowComp.isEditing();\n    var rowIsDetail = rowNode.detail;\n    var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail; // if we deffo don't want to keep it,\n\n    if (!mightWantToKeepRow) {\n      return REMOVE_ROW;\n    } // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n    // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n    // the context of the editing in process.\n\n\n    var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n  };\n\n  RowRenderer.prototype.createRowComp = function (rowNode, animate, afterScroll) {\n    var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame(); // we don't use animations frames for printing, so the user can put the grid into print mode\n    // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n    // (via the animation frames) which is awkward to do from code.\n    // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n    // having animation frames for other times makes the grid look 'jumpy'.\n\n    var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n    var rowComp = new rowComp_1.RowComp(this.$scope, this.rowContainers.body, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight, this.rowContainers.fullWidth, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout, this.embedFullWidthRows);\n    rowComp.init();\n    return rowComp;\n  };\n\n  RowRenderer.prototype.getRenderedNodes = function () {\n    var renderedRows = this.rowCompsByIndex;\n    return Object.keys(renderedRows).map(function (key) {\n      return renderedRows[key].getRowNode();\n    });\n  }; // we use index for rows, but column object for columns, as the next column (by index) might not\n  // be visible (header grouping) so it's not reliable, so using the column object instead.\n\n\n  RowRenderer.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n    // we keep searching for a next cell until we find one. this is how the group rows get skipped\n    var nextCell = currentCell;\n    var finished = false;\n\n    while (!finished) {\n      // if the current cell is spanning across multiple columns, we need to move\n      // our current position to be the last cell on the right before finding the\n      // the next target.\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        if (key === constants_1.Constants.KEY_LEFT) {\n          nextCell = this.getLastCellOfColSpan(nextCell);\n        }\n      } else if (key === constants_1.Constants.KEY_RIGHT) {\n        nextCell = this.getLastCellOfColSpan(nextCell);\n      }\n\n      nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell); // eg if going down, and nextCell=undefined, means we are gone past the last row\n\n      var hitEdgeOfGrid = utils_1._.missing(nextCell);\n\n      if (hitEdgeOfGrid) {\n        finished = true;\n        continue;\n      }\n\n      var rowNode = this.rowPositionUtils.getRowNode(nextCell); // we do not allow focusing on full width rows, this includes details rows\n\n      if (rowNode.detail) {\n        continue;\n      } // if not a group, then we have a valid row, so quit the search\n\n\n      if (!rowNode.group) {\n        finished = true;\n        continue;\n      } // full width rows cannot be focused, so if it's a group and using full width rows,\n      // we need to skip over the row\n\n\n      var pivotMode = this.columnController.isPivotMode();\n      var usingFullWidthRows = this.gridOptionsWrapper.isGroupUseEntireRow(pivotMode);\n\n      if (!usingFullWidthRows) {\n        finished = true;\n      }\n    } // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n    // we allow this, however if processing 'enter after edit' we don't allow override\n\n\n    if (allowUserOverride) {\n      var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n\n      if (utils_1._.exists(userFunc)) {\n        var params = {\n          key: key,\n          previousCellPosition: currentCell,\n          nextCellPosition: nextCell ? nextCell : null,\n          event: event\n        };\n        var userCell = userFunc(params);\n\n        if (utils_1._.exists(userCell)) {\n          if (userCell.floating) {\n            utils_1._.doOnce(function () {\n              console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextCell = {\n            rowPinned: userCell.rowPinned,\n            rowIndex: userCell.rowIndex,\n            column: userCell.column\n          };\n        } else {\n          nextCell = null;\n        }\n      }\n    } // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n\n\n    if (!nextCell) {\n      return;\n    } // in case we have col spanning we get the cellComp and use it to\n    // get the position. This was we always focus the first cell inside\n    // the spanning.\n\n\n    this.ensureCellVisible(nextCell); // ensureCellVisible first, to make sure nextCell is rendered\n\n    var cellComp = this.getComponentForCell(nextCell);\n    nextCell = cellComp.getCellPosition(); // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n    // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n    // last column in the group, however now it's the first column in the group). if we didn't do\n    // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n    // merged cells.\n\n    this.ensureCellVisible(nextCell);\n    this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.rowPinned, true);\n\n    if (this.rangeController) {\n      this.rangeController.setRangeToCell(nextCell);\n    }\n  };\n\n  RowRenderer.prototype.getLastCellOfColSpan = function (cell) {\n    var cellComp = this.getComponentForCell(cell);\n\n    if (!cellComp) {\n      return cell;\n    }\n\n    var colSpanningList = cellComp.getColSpanningList();\n\n    if (colSpanningList.length === 1) {\n      return cell;\n    }\n\n    return {\n      rowIndex: cell.rowIndex,\n      column: utils_1._.last(colSpanningList),\n      rowPinned: cell.rowPinned\n    };\n  };\n\n  RowRenderer.prototype.ensureCellVisible = function (gridCell) {\n    // this scrolls the row into view\n    if (utils_1._.missing(gridCell.rowPinned)) {\n      this.gridPanel.ensureIndexVisible(gridCell.rowIndex);\n    }\n\n    if (!gridCell.column.isPinned()) {\n      this.gridPanel.ensureColumnVisible(gridCell.column);\n    } // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n    // floating cell, the scrolls get out of sync\n\n\n    this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter(); // need to flush frames, to make sure the correct cells are rendered\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {\n    var cell = this.getComponentForCell(gridCell);\n\n    if (cell) {\n      cell.startRowOrCellEdit(keyPress, charPress);\n    }\n  };\n\n  RowRenderer.prototype.getComponentForCell = function (cellPosition) {\n    var rowComponent;\n\n    switch (cellPosition.rowPinned) {\n      case constants_1.Constants.PINNED_TOP:\n        rowComponent = this.floatingTopRowComps[cellPosition.rowIndex];\n        break;\n\n      case constants_1.Constants.PINNED_BOTTOM:\n        rowComponent = this.floatingBottomRowComps[cellPosition.rowIndex];\n        break;\n\n      default:\n        rowComponent = this.rowCompsByIndex[cellPosition.rowIndex];\n        break;\n    }\n\n    if (!rowComponent) {\n      return null;\n    }\n\n    var cellComponent = rowComponent.getRenderedCellForColumn(cellPosition.column);\n    return cellComponent;\n  };\n\n  RowRenderer.prototype.getRowNode = function (gridRow) {\n    switch (gridRow.rowPinned) {\n      case constants_1.Constants.PINNED_TOP:\n        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n\n      case constants_1.Constants.PINNED_BOTTOM:\n        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n\n      default:\n        return this.rowModel.getRow(gridRow.rowIndex);\n    }\n  };\n\n  RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {\n    var backwards = keyboardEvent.shiftKey;\n    var success = this.moveToCellAfter(previousRenderedCell, backwards);\n\n    if (success) {\n      keyboardEvent.preventDefault();\n    }\n  };\n\n  RowRenderer.prototype.tabToNextCell = function (backwards) {\n    var focusedCell = this.focusedCellController.getFocusedCell(); // if no focus, then cannot navigate\n\n    if (utils_1._.missing(focusedCell)) {\n      return false;\n    }\n\n    var renderedCell = this.getComponentForCell(focusedCell); // if cell is not rendered, means user has scrolled away from the cell\n\n    if (utils_1._.missing(renderedCell)) {\n      return false;\n    }\n\n    var result = this.moveToCellAfter(renderedCell, backwards);\n    return result;\n  };\n\n  RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {\n    var editing = previousRenderedCell.isEditing();\n    var res;\n\n    if (editing) {\n      if (this.gridOptionsWrapper.isFullRowEdit()) {\n        res = this.moveToNextEditingRow(previousRenderedCell, backwards);\n      } else {\n        res = this.moveToNextEditingCell(previousRenderedCell, backwards);\n      }\n    } else {\n      res = this.moveToNextCellNotEditing(previousRenderedCell, backwards);\n    }\n\n    return res;\n  };\n\n  RowRenderer.prototype.moveToNextEditingCell = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // need to do this before getting next cell to edit, in case the next cell\n    // has editable function (eg colDef.editable=func() ) and it depends on the\n    // result of this cell, so need to save updates from the first edit, in case\n    // the value is referenced in the function.\n\n    previousRenderedCell.stopEditing(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n    var foundCell = utils_1._.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      nextRenderedCell.startEditingIfEnabled(null, null, true);\n      nextRenderedCell.focusCell(false);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveToNextEditingRow = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n    var foundCell = utils_1._.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveToNextCellNotEditing = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n\n    var foundCell = utils_1._.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      nextRenderedCell.focusCell(true);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveEditToNextCellOrRow = function (previousRenderedCell, nextRenderedCell) {\n    var pGridCell = previousRenderedCell.getCellPosition();\n    var nGridCell = nextRenderedCell.getCellPosition();\n    var rowsMatch = pGridCell.rowIndex === nGridCell.rowIndex && pGridCell.rowPinned === nGridCell.rowPinned;\n\n    if (rowsMatch) {\n      // same row, so we don't start / stop editing, we just move the focus along\n      previousRenderedCell.setFocusOutOnEditor();\n      nextRenderedCell.setFocusInOnEditor();\n    } else {\n      var pRow = previousRenderedCell.getRenderedRow();\n      var nRow = nextRenderedCell.getRenderedRow();\n      previousRenderedCell.setFocusOutOnEditor();\n      pRow.stopEditing();\n      nRow.startRowEditing();\n      nextRenderedCell.setFocusInOnEditor();\n    }\n\n    nextRenderedCell.focusCell();\n  }; // called by the cell, when tab is pressed while editing.\n  // @return: RenderedCell when navigation successful, otherwise null\n\n\n  RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {\n    var nextCell = gridCell;\n\n    while (true) {\n      if (!backwards) {\n        nextCell = this.getLastCellOfColSpan(nextCell);\n      }\n\n      nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards); // allow user to override what cell to go to next\n\n      var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n      if (utils_1._.exists(userFunc)) {\n        var params = {\n          backwards: backwards,\n          editing: startEditing,\n          previousCellPosition: gridCell,\n          nextCellPosition: nextCell ? nextCell : null\n        };\n        var userCell = userFunc(params);\n\n        if (utils_1._.exists(userCell)) {\n          if (userCell.floating) {\n            utils_1._.doOnce(function () {\n              console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextCell = {\n            rowIndex: userCell.rowIndex,\n            column: userCell.column,\n            rowPinned: userCell.rowPinned\n          };\n        } else {\n          nextCell = null;\n        }\n      } // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n      // so bottom right cell going forwards, or top left going backwards\n\n\n      if (!nextCell) {\n        return null;\n      } // if editing, but cell not editable, skip cell. we do this before we do all of\n      // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n      // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n      // (except for the last one) which causes grid to stall for a while.\n\n\n      if (startEditing) {\n        var rowNode = this.lookupRowNodeForCell(nextCell);\n        var cellIsEditable = nextCell.column.isCellEditable(rowNode);\n\n        if (!cellIsEditable) {\n          continue;\n        }\n      } // this scrolls the row into view\n\n\n      var cellIsNotFloating = utils_1._.missing(nextCell.rowPinned);\n\n      if (cellIsNotFloating) {\n        this.gridPanel.ensureIndexVisible(nextCell.rowIndex);\n      } // pinned columns don't scroll, so no need to ensure index visible\n\n\n      if (!nextCell.column.isPinned()) {\n        this.gridPanel.ensureColumnVisible(nextCell.column);\n      } // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n      // floating cell, the scrolls get out of sync\n\n\n      this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter(); // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp\n      // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.\n\n      this.animationFrameService.flushAllFrames(); // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n      // or row that is not currently in view, hence the renderedCell would not exist\n\n      var nextCellComp = this.getComponentForCell(nextCell); // if next cell is fullWidth row, then no rendered cell,\n      // as fullWidth rows have no cells, so we skip it\n\n      if (utils_1._.missing(nextCellComp)) {\n        continue;\n      }\n\n      if (nextCellComp.isSuppressNavigable()) {\n        continue;\n      } // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n      // consistent, we set into range here also.\n\n\n      if (this.rangeController) {\n        this.rangeController.setRangeToCell(nextCell);\n      } // we successfully tabbed onto a grid cell, so return true\n\n\n      return nextCellComp;\n    }\n  };\n\n  RowRenderer.prototype.lookupRowNodeForCell = function (cell) {\n    if (cell.rowPinned === constants_1.Constants.PINNED_TOP) {\n      return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n    }\n\n    if (cell.rowPinned === constants_1.Constants.PINNED_BOTTOM) {\n      return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n    }\n\n    return this.paginationProxy.getRow(cell.rowIndex);\n  };\n\n  __decorate([context_1.Autowired(\"paginationProxy\"), __metadata(\"design:type\", paginationProxy_1.PaginationProxy)], RowRenderer.prototype, \"paginationProxy\", void 0);\n\n  __decorate([context_1.Autowired(\"columnController\"), __metadata(\"design:type\", columnController_1.ColumnController)], RowRenderer.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired(\"gridOptionsWrapper\"), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], RowRenderer.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired(\"$scope\"), __metadata(\"design:type\", Object)], RowRenderer.prototype, \"$scope\", void 0);\n\n  __decorate([context_1.Autowired(\"eventService\"), __metadata(\"design:type\", eventService_1.EventService)], RowRenderer.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired(\"pinnedRowModel\"), __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([context_1.Autowired(\"rowModel\"), __metadata(\"design:type\", Object)], RowRenderer.prototype, \"rowModel\", void 0);\n\n  __decorate([context_1.Autowired(\"loggerFactory\"), __metadata(\"design:type\", logger_1.LoggerFactory)], RowRenderer.prototype, \"loggerFactory\", void 0);\n\n  __decorate([context_1.Autowired(\"focusedCellController\"), __metadata(\"design:type\", focusedCellController_1.FocusedCellController)], RowRenderer.prototype, \"focusedCellController\", void 0);\n\n  __decorate([context_1.Autowired(\"cellNavigationService\"), __metadata(\"design:type\", cellNavigationService_1.CellNavigationService)], RowRenderer.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([context_1.Autowired(\"columnApi\"), __metadata(\"design:type\", columnApi_1.ColumnApi)], RowRenderer.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.Autowired(\"gridApi\"), __metadata(\"design:type\", gridApi_1.GridApi)], RowRenderer.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.Autowired(\"beans\"), __metadata(\"design:type\", beans_1.Beans)], RowRenderer.prototype, \"beans\", void 0);\n\n  __decorate([context_1.Autowired(\"maxDivHeightScaler\"), __metadata(\"design:type\", maxDivHeightScaler_1.MaxDivHeightScaler)], RowRenderer.prototype, \"maxDivHeightScaler\", void 0);\n\n  __decorate([context_1.Autowired(\"animationFrameService\"), __metadata(\"design:type\", animationFrameService_1.AnimationFrameService)], RowRenderer.prototype, \"animationFrameService\", void 0);\n\n  __decorate([context_1.Autowired(\"rowPositionUtils\"), __metadata(\"design:type\", rowPosition_1.RowPositionUtils)], RowRenderer.prototype, \"rowPositionUtils\", void 0);\n\n  __decorate([context_1.Optional(\"rangeController\"), __metadata(\"design:type\", Object)], RowRenderer.prototype, \"rangeController\", void 0);\n\n  __decorate([__param(0, context_1.Qualifier(\"loggerFactory\")), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], RowRenderer.prototype, \"agWire\", null);\n\n  RowRenderer = __decorate([context_1.Bean(\"rowRenderer\")], RowRenderer);\n  return RowRenderer;\n}(beanStub_1.BeanStub);\n\nexports.RowRenderer = RowRenderer;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/rendering/rowRenderer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","__param","paramIndex","decorator","exports","value","gridOptionsWrapper_1","require","eventService_1","rowComp_1","column_1","events_1","constants_1","cellComp_1","context_1","columnApi_1","columnController_1","logger_1","focusedCellController_1","cellNavigationService_1","beanStub_1","paginationProxy_1","gridApi_1","pinnedRowModel_1","beans_1","animationFrameService_1","maxDivHeightScaler_1","utils_1","rowPosition_1","RowRenderer","_super","_this","apply","destroyFuncsForColumnListeners","rowCompsByIndex","floatingTopRowComps","floatingBottomRowComps","refreshInProgress","registerGridCore","gridCore","getGridCore","agWire","loggerFactory","logger","registerGridComp","gridPanel","rowContainers","getRowContainers","addDestroyableEventListener","eventService","Events","EVENT_PAGINATION_CHANGED","onPageLoaded","bind","EVENT_PINNED_ROW_DATA_CHANGED","onPinnedRowDataChanged","EVENT_DISPLAYED_COLUMNS_CHANGED","onDisplayedColumnsChanged","EVENT_BODY_SCROLL","redrawAfterScroll","EVENT_BODY_HEIGHT_CHANGED","gridOptionsWrapper","GridOptionsWrapper","PROP_DOM_LAYOUT","onDomLayoutChanged","registerCellEventListeners","printLayout","getDomLayout","Constants","DOM_LAYOUT_PRINT","embedFullWidthRows","isEmbedFullWidthRows","redrawAfterModelUpdate","EVENT_CELL_FOCUSED","event","forEachCellComp","cellComp","onCellFocused","EVENT_FLASH_CELLS","onFlashCells","EVENT_COLUMN_HOVER_CHANGED","onColumnHover","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onLeftChanged","rangeSelectionEnabled","isEnableRangeSelection","EVENT_RANGE_SELECTION_CHANGED","onRangeSelectionChanged","EVENT_COLUMN_MOVED","updateRangeBordersIfRangeCount","EVENT_COLUMN_PINNED","EVENT_COLUMN_VISIBLE","refreshListenersToColumnsForCellComps","EVENT_GRID_COLUMNS_CHANGED","addDestroyFunc","removeGridColumnListeners","forEach","func","cols","columnController","getAllGridColumns","col","forEachCellWithThisCol","callback","getColumn","leftChangedListener","widthChangedListener","onWidthChanged","firstRightPinnedChangedListener","onFirstRightPinnedChanged","lastLeftPinnedChangedListener","onLastLeftPinnedChanged","addEventListener","Column","EVENT_LEFT_CHANGED","EVENT_WIDTH_CHANGED","EVENT_FIRST_RIGHT_PINNED_CHANGED","EVENT_LAST_LEFT_PINNED_CHANGED","push","removeEventListener","destroyRows","datasourceChanged","firstRenderedRow","lastRenderedRow","rowIndexesToRemove","keys","removeRowComps","refreshEvent","_","missing","type","EVENT_MODEL_UPDATED","api","gridApi","columnApi","animate","keepRenderedRows","newData","newPage","onModelUpdated","getAllCellsForColumn","column","eCells","iterateObject","rowComp","eCell","getCellForCol","refreshFloatingRowComps","refreshFloatingRows","pinnedRowModel","getPinnedTopRowData","floatingTopPinnedLeft","floatingTopPinnedRight","floatingTop","floatingTopFullWidth","getPinnedBottomRowData","floatingBottomPinnedLeft","floatingBottomPinnedRight","floatingBottom","floatingBottomFullWith","rowComps","rowNodes","pinnedLeftContainerComp","pinnedRightContainerComp","bodyContainerComp","fullWidthContainerComp","row","destroy","node","RowComp","$scope","beans","init","flushContainers","params","recycleRows","onlyBody","getRenderedIndexesForRowNodes","result","index","renderedRow","rowNode","getRowNode","indexOf","redrawRows","indexesToRemove","getCellToRestoreFocusToAfterRefresh","focusedCell","suppressKeepFocus","focusedCellController","getFocusCellToUseAfterRefresh","activeElement","document","domData","getDomData","CellComp","DOM_DATA_KEY_CELL_COMP","elementIsNotACellDev","getLockOnRefresh","sizeContainerToPageHeight","scrollToTopIfNewData","isAnimateRows","rowsToRecycle","binRowComps","redraw","restoreFocusedCell","releaseLockOnRefresh","scrollToTop","suppressScrollToTop","isSuppressScrollOnNewData","containers","body","fullWidth","pinnedLeft","pinnedRight","container","setHeight","containerHeight","paginationProxy","getCurrentPageHeight","maxDivHeightScaler","setModelHeight","realHeight","getUiContainerHeight","Error","cellPosition","setFocusedCell","rowIndex","rowPinned","stopEditing","cancel","forEachRowComp","addRenderedRowListener","eventName","flashCells","forEachCellCompFiltered","columns","flashCell","refreshCells","refreshCellParams","forceRefresh","force","refreshCell","getCellRendererInstances","res","cellRenderer","getCellRenderer","getCellEditorInstances","cellEditor","getCellEditor","getEditingCells","isEditing","getCellPosition","rowIdsMap","exists","top","bottom","normal","PINNED_TOP","id","PINNED_BOTTOM","colIdsMap","colKey","getGridColumn","getId","processRow","floating","colId","excludeColFromRefresh","call","rowsToRemove","indexToRemove","removeRowCompsNotToDraw","indexesToDraw","indexesToDrawMap","existingIndexes","indexesNotToDraw","filter","calculateIndexesToDraw","createArrayOfNumbers","indexStr","Number","doNotUnVirtualiseRow","sort","a","afterScroll","updateOffset","workOutFirstAndLastRowsToRender","nextVmTurnFunctions","createOrUpdateRowComp","pushAll","getAndClearNextVMTurnFunctions","executeNextVMTurn","useAnimationFrame","isSuppressAnimationFrame","taskQueue","addP2Task","destroyRowComps","checkAngularCompile","updateRowCount","rowContainerComp","flushRowTemplates","afterFlush","pinningLeft","isPinningLeft","pinningRight","isPinningRight","atLeastOneChanged","redrawFullWidthEmbeddedRows","isFullWidth","toString","refreshFullWidthRows","fullWidthRowsRefreshed","refreshFullWidth","getRow","alreadyRendered","creatingNewRowComp","createRowComp","ensureDomOrder","rowCompsMap","delayedFuncs","nodeId","getAndClearDelayedDestroyFunctions","executeInAWhile","isAngularCompileRows","window","setTimeout","$apply","newFirst","newLast","isRowsToRender","getPageFirstRow","getPageLastRow","paginationOffset","getPixelOffset","getOffset","bodyVRange","getVScrollPosition","bodyTopPixel","bodyBottomPixel","bufferPixels","getRowBufferInPixels","firstPixel","lastPixel","ensureAllRowsInRangeHaveHeightsCalculated","firstRowIndex","getRowIndexAtPixel","lastRowIndex","pageFirstRow","pageLastRow","rowLayoutNormal","DOM_LAYOUT_NORMAL","suppressRowCountRestriction","isSuppressMaxRenderedRowRestriction","rowBufferMaxSize","Math","max","getRowBuffer","firstDiffers","lastDiffers","event_1","EVENT_VIEWPORT_CHANGED","firstRow","lastRow","dispatchEvent","event_2","EVENT_FIRST_DATA_RENDERED","dispatchEventOnce","topPixel","bottomPixel","rowHeightsChanged","ensureRowHeightsValid","getFirstVirtualRenderedRow","getLastVirtualRenderedRow","REMOVE_ROW","KEEP_ROW","rowHasFocus","isRowNodeFocused","rowIsEditing","rowIsDetail","detail","mightWantToKeepRow","rowNodePresent","isRowPresent","suppressAnimationFrame","useAnimationFrameForCreate","getRenderedNodes","renderedRows","map","navigateToNextCell","currentCell","allowUserOverride","nextCell","finished","isEnableRtl","KEY_LEFT","getLastCellOfColSpan","KEY_RIGHT","cellNavigationService","getNextCellToFocus","hitEdgeOfGrid","rowPositionUtils","group","pivotMode","isPivotMode","usingFullWidthRows","isGroupUseEntireRow","userFunc","getNavigateToNextCellFunc","previousCellPosition","nextCellPosition","userCell","doOnce","console","warn","ensureCellVisible","getComponentForCell","rangeController","setRangeToCell","cell","colSpanningList","getColSpanningList","last","gridCell","ensureIndexVisible","isPinned","ensureColumnVisible","horizontallyScrollHeaderCenterAndFloatingCenter","animationFrameService","flushAllFrames","startEditingCell","keyPress","charPress","startRowOrCellEdit","rowComponent","cellComponent","getRenderedCellForColumn","gridRow","rowModel","onTabKeyDown","previousRenderedCell","keyboardEvent","backwards","shiftKey","success","moveToCellAfter","preventDefault","tabToNextCell","getFocusedCell","renderedCell","editing","isFullRowEdit","moveToNextEditingRow","moveToNextEditingCell","moveToNextCellNotEditing","nextRenderedCell","findNextCellToFocusOn","foundCell","startEditingIfEnabled","focusCell","moveEditToNextCellOrRow","pGridCell","nGridCell","rowsMatch","setFocusOutOnEditor","setFocusInOnEditor","pRow","getRenderedRow","nRow","startRowEditing","startEditing","getNextTabbedCell","getTabToNextCellFunc","lookupRowNodeForCell","cellIsEditable","isCellEditable","cellIsNotFloating","nextCellComp","isSuppressNavigable","getPinnedTopRow","getPinnedBottomRow","Autowired","PaginationProxy","ColumnController","EventService","PinnedRowModel","LoggerFactory","FocusedCellController","CellNavigationService","ColumnApi","GridApi","Beans","MaxDivHeightScaler","AnimationFrameService","RowPositionUtils","Optional","Qualifier","Function","Bean","BeanStub"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar eventService_1 = require(\"../eventService\");\nvar rowComp_1 = require(\"./rowComp\");\nvar column_1 = require(\"../entities/column\");\nvar events_1 = require(\"../events\");\nvar constants_1 = require(\"../constants\");\nvar cellComp_1 = require(\"./cellComp\");\nvar context_1 = require(\"../context/context\");\nvar columnApi_1 = require(\"../columnController/columnApi\");\nvar columnController_1 = require(\"../columnController/columnController\");\nvar logger_1 = require(\"../logger\");\nvar focusedCellController_1 = require(\"../focusedCellController\");\nvar cellNavigationService_1 = require(\"../cellNavigationService\");\nvar beanStub_1 = require(\"../context/beanStub\");\nvar paginationProxy_1 = require(\"../rowModels/paginationProxy\");\nvar gridApi_1 = require(\"../gridApi\");\nvar pinnedRowModel_1 = require(\"../rowModels/pinnedRowModel\");\nvar beans_1 = require(\"./beans\");\nvar animationFrameService_1 = require(\"../misc/animationFrameService\");\nvar maxDivHeightScaler_1 = require(\"./maxDivHeightScaler\");\nvar utils_1 = require(\"../utils\");\nvar rowPosition_1 = require(\"../entities/rowPosition\");\nvar RowRenderer = /** @class */ (function (_super) {\n    __extends(RowRenderer, _super);\n    function RowRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destroyFuncsForColumnListeners = [];\n        // map of row ids to row objects. keeps track of which elements\n        // are rendered for which rows in the dom.\n        _this.rowCompsByIndex = {};\n        _this.floatingTopRowComps = [];\n        _this.floatingBottomRowComps = [];\n        // we only allow one refresh at a time, otherwise the internal memory structure here\n        // will get messed up. this can happen if the user has a cellRenderer, and inside the\n        // renderer they call an API method that results in another pass of the refresh,\n        // then it will be trying to draw rows in the middle of a refresh.\n        _this.refreshInProgress = false;\n        return _this;\n    }\n    RowRenderer.prototype.registerGridCore = function (gridCore) {\n        this.gridCore = gridCore;\n    };\n    RowRenderer.prototype.getGridCore = function () {\n        return this.gridCore;\n    };\n    RowRenderer.prototype.agWire = function (loggerFactory) {\n        this.logger = loggerFactory.create(\"RowRenderer\");\n    };\n    RowRenderer.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n        this.rowContainers = this.gridPanel.getRowContainers();\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n        this.registerCellEventListeners();\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        this.redrawAfterModelUpdate();\n    };\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    RowRenderer.prototype.registerCellEventListeners = function () {\n        var _this = this;\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_CELL_FOCUSED, function (event) {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onCellFocused(event); });\n        });\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_FLASH_CELLS, function (event) {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onFlashCells(event); });\n        });\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onColumnHover(); });\n        });\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n            if (_this.printLayout) {\n                _this.forEachCellComp(function (cellComp) { return cellComp.onLeftChanged(); });\n            }\n        });\n        var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n            this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.onRangeSelectionChanged(); });\n            });\n            this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_MOVED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n            this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_PINNED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n            this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_VISIBLE, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n        }\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    };\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    RowRenderer.prototype.removeGridColumnListeners = function () {\n        this.destroyFuncsForColumnListeners.forEach(function (func) { return func(); });\n        this.destroyFuncsForColumnListeners.length = 0;\n    };\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n        var _this = this;\n        this.removeGridColumnListeners();\n        var cols = this.columnController.getAllGridColumns();\n        if (!cols) {\n            return;\n        }\n        cols.forEach(function (col) {\n            var forEachCellWithThisCol = function (callback) {\n                _this.forEachCellComp(function (cellComp) {\n                    if (cellComp.getColumn() === col) {\n                        callback(cellComp);\n                    }\n                });\n            };\n            var leftChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onLeftChanged(); });\n            };\n            var widthChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onWidthChanged(); });\n            };\n            var firstRightPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onFirstRightPinnedChanged(); });\n            };\n            var lastLeftPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onLastLeftPinnedChanged(); });\n            };\n            col.addEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            _this.destroyFuncsForColumnListeners.push(function () {\n                col.removeEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n    };\n    RowRenderer.prototype.onDomLayoutChanged = function () {\n        var printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n        var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    };\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    RowRenderer.prototype.datasourceChanged = function () {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    };\n    RowRenderer.prototype.onPageLoaded = function (refreshEvent) {\n        if (utils_1._.missing(refreshEvent)) {\n            refreshEvent = {\n                type: events_1.Events.EVENT_MODEL_UPDATED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                animate: false,\n                keepRenderedRows: false,\n                newData: false,\n                newPage: false\n            };\n        }\n        this.onModelUpdated(refreshEvent);\n    };\n    RowRenderer.prototype.getAllCellsForColumn = function (column) {\n        var eCells = [];\n        utils_1._.iterateObject(this.rowCompsByIndex, callback);\n        utils_1._.iterateObject(this.floatingBottomRowComps, callback);\n        utils_1._.iterateObject(this.floatingTopRowComps, callback);\n        function callback(key, rowComp) {\n            var eCell = rowComp.getCellForCol(column);\n            if (eCell) {\n                eCells.push(eCell);\n            }\n        }\n        return eCells;\n    };\n    RowRenderer.prototype.refreshFloatingRowComps = function () {\n        this.refreshFloatingRows(this.floatingTopRowComps, this.pinnedRowModel.getPinnedTopRowData(), this.rowContainers.floatingTopPinnedLeft, this.rowContainers.floatingTopPinnedRight, this.rowContainers.floatingTop, this.rowContainers.floatingTopFullWidth);\n        this.refreshFloatingRows(this.floatingBottomRowComps, this.pinnedRowModel.getPinnedBottomRowData(), this.rowContainers.floatingBottomPinnedLeft, this.rowContainers.floatingBottomPinnedRight, this.rowContainers.floatingBottom, this.rowContainers.floatingBottomFullWith);\n    };\n    RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes, pinnedLeftContainerComp, pinnedRightContainerComp, bodyContainerComp, fullWidthContainerComp) {\n        var _this = this;\n        rowComps.forEach(function (row) {\n            row.destroy();\n        });\n        rowComps.length = 0;\n        if (rowNodes) {\n            rowNodes.forEach(function (node) {\n                var rowComp = new rowComp_1.RowComp(_this.$scope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, node, _this.beans, false, false, _this.printLayout, _this.embedFullWidthRows);\n                rowComp.init();\n                rowComps.push(rowComp);\n            });\n        }\n        this.flushContainers(rowComps);\n    };\n    RowRenderer.prototype.onPinnedRowDataChanged = function () {\n        // recycling rows in order to ensure cell editing is not cancelled\n        var params = {\n            recycleRows: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    RowRenderer.prototype.onModelUpdated = function (refreshEvent) {\n        var params = {\n            recycleRows: refreshEvent.keepRenderedRows,\n            animate: refreshEvent.animate,\n            newData: refreshEvent.newData,\n            newPage: refreshEvent.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    // if the row nodes are not rendered, no index is returned\n    RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n        var result = [];\n        if (utils_1._.missing(rowNodes)) {\n            return result;\n        }\n        utils_1._.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {\n            var rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n        return result;\n    };\n    RowRenderer.prototype.redrawRows = function (rowNodes) {\n        if (!rowNodes || rowNodes.length == 0) {\n            return;\n        }\n        // we only need to be worried about rendered rows, as this method is\n        // called to what's rendered. if the row isn't rendered, we don't care\n        var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);\n        // remove the rows\n        this.removeRowComps(indexesToRemove);\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: true\n        });\n    };\n    RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n        var focusedCell = params.suppressKeepFocus ? null : this.focusedCellController.getFocusCellToUseAfterRefresh();\n        if (utils_1._.missing(focusedCell)) {\n            return null;\n        }\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        var activeElement = document.activeElement;\n        var domData = this.gridOptionsWrapper.getDomData(activeElement, cellComp_1.CellComp.DOM_DATA_KEY_CELL_COMP);\n        var elementIsNotACellDev = utils_1._.missing(domData);\n        if (elementIsNotACellDev) {\n            return null;\n        }\n        return focusedCell;\n    };\n    // gets called after changes to the model.\n    RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n        if (params === void 0) { params = {}; }\n        this.getLockOnRefresh();\n        var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n        this.sizeContainerToPageHeight();\n        this.scrollToTopIfNewData(params);\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        var recycleRows = !this.printLayout && params.recycleRows;\n        var animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n        var rowsToRecycle = this.binRowComps(recycleRows);\n        this.redraw(rowsToRecycle, animate);\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n        this.restoreFocusedCell(focusedCell);\n        this.releaseLockOnRefresh();\n    };\n    RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n        var scrollToTop = params.newData || params.newPage;\n        var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridPanel.scrollToTop();\n        }\n    };\n    RowRenderer.prototype.sizeContainerToPageHeight = function () {\n        var containers = [\n            this.rowContainers.body,\n            this.rowContainers.fullWidth,\n            this.rowContainers.pinnedLeft,\n            this.rowContainers.pinnedRight\n        ];\n        if (this.printLayout) {\n            containers.forEach(function (container) { return container.setHeight(null); });\n            return;\n        }\n        var containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n        this.maxDivHeightScaler.setModelHeight(containerHeight);\n        var realHeight = this.maxDivHeightScaler.getUiContainerHeight();\n        containers.forEach(function (container) { return container.setHeight(realHeight); });\n    };\n    RowRenderer.prototype.getLockOnRefresh = function () {\n        if (this.refreshInProgress) {\n            throw new Error(\"ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                \"this, put the API call into a timeout, eg instead of api.refreshView(), \" +\n                \"call setTimeout(function(){api.refreshView(),0}). To see what part of your code \" +\n                \"that caused the refresh check this stacktrace.\");\n        }\n        this.refreshInProgress = true;\n    };\n    RowRenderer.prototype.releaseLockOnRefresh = function () {\n        this.refreshInProgress = false;\n    };\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n        if (cellPosition) {\n            this.focusedCellController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    };\n    RowRenderer.prototype.stopEditing = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        this.forEachRowComp(function (key, rowComp) {\n            rowComp.stopEditing(cancel);\n        });\n    };\n    RowRenderer.prototype.forEachCellComp = function (callback) {\n        this.forEachRowComp(function (key, rowComp) { return rowComp.forEachCellComp(callback); });\n    };\n    RowRenderer.prototype.forEachRowComp = function (callback) {\n        utils_1._.iterateObject(this.rowCompsByIndex, callback);\n        utils_1._.iterateObject(this.floatingTopRowComps, callback);\n        utils_1._.iterateObject(this.floatingBottomRowComps, callback);\n    };\n    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n        var rowComp = this.rowCompsByIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    };\n    RowRenderer.prototype.flashCells = function (params) {\n        if (params === void 0) { params = {}; }\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) { return cellComp.flashCell(); });\n    };\n    RowRenderer.prototype.refreshCells = function (params) {\n        if (params === void 0) { params = {}; }\n        var refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false\n        };\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) { return cellComp.refreshCell(refreshCellParams); });\n    };\n    RowRenderer.prototype.getCellRendererInstances = function (params) {\n        var res = [];\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n            var cellRenderer = cellComp.getCellRenderer();\n            if (cellRenderer) {\n                res.push(cellRenderer);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.getCellEditorInstances = function (params) {\n        var res = [];\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n            var cellEditor = cellComp.getCellEditor();\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.getEditingCells = function () {\n        var res = [];\n        this.forEachCellComp(function (cellComp) {\n            if (cellComp.isEditing()) {\n                var cellPosition = cellComp.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n        return res;\n    };\n    // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n    RowRenderer.prototype.forEachCellCompFiltered = function (rowNodes, columns, callback) {\n        var _this = this;\n        var rowIdsMap;\n        if (utils_1._.exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n            rowNodes.forEach(function (rowNode) {\n                if (rowNode.rowPinned === constants_1.Constants.PINNED_TOP) {\n                    rowIdsMap.top[rowNode.id] = true;\n                }\n                else if (rowNode.rowPinned === constants_1.Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[rowNode.id] = true;\n                }\n                else {\n                    rowIdsMap.normal[rowNode.id] = true;\n                }\n            });\n        }\n        var colIdsMap;\n        if (utils_1._.exists(columns)) {\n            colIdsMap = {};\n            columns.forEach(function (colKey) {\n                var column = _this.columnController.getGridColumn(colKey);\n                if (utils_1._.exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n        var processRow = function (rowComp) {\n            var rowNode = rowComp.getRowNode();\n            var id = rowNode.id;\n            var floating = rowNode.rowPinned;\n            // skip this row if it is missing from the provided list\n            if (utils_1._.exists(rowIdsMap)) {\n                if (floating === constants_1.Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                }\n                else if (floating === constants_1.Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                }\n                else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n            rowComp.forEachCellComp(function (cellComp) {\n                var colId = cellComp.getColumn().getId();\n                var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n                if (excludeColFromRefresh) {\n                    return;\n                }\n                callback(cellComp);\n            });\n        };\n        utils_1._.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n            processRow(rowComp);\n        });\n        if (this.floatingTopRowComps) {\n            this.floatingTopRowComps.forEach(processRow);\n        }\n        if (this.floatingBottomRowComps) {\n            this.floatingBottomRowComps.forEach(processRow);\n        }\n    };\n    RowRenderer.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    };\n    RowRenderer.prototype.binRowComps = function (recycleRows) {\n        var _this = this;\n        var indexesToRemove;\n        var rowsToRecycle = {};\n        if (recycleRows) {\n            indexesToRemove = [];\n            utils_1._.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n                var rowNode = rowComp.getRowNode();\n                if (utils_1._.exists(rowNode.id)) {\n                    rowsToRecycle[rowNode.id] = rowComp;\n                    delete _this.rowCompsByIndex[index];\n                }\n                else {\n                    indexesToRemove.push(index);\n                }\n            });\n        }\n        else {\n            indexesToRemove = Object.keys(this.rowCompsByIndex);\n        }\n        this.removeRowComps(indexesToRemove);\n        return rowsToRecycle;\n    };\n    // takes array of row indexes\n    RowRenderer.prototype.removeRowComps = function (rowsToRemove) {\n        var _this = this;\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(function (indexToRemove) {\n            var renderedRow = _this.rowCompsByIndex[indexToRemove];\n            renderedRow.destroy();\n            delete _this.rowCompsByIndex[indexToRemove];\n        });\n    };\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    RowRenderer.prototype.redrawAfterScroll = function () {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n    };\n    RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n        // for speedy lookup, dump into map\n        var indexesToDrawMap = {};\n        indexesToDraw.forEach(function (index) { return (indexesToDrawMap[index] = true); });\n        var existingIndexes = Object.keys(this.rowCompsByIndex);\n        var indexesNotToDraw = utils_1._.filter(existingIndexes, function (index) { return !indexesToDrawMap[index]; });\n        this.removeRowComps(indexesNotToDraw);\n    };\n    RowRenderer.prototype.calculateIndexesToDraw = function () {\n        var _this = this;\n        // all in all indexes in the viewport\n        var indexesToDraw = utils_1._.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n        // add in indexes of rows we want to keep, because they are currently editing\n        utils_1._.iterateObject(this.rowCompsByIndex, function (indexStr, rowComp) {\n            var index = Number(indexStr);\n            if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n                if (_this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        });\n        indexesToDraw.sort(function (a, b) { return a - b; });\n        return indexesToDraw;\n    };\n    RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n        var _this = this;\n        if (animate === void 0) { animate = false; }\n        if (afterScroll === void 0) { afterScroll = false; }\n        this.maxDivHeightScaler.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        var indexesToDraw = this.calculateIndexesToDraw();\n        this.removeRowCompsNotToDraw(indexesToDraw);\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n        // add in new rows\n        var nextVmTurnFunctions = [];\n        var rowComps = [];\n        indexesToDraw.forEach(function (rowIndex) {\n            var rowComp = _this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (utils_1._.exists(rowComp)) {\n                rowComps.push(rowComp);\n                utils_1._.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());\n            }\n        });\n        this.flushContainers(rowComps);\n        utils_1._.executeNextVMTurn(nextVmTurnFunctions);\n        var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n        if (useAnimationFrame) {\n            this.beans.taskQueue.addP2Task(this.destroyRowComps.bind(this, rowsToRecycle, animate));\n        }\n        else {\n            this.destroyRowComps(rowsToRecycle, animate);\n        }\n        this.checkAngularCompile();\n        this.gridPanel.updateRowCount();\n    };\n    RowRenderer.prototype.flushContainers = function (rowComps) {\n        utils_1._.iterateObject(this.rowContainers, function (key, rowContainerComp) {\n            if (rowContainerComp) {\n                rowContainerComp.flushRowTemplates();\n            }\n        });\n        rowComps.forEach(function (rowComp) { return rowComp.afterFlush(); });\n    };\n    RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n        var pinningLeft = this.columnController.isPinningLeft();\n        var pinningRight = this.columnController.isPinningRight();\n        var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    };\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        var rowsToRemove = [];\n        utils_1._.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n            if (rowComp.isFullWidth()) {\n                var rowIndex = rowComp.getRowNode().rowIndex;\n                rowsToRemove.push(rowIndex.toString());\n            }\n        });\n        this.refreshFloatingRowComps();\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.refreshFullWidthRows = function () {\n        var rowsToRemove = [];\n        utils_1._.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n            if (rowComp.isFullWidth()) {\n                var fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n                if (!fullWidthRowsRefreshed) {\n                    var rowIndex = rowComp.getRowNode().rowIndex;\n                    rowsToRemove.push(rowIndex.toString());\n                }\n            }\n        });\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.createOrUpdateRowComp = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n        var rowNode;\n        var rowComp = this.rowCompsByIndex[rowIndex];\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowComp) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (utils_1._.exists(rowNode) && utils_1._.exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n                rowComp = rowsToRecycle[rowNode.id];\n                rowsToRecycle[rowNode.id] = null;\n            }\n        }\n        var creatingNewRowComp = !rowComp;\n        if (creatingNewRowComp) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n            if (utils_1._.exists(rowNode)) {\n                rowComp = this.createRowComp(rowNode, animate, afterScroll);\n            }\n            else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        }\n        else {\n            // ensure row comp is in right position in DOM\n            rowComp.ensureDomOrder();\n        }\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n        this.rowCompsByIndex[rowIndex] = rowComp;\n        return rowComp;\n    };\n    RowRenderer.prototype.destroyRowComps = function (rowCompsMap, animate) {\n        var delayedFuncs = [];\n        utils_1._.iterateObject(rowCompsMap, function (nodeId, rowComp) {\n            // if row was used, then it's null\n            if (!rowComp) {\n                return;\n            }\n            rowComp.destroy(animate);\n            utils_1._.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());\n        });\n        utils_1._.executeInAWhile(delayedFuncs);\n    };\n    RowRenderer.prototype.checkAngularCompile = function () {\n        var _this = this;\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n        var newFirst;\n        var newLast;\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        }\n        else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        }\n        else {\n            var paginationOffset = this.paginationProxy.getPixelOffset();\n            var maxDivHeightScaler = this.maxDivHeightScaler.getOffset();\n            var bodyVRange = this.gridPanel.getVScrollPosition();\n            var bodyTopPixel = bodyVRange.top;\n            var bodyBottomPixel = bodyVRange.bottom;\n            var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n            var firstPixel = bodyTopPixel + paginationOffset + maxDivHeightScaler - bufferPixels;\n            var lastPixel = bodyBottomPixel + paginationOffset + maxDivHeightScaler + bufferPixels;\n            this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n            var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n            var pageFirstRow = this.paginationProxy.getPageFirstRow();\n            var pageLastRow = this.paginationProxy.getPageLastRow();\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_NORMAL;\n        var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n        var firstDiffers = newFirst !== this.firstRenderedRow;\n        var lastDiffers = newLast !== this.lastRenderedRow;\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n            var event_1 = {\n                type: events_1.Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        if (this.paginationProxy.isRowsToRender()) {\n            var event_2 = {\n                type: events_1.Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEventOnce(event_2);\n        }\n    };\n    RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        var rowHeightsChanged = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n        if (rowHeightsChanged) {\n            // if row heights have changed, we need to resize the containers the rows sit it\n            this.sizeContainerToPageHeight();\n            // we also need to update heightScaler as this has dependency of row container height\n            this.maxDivHeightScaler.updateOffset();\n        }\n    };\n    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n        return this.firstRenderedRow;\n    };\n    RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n        return this.lastRenderedRow;\n    };\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n        var REMOVE_ROW = false;\n        var KEEP_ROW = true;\n        var rowNode = rowComp.getRowNode();\n        var rowHasFocus = this.focusedCellController.isRowNodeFocused(rowNode);\n        var rowIsEditing = rowComp.isEditing();\n        var rowIsDetail = rowNode.detail;\n        var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    };\n    RowRenderer.prototype.createRowComp = function (rowNode, animate, afterScroll) {\n        var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n        var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n        var rowComp = new rowComp_1.RowComp(this.$scope, this.rowContainers.body, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight, this.rowContainers.fullWidth, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout, this.embedFullWidthRows);\n        rowComp.init();\n        return rowComp;\n    };\n    RowRenderer.prototype.getRenderedNodes = function () {\n        var renderedRows = this.rowCompsByIndex;\n        return Object.keys(renderedRows).map(function (key) {\n            return renderedRows[key].getRowNode();\n        });\n    };\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    RowRenderer.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        var nextCell = currentCell;\n        var finished = false;\n        while (!finished) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === constants_1.Constants.KEY_LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            }\n            else if (key === constants_1.Constants.KEY_RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            var hitEdgeOfGrid = utils_1._.missing(nextCell);\n            if (hitEdgeOfGrid) {\n                finished = true;\n                continue;\n            }\n            var rowNode = this.rowPositionUtils.getRowNode(nextCell);\n            // we do not allow focusing on full width rows, this includes details rows\n            if (rowNode.detail) {\n                continue;\n            }\n            // if not a group, then we have a valid row, so quit the search\n            if (!rowNode.group) {\n                finished = true;\n                continue;\n            }\n            // full width rows cannot be focused, so if it's a group and using full width rows,\n            // we need to skip over the row\n            var pivotMode = this.columnController.isPivotMode();\n            var usingFullWidthRows = this.gridOptionsWrapper.isGroupUseEntireRow(pivotMode);\n            if (!usingFullWidthRows) {\n                finished = true;\n            }\n        }\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (utils_1._.exists(userFunc)) {\n                var params = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                var userCell = userFunc(params);\n                if (utils_1._.exists(userCell)) {\n                    if (userCell.floating) {\n                        utils_1._.doOnce(function () { console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    };\n                }\n                else {\n                    nextCell = null;\n                }\n            }\n        }\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) {\n            return;\n        }\n        // in case we have col spanning we get the cellComp and use it to\n        // get the position. This was we always focus the first cell inside\n        // the spanning.\n        this.ensureCellVisible(nextCell); // ensureCellVisible first, to make sure nextCell is rendered\n        var cellComp = this.getComponentForCell(nextCell);\n        nextCell = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(nextCell);\n        this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.rowPinned, true);\n        if (this.rangeController) {\n            this.rangeController.setRangeToCell(nextCell);\n        }\n    };\n    RowRenderer.prototype.getLastCellOfColSpan = function (cell) {\n        var cellComp = this.getComponentForCell(cell);\n        if (!cellComp) {\n            return cell;\n        }\n        var colSpanningList = cellComp.getColSpanningList();\n        if (colSpanningList.length === 1) {\n            return cell;\n        }\n        return {\n            rowIndex: cell.rowIndex,\n            column: utils_1._.last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    };\n    RowRenderer.prototype.ensureCellVisible = function (gridCell) {\n        // this scrolls the row into view\n        if (utils_1._.missing(gridCell.rowPinned)) {\n            this.gridPanel.ensureIndexVisible(gridCell.rowIndex);\n        }\n        if (!gridCell.column.isPinned()) {\n            this.gridPanel.ensureColumnVisible(gridCell.column);\n        }\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {\n        var cell = this.getComponentForCell(gridCell);\n        if (cell) {\n            cell.startRowOrCellEdit(keyPress, charPress);\n        }\n    };\n    RowRenderer.prototype.getComponentForCell = function (cellPosition) {\n        var rowComponent;\n        switch (cellPosition.rowPinned) {\n            case constants_1.Constants.PINNED_TOP:\n                rowComponent = this.floatingTopRowComps[cellPosition.rowIndex];\n                break;\n            case constants_1.Constants.PINNED_BOTTOM:\n                rowComponent = this.floatingBottomRowComps[cellPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowCompsByIndex[cellPosition.rowIndex];\n                break;\n        }\n        if (!rowComponent) {\n            return null;\n        }\n        var cellComponent = rowComponent.getRenderedCellForColumn(cellPosition.column);\n        return cellComponent;\n    };\n    RowRenderer.prototype.getRowNode = function (gridRow) {\n        switch (gridRow.rowPinned) {\n            case constants_1.Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case constants_1.Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    };\n    RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {\n        var backwards = keyboardEvent.shiftKey;\n        var success = this.moveToCellAfter(previousRenderedCell, backwards);\n        if (success) {\n            keyboardEvent.preventDefault();\n        }\n    };\n    RowRenderer.prototype.tabToNextCell = function (backwards) {\n        var focusedCell = this.focusedCellController.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (utils_1._.missing(focusedCell)) {\n            return false;\n        }\n        var renderedCell = this.getComponentForCell(focusedCell);\n        // if cell is not rendered, means user has scrolled away from the cell\n        if (utils_1._.missing(renderedCell)) {\n            return false;\n        }\n        var result = this.moveToCellAfter(renderedCell, backwards);\n        return result;\n    };\n    RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {\n        var editing = previousRenderedCell.isEditing();\n        var res;\n        if (editing) {\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previousRenderedCell, backwards);\n            }\n            else {\n                res = this.moveToNextEditingCell(previousRenderedCell, backwards);\n            }\n        }\n        else {\n            res = this.moveToNextCellNotEditing(previousRenderedCell, backwards);\n        }\n        return res;\n    };\n    RowRenderer.prototype.moveToNextEditingCell = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousRenderedCell.stopEditing();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n        var foundCell = utils_1._.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.startEditingIfEnabled(null, null, true);\n            nextRenderedCell.focusCell(false);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveToNextEditingRow = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n        var foundCell = utils_1._.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveToNextCellNotEditing = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n        var foundCell = utils_1._.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.focusCell(true);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveEditToNextCellOrRow = function (previousRenderedCell, nextRenderedCell) {\n        var pGridCell = previousRenderedCell.getCellPosition();\n        var nGridCell = nextRenderedCell.getCellPosition();\n        var rowsMatch = pGridCell.rowIndex === nGridCell.rowIndex && pGridCell.rowPinned === nGridCell.rowPinned;\n        if (rowsMatch) {\n            // same row, so we don't start / stop editing, we just move the focus along\n            previousRenderedCell.setFocusOutOnEditor();\n            nextRenderedCell.setFocusInOnEditor();\n        }\n        else {\n            var pRow = previousRenderedCell.getRenderedRow();\n            var nRow = nextRenderedCell.getRenderedRow();\n            previousRenderedCell.setFocusOutOnEditor();\n            pRow.stopEditing();\n            nRow.startRowEditing();\n            nextRenderedCell.setFocusInOnEditor();\n        }\n        nextRenderedCell.focusCell();\n    };\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {\n        var nextCell = gridCell;\n        while (true) {\n            if (!backwards) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);\n            // allow user to override what cell to go to next\n            var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n            if (utils_1._.exists(userFunc)) {\n                var params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: gridCell,\n                    nextCellPosition: nextCell ? nextCell : null\n                };\n                var userCell = userFunc(params);\n                if (utils_1._.exists(userCell)) {\n                    if (userCell.floating) {\n                        utils_1._.doOnce(function () { console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextCell = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    };\n                }\n                else {\n                    nextCell = null;\n                }\n            }\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextCell) {\n                return null;\n            }\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            if (startEditing) {\n                var rowNode = this.lookupRowNodeForCell(nextCell);\n                var cellIsEditable = nextCell.column.isCellEditable(rowNode);\n                if (!cellIsEditable) {\n                    continue;\n                }\n            }\n            // this scrolls the row into view\n            var cellIsNotFloating = utils_1._.missing(nextCell.rowPinned);\n            if (cellIsNotFloating) {\n                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);\n            }\n            // pinned columns don't scroll, so no need to ensure index visible\n            if (!nextCell.column.isPinned()) {\n                this.gridPanel.ensureColumnVisible(nextCell.column);\n            }\n            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n            // floating cell, the scrolls get out of sync\n            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n            // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp\n            // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.\n            this.animationFrameService.flushAllFrames();\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            var nextCellComp = this.getComponentForCell(nextCell);\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (utils_1._.missing(nextCellComp)) {\n                continue;\n            }\n            if (nextCellComp.isSuppressNavigable()) {\n                continue;\n            }\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeController) {\n                this.rangeController.setRangeToCell(nextCell);\n            }\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCellComp;\n        }\n    };\n    RowRenderer.prototype.lookupRowNodeForCell = function (cell) {\n        if (cell.rowPinned === constants_1.Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n        if (cell.rowPinned === constants_1.Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n        return this.paginationProxy.getRow(cell.rowIndex);\n    };\n    __decorate([\n        context_1.Autowired(\"paginationProxy\"),\n        __metadata(\"design:type\", paginationProxy_1.PaginationProxy)\n    ], RowRenderer.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        context_1.Autowired(\"columnController\"),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], RowRenderer.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired(\"gridOptionsWrapper\"),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], RowRenderer.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired(\"$scope\"),\n        __metadata(\"design:type\", Object)\n    ], RowRenderer.prototype, \"$scope\", void 0);\n    __decorate([\n        context_1.Autowired(\"eventService\"),\n        __metadata(\"design:type\", eventService_1.EventService)\n    ], RowRenderer.prototype, \"eventService\", void 0);\n    __decorate([\n        context_1.Autowired(\"pinnedRowModel\"),\n        __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)\n    ], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        context_1.Autowired(\"rowModel\"),\n        __metadata(\"design:type\", Object)\n    ], RowRenderer.prototype, \"rowModel\", void 0);\n    __decorate([\n        context_1.Autowired(\"loggerFactory\"),\n        __metadata(\"design:type\", logger_1.LoggerFactory)\n    ], RowRenderer.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        context_1.Autowired(\"focusedCellController\"),\n        __metadata(\"design:type\", focusedCellController_1.FocusedCellController)\n    ], RowRenderer.prototype, \"focusedCellController\", void 0);\n    __decorate([\n        context_1.Autowired(\"cellNavigationService\"),\n        __metadata(\"design:type\", cellNavigationService_1.CellNavigationService)\n    ], RowRenderer.prototype, \"cellNavigationService\", void 0);\n    __decorate([\n        context_1.Autowired(\"columnApi\"),\n        __metadata(\"design:type\", columnApi_1.ColumnApi)\n    ], RowRenderer.prototype, \"columnApi\", void 0);\n    __decorate([\n        context_1.Autowired(\"gridApi\"),\n        __metadata(\"design:type\", gridApi_1.GridApi)\n    ], RowRenderer.prototype, \"gridApi\", void 0);\n    __decorate([\n        context_1.Autowired(\"beans\"),\n        __metadata(\"design:type\", beans_1.Beans)\n    ], RowRenderer.prototype, \"beans\", void 0);\n    __decorate([\n        context_1.Autowired(\"maxDivHeightScaler\"),\n        __metadata(\"design:type\", maxDivHeightScaler_1.MaxDivHeightScaler)\n    ], RowRenderer.prototype, \"maxDivHeightScaler\", void 0);\n    __decorate([\n        context_1.Autowired(\"animationFrameService\"),\n        __metadata(\"design:type\", animationFrameService_1.AnimationFrameService)\n    ], RowRenderer.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        context_1.Autowired(\"rowPositionUtils\"),\n        __metadata(\"design:type\", rowPosition_1.RowPositionUtils)\n    ], RowRenderer.prototype, \"rowPositionUtils\", void 0);\n    __decorate([\n        context_1.Optional(\"rangeController\"),\n        __metadata(\"design:type\", Object)\n    ], RowRenderer.prototype, \"rangeController\", void 0);\n    __decorate([\n        __param(0, context_1.Qualifier(\"loggerFactory\")),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], RowRenderer.prototype, \"agWire\", null);\n    RowRenderer = __decorate([\n        context_1.Bean(\"rowRenderer\")\n    ], RowRenderer);\n    return RowRenderer;\n}(beanStub_1.BeanStub));\nexports.RowRenderer = RowRenderer;\n"]},"metadata":{},"sourceType":"script"}