{"ast":null,"code":"/**\n * @module ol/style/RegularShape\n */\nimport { inherits } from '../util.js';\nimport { asColorLike } from '../colorlike.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { CANVAS_LINE_DASH } from '../has.js';\nimport ImageState from '../ImageState.js';\nimport { defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit } from '../render/canvas.js';\nimport ImageStyle from '../style/Image.js';\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {module:ol/style/Fill} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate\n * when drawing the shape in the output canvas. If `false` fractional numbers may be used. Using `true` allows for\n * \"sharp\" rendering (no blur), while using `false` allows for \"accurate\" rendering. Note that accuracy is important if\n * the shape's position is animated. Without it, the shape may jitter noticeably.\n * @property {module:ol/style/Stroke} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {module:ol/colorlike~ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array.<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n *\n * @constructor\n * @param {module:ol/style/RegularShape~Options} options Options.\n * @extends {module:ol/style/Image}\n * @api\n */\n\nconst RegularShape = function (options) {\n  /**\n   * @private\n   * @type {Array.<string>}\n   */\n  this.checksums_ = null;\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = null;\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.hitDetectionCanvas_ = null;\n  /**\n   * @private\n   * @type {module:ol/style/Fill}\n   */\n\n  this.fill_ = options.fill !== undefined ? options.fill : null;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this.origin_ = [0, 0];\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.points_ = options.points;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.radius_ =\n  /** @type {number} */\n  options.radius !== undefined ? options.radius : options.radius1;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.radius2_ = options.radius2;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.angle_ = options.angle !== undefined ? options.angle : 0;\n  /**\n   * @private\n   * @type {module:ol/style/Stroke}\n   */\n\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this.anchor_ = null;\n  /**\n   * @private\n   * @type {module:ol/size~Size}\n   */\n\n  this.size_ = null;\n  /**\n   * @private\n   * @type {module:ol/size~Size}\n   */\n\n  this.imageSize_ = null;\n  /**\n   * @private\n   * @type {module:ol/size~Size}\n   */\n\n  this.hitDetectionImageSize_ = null;\n  /**\n   * @protected\n   * @type {module:ol/style/AtlasManager|undefined}\n   */\n\n  this.atlasManager_ = options.atlasManager;\n  this.render_(this.atlasManager_);\n  /**\n   * @type {boolean}\n   */\n\n  const snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;\n  /**\n   * @type {boolean}\n   */\n\n  const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n  ImageStyle.call(this, {\n    opacity: 1,\n    rotateWithView: rotateWithView,\n    rotation: options.rotation !== undefined ? options.rotation : 0,\n    scale: 1,\n    snapToPixel: snapToPixel\n  });\n};\n\ninherits(RegularShape, ImageStyle);\n/**\n * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n * @return {module:ol/style/RegularShape} The cloned style.\n * @api\n */\n\nRegularShape.prototype.clone = function () {\n  const style = new RegularShape({\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    points: this.getPoints(),\n    radius: this.getRadius(),\n    radius2: this.getRadius2(),\n    angle: this.getAngle(),\n    snapToPixel: this.getSnapToPixel(),\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n    rotation: this.getRotation(),\n    rotateWithView: this.getRotateWithView(),\n    atlasManager: this.atlasManager_\n  });\n  style.setOpacity(this.getOpacity());\n  style.setScale(this.getScale());\n  return style;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nRegularShape.prototype.getAnchor = function () {\n  return this.anchor_;\n};\n/**\n * Get the angle used in generating the shape.\n * @return {number} Shape's rotation in radians.\n * @api\n */\n\n\nRegularShape.prototype.getAngle = function () {\n  return this.angle_;\n};\n/**\n * Get the fill style for the shape.\n * @return {module:ol/style/Fill} Fill style.\n * @api\n */\n\n\nRegularShape.prototype.getFill = function () {\n  return this.fill_;\n};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.getHitDetectionImage = function (pixelRatio) {\n  return this.hitDetectionCanvas_;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nRegularShape.prototype.getImage = function (pixelRatio) {\n  return this.canvas_;\n};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.getImageSize = function () {\n  return this.imageSize_;\n};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.getHitDetectionImageSize = function () {\n  return this.hitDetectionImageSize_;\n};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.getImageState = function () {\n  return ImageState.LOADED;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nRegularShape.prototype.getOrigin = function () {\n  return this.origin_;\n};\n/**\n * Get the number of points for generating the shape.\n * @return {number} Number of points for stars and regular polygons.\n * @api\n */\n\n\nRegularShape.prototype.getPoints = function () {\n  return this.points_;\n};\n/**\n * Get the (primary) radius for the shape.\n * @return {number} Radius.\n * @api\n */\n\n\nRegularShape.prototype.getRadius = function () {\n  return this.radius_;\n};\n/**\n * Get the secondary radius for the shape.\n * @return {number|undefined} Radius2.\n * @api\n */\n\n\nRegularShape.prototype.getRadius2 = function () {\n  return this.radius2_;\n};\n/**\n * @inheritDoc\n * @api\n */\n\n\nRegularShape.prototype.getSize = function () {\n  return this.size_;\n};\n/**\n * Get the stroke style for the shape.\n * @return {module:ol/style/Stroke} Stroke style.\n * @api\n */\n\n\nRegularShape.prototype.getStroke = function () {\n  return this.stroke_;\n};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.listenImageChange = function (listener, thisArg) {};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.load = function () {};\n/**\n * @inheritDoc\n */\n\n\nRegularShape.prototype.unlistenImageChange = function (listener, thisArg) {};\n/**\n * @protected\n * @param {module:ol/style/AtlasManager|undefined} atlasManager An atlas manager.\n */\n\n\nRegularShape.prototype.render_ = function (atlasManager) {\n  let imageSize;\n  let lineCap = '';\n  let lineJoin = '';\n  let miterLimit = 0;\n  let lineDash = null;\n  let lineDashOffset = 0;\n  let strokeStyle;\n  let strokeWidth = 0;\n\n  if (this.stroke_) {\n    strokeStyle = this.stroke_.getColor();\n\n    if (strokeStyle === null) {\n      strokeStyle = defaultStrokeStyle;\n    }\n\n    strokeStyle = asColorLike(strokeStyle);\n    strokeWidth = this.stroke_.getWidth();\n\n    if (strokeWidth === undefined) {\n      strokeWidth = defaultLineWidth;\n    }\n\n    lineDash = this.stroke_.getLineDash();\n    lineDashOffset = this.stroke_.getLineDashOffset();\n\n    if (!CANVAS_LINE_DASH) {\n      lineDash = null;\n      lineDashOffset = 0;\n    }\n\n    lineJoin = this.stroke_.getLineJoin();\n\n    if (lineJoin === undefined) {\n      lineJoin = defaultLineJoin;\n    }\n\n    lineCap = this.stroke_.getLineCap();\n\n    if (lineCap === undefined) {\n      lineCap = defaultLineCap;\n    }\n\n    miterLimit = this.stroke_.getMiterLimit();\n\n    if (miterLimit === undefined) {\n      miterLimit = defaultMiterLimit;\n    }\n  }\n\n  let size = 2 * (this.radius_ + strokeWidth) + 1;\n  /** @type {module:ol/style/RegularShape~RenderOptions} */\n\n  const renderOptions = {\n    strokeStyle: strokeStyle,\n    strokeWidth: strokeWidth,\n    size: size,\n    lineCap: lineCap,\n    lineDash: lineDash,\n    lineDashOffset: lineDashOffset,\n    lineJoin: lineJoin,\n    miterLimit: miterLimit\n  };\n\n  if (atlasManager === undefined) {\n    // no atlas manager is used, create a new canvas\n    const context = createCanvasContext2D(size, size);\n    this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer\n\n    size = this.canvas_.width;\n    imageSize = size;\n    this.draw_(renderOptions, context, 0, 0);\n    this.createHitDetectionCanvas_(renderOptions);\n  } else {\n    // an atlas manager is used, add the symbol to an atlas\n    size = Math.round(size);\n    const hasCustomHitDetectionImage = !this.fill_;\n    let renderHitDetectionCallback;\n\n    if (hasCustomHitDetectionImage) {\n      // render the hit-detection image into a separate atlas image\n      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);\n    }\n\n    const id = this.getChecksum();\n    const info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);\n    this.canvas_ = info.image;\n    this.origin_ = [info.offsetX, info.offsetY];\n    imageSize = info.image.width;\n\n    if (hasCustomHitDetectionImage) {\n      this.hitDetectionCanvas_ = info.hitImage;\n      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];\n    } else {\n      this.hitDetectionCanvas_ = this.canvas_;\n      this.hitDetectionImageSize_ = [imageSize, imageSize];\n    }\n  }\n\n  this.anchor_ = [size / 2, size / 2];\n  this.size_ = [size, size];\n  this.imageSize_ = [imageSize, imageSize];\n};\n/**\n * @private\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\n * @param {CanvasRenderingContext2D} context The rendering context.\n * @param {number} x The origin for the symbol (x).\n * @param {number} y The origin for the symbol (y).\n */\n\n\nRegularShape.prototype.draw_ = function (renderOptions, context, x, y) {\n  let i, angle0, radiusC; // reset transform\n\n  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n  context.translate(x, y);\n  context.beginPath();\n  let points = this.points_;\n\n  if (points === Infinity) {\n    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n  } else {\n    const radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n    if (radius2 !== this.radius_) {\n      points = 2 * points;\n    }\n\n    for (i = 0; i <= points; i++) {\n      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n      radiusC = i % 2 === 0 ? this.radius_ : radius2;\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n    }\n  }\n\n  if (this.fill_) {\n    let color = this.fill_.getColor();\n\n    if (color === null) {\n      color = defaultFillStyle;\n    }\n\n    context.fillStyle = asColorLike(color);\n    context.fill();\n  }\n\n  if (this.stroke_) {\n    context.strokeStyle = renderOptions.strokeStyle;\n    context.lineWidth = renderOptions.strokeWidth;\n\n    if (renderOptions.lineDash) {\n      context.setLineDash(renderOptions.lineDash);\n      context.lineDashOffset = renderOptions.lineDashOffset;\n    }\n\n    context.lineCap = renderOptions.lineCap;\n    context.lineJoin = renderOptions.lineJoin;\n    context.miterLimit = renderOptions.miterLimit;\n    context.stroke();\n  }\n\n  context.closePath();\n};\n/**\n * @private\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\n */\n\n\nRegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {\n  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n\n  if (this.fill_) {\n    this.hitDetectionCanvas_ = this.canvas_;\n    return;\n  } // if no fill style is set, create an extra hit-detection image with a\n  // default fill style\n\n\n  const context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n  this.hitDetectionCanvas_ = context.canvas;\n  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n};\n/**\n * @private\n * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.\n * @param {CanvasRenderingContext2D} context The context.\n * @param {number} x The origin for the symbol (x).\n * @param {number} y The origin for the symbol (y).\n */\n\n\nRegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {\n  // reset transform\n  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n  context.translate(x, y);\n  context.beginPath();\n  let points = this.points_;\n\n  if (points === Infinity) {\n    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n  } else {\n    const radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n    if (radius2 !== this.radius_) {\n      points = 2 * points;\n    }\n\n    let i, radiusC, angle0;\n\n    for (i = 0; i <= points; i++) {\n      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n      radiusC = i % 2 === 0 ? this.radius_ : radius2;\n      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n    }\n  }\n\n  context.fillStyle = defaultFillStyle;\n  context.fill();\n\n  if (this.stroke_) {\n    context.strokeStyle = renderOptions.strokeStyle;\n    context.lineWidth = renderOptions.strokeWidth;\n\n    if (renderOptions.lineDash) {\n      context.setLineDash(renderOptions.lineDash);\n      context.lineDashOffset = renderOptions.lineDashOffset;\n    }\n\n    context.stroke();\n  }\n\n  context.closePath();\n};\n/**\n * @return {string} The checksum.\n */\n\n\nRegularShape.prototype.getChecksum = function () {\n  const strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';\n  const fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';\n  const recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];\n\n  if (recalculate) {\n    const checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');\n    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];\n  }\n\n  return this.checksums_[0];\n};\n\nexport default RegularShape;","map":null,"metadata":{},"sourceType":"module"}