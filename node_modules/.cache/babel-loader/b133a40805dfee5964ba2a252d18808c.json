{"ast":null,"code":"/**\n * @module ol/interaction/Draw\n */\nimport { inherits } from '../util.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\nimport { getChangeEventType } from '../Object.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\nimport { listen } from '../events.js';\nimport Event from '../events/Event.js';\nimport { noModifierKeys, always, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport Circle from '../geom/Circle.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport { POINTER_TYPE } from '../pointer/MouseSource.js';\nimport Point from '../geom/Point.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport PointerInteraction, { handleEvent as handlePointerEvent } from '../interaction/Pointer.js';\nimport InteractionProperty from '../interaction/Property.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { createEditingStyle } from '../style/Style.js';\n/**\n * @typedef {Object} Options\n * @property {module:ol/geom/GeometryType} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {module:ol/Collection.<module:ol/Feature>} [features]\n * Destination collection for the drawn features.\n * @property {module:ol/source/Vector} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {module:ol/events/condition~Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished.\n * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]\n * Style for sketch features.\n * @property {module:ol/interaction/Draw~GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {module:ol/events/condition~Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {module:ol/events/condition~Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry as\n * arguments, and returns a geometry. The optional existing geometry is the\n * geometry that is returned when the function is called without a second\n * argument.\n * @typedef {function(!Array.<module:ol/coordinate~Coordinate>, module:ol/geom/SimpleGeometry=):\n *     module:ol/geom/SimpleGeometry} GeometryFunction\n */\n\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\n\nconst Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n/**\n * @enum {string}\n */\n\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event module:ol/interaction/Draw~DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n\n  /**\n   * Triggered upon feature draw end\n   * @event module:ol/interaction/Draw~DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n *\n * @constructor\n * @extends {module:ol/events/Event}\n * @param {module:ol/interaction/Draw~DrawEventType} type Type.\n * @param {module:ol/Feature} feature The feature drawn.\n */\n\nconst DrawEvent = function (type, feature) {\n  Event.call(this, type);\n  /**\n   * The feature being drawn.\n   * @type {module:ol/Feature}\n   * @api\n   */\n\n  this.feature = feature;\n};\n\ninherits(DrawEvent, Event);\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @constructor\n * @extends {module:ol/interaction/Pointer}\n * @fires module:ol/interaction/Draw~DrawEvent\n * @param {module:ol/interaction/Draw~Options} options Options.\n * @api\n */\n\nconst Draw = function (options) {\n  PointerInteraction.call(this, {\n    handleDownEvent: handleDownEvent,\n    handleEvent: handleEvent,\n    handleUpEvent: handleUpEvent\n  });\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.shouldHandle_ = false;\n  /**\n   * @type {module:ol~Pixel}\n   * @private\n   */\n\n  this.downPx_ = null;\n  /**\n   * @type {number|undefined}\n   * @private\n   */\n\n  this.downTimeout_;\n  /**\n   * @type {number|undefined}\n   * @private\n   */\n\n  this.lastDragTime_;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.freehand_ = false;\n  /**\n   * Target source for drawn features.\n   * @type {module:ol/source/Vector}\n   * @private\n   */\n\n  this.source_ = options.source ? options.source : null;\n  /**\n   * Target collection for drawn features.\n   * @type {module:ol/Collection.<module:ol/Feature>}\n   * @private\n   */\n\n  this.features_ = options.features ? options.features : null;\n  /**\n   * Pixel distance for snapping.\n   * @type {number}\n   * @private\n   */\n\n  this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n  /**\n   * Geometry type.\n   * @type {module:ol/geom/GeometryType}\n   * @private\n   */\n\n  this.type_ =\n  /** @type {module:ol/geom/GeometryType} */\n  options.type;\n  /**\n   * Drawing mode (derived from geometry type.\n   * @type {module:ol/interaction/Draw~Mode}\n   * @private\n   */\n\n  this.mode_ = getMode(this.type_);\n  /**\n   * Stop click, singleclick, and doubleclick events from firing during drawing.\n   * Default is `false`.\n   * @type {boolean}\n   * @private\n   */\n\n  this.stopClick_ = !!options.stopClick;\n  /**\n   * The number of points that must be drawn before a polygon ring or line\n   * string can be finished.  The default is 3 for polygon rings and 2 for\n   * line strings.\n   * @type {number}\n   * @private\n   */\n\n  this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === Mode.POLYGON ? 3 : 2;\n  /**\n   * The number of points that can be drawn before a polygon ring or line string\n   * is finished. The default is no restriction.\n   * @type {number}\n   * @private\n   */\n\n  this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n  /**\n   * A function to decide if a potential finish coordinate is permissible\n   * @private\n   * @type {module:ol/events/condition~Condition}\n   */\n\n  this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n  let geometryFunction = options.geometryFunction;\n\n  if (!geometryFunction) {\n    if (this.type_ === GeometryType.CIRCLE) {\n      /**\n       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates\n       *     The coordinates.\n       * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.\n       * @return {module:ol/geom/SimpleGeometry} A geometry.\n       */\n      geometryFunction = function (coordinates, opt_geometry) {\n        const circle = opt_geometry ?\n        /** @type {module:ol/geom/Circle} */\n        opt_geometry : new Circle([NaN, NaN]);\n        const squaredLength = squaredCoordinateDistance(coordinates[0], coordinates[1]);\n        circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n        return circle;\n      };\n    } else {\n      let Constructor;\n      const mode = this.mode_;\n\n      if (mode === Mode.POINT) {\n        Constructor = Point;\n      } else if (mode === Mode.LINE_STRING) {\n        Constructor = LineString;\n      } else if (mode === Mode.POLYGON) {\n        Constructor = Polygon;\n      }\n      /**\n       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates\n       *     The coordinates.\n       * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.\n       * @return {module:ol/geom/SimpleGeometry} A geometry.\n       */\n\n\n      geometryFunction = function (coordinates, opt_geometry) {\n        let geometry = opt_geometry;\n\n        if (geometry) {\n          if (mode === Mode.POLYGON) {\n            if (coordinates[0].length) {\n              // Add a closing coordinate to match the first\n              geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n            } else {\n              geometry.setCoordinates([]);\n            }\n          } else {\n            geometry.setCoordinates(coordinates);\n          }\n        } else {\n          geometry = new Constructor(coordinates);\n        }\n\n        return geometry;\n      };\n    }\n  }\n  /**\n   * @type {module:ol/interaction/Draw~GeometryFunction}\n   * @private\n   */\n\n\n  this.geometryFunction_ = geometryFunction;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n  /**\n   * Finish coordinate for the feature (first point for polygons, last point for\n   * linestrings).\n   * @type {module:ol/coordinate~Coordinate}\n   * @private\n   */\n\n  this.finishCoordinate_ = null;\n  /**\n   * Sketch feature.\n   * @type {module:ol/Feature}\n   * @private\n   */\n\n  this.sketchFeature_ = null;\n  /**\n   * Sketch point.\n   * @type {module:ol/Feature}\n   * @private\n   */\n\n  this.sketchPoint_ = null;\n  /**\n   * Sketch coordinates. Used when drawing a line or polygon.\n   * @type {module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>}\n   * @private\n   */\n\n  this.sketchCoords_ = null;\n  /**\n   * Sketch line. Used when drawing polygon.\n   * @type {module:ol/Feature}\n   * @private\n   */\n\n  this.sketchLine_ = null;\n  /**\n   * Sketch line coordinates. Used when drawing a polygon or circle.\n   * @type {Array.<module:ol/coordinate~Coordinate>}\n   * @private\n   */\n\n  this.sketchLineCoords_ = null;\n  /**\n   * Squared tolerance for handling up events.  If the squared distance\n   * between a down and up event is greater than this tolerance, up events\n   * will not be handled.\n   * @type {number}\n   * @private\n   */\n\n  this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n  /**\n   * Draw overlay where our sketch features are drawn.\n   * @type {module:ol/layer/Vector}\n   * @private\n   */\n\n  this.overlay_ = new VectorLayer({\n    source: new VectorSource({\n      useSpatialIndex: false,\n      wrapX: options.wrapX ? options.wrapX : false\n    }),\n    style: options.style ? options.style : getDefaultStyleFunction(),\n    updateWhileInteracting: true\n  });\n  /**\n   * Name of the geometry attribute for newly created features.\n   * @type {string|undefined}\n   * @private\n   */\n\n  this.geometryName_ = options.geometryName;\n  /**\n   * @private\n   * @type {module:ol/events/condition~Condition}\n   */\n\n  this.condition_ = options.condition ? options.condition : noModifierKeys;\n  /**\n   * @private\n   * @type {module:ol/events/condition~Condition}\n   */\n\n  this.freehandCondition_;\n\n  if (options.freehand) {\n    this.freehandCondition_ = always;\n  } else {\n    this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n  }\n\n  listen(this, getChangeEventType(InteractionProperty.ACTIVE), this.updateState_, this);\n};\n\ninherits(Draw, PointerInteraction);\n/**\n * @return {module:ol/style/Style~StyleFunction} Styles.\n */\n\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n/**\n * @inheritDoc\n */\n\n\nDraw.prototype.setMap = function (map) {\n  PointerInteraction.prototype.setMap.call(this, map);\n  this.updateState_();\n};\n/**\n * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually\n * draw or finish the drawing.\n * @param {module:ol/MapBrowserEvent} event Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {module:ol/interaction/Draw}\n * @api\n */\n\n\nexport function handleEvent(event) {\n  if (event.originalEvent.type === EventType.CONTEXTMENU) {\n    // Avoid context menu for long taps when drawing on mobile\n    event.preventDefault();\n  }\n\n  this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n  let move = event.type === MapBrowserEventType.POINTERMOVE;\n  let pass = true;\n\n  if (this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n    const now = Date.now();\n\n    if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n      this.downPx_ = event.pixel;\n      this.shouldHandle_ = !this.freehand_;\n      move = true;\n    } else {\n      this.lastDragTime_ = undefined;\n    }\n\n    if (this.shouldHandle_ && this.downTimeout_) {\n      clearTimeout(this.downTimeout_);\n      this.downTimeout_ = undefined;\n    }\n  }\n\n  if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n    this.addToDrawing_(event);\n    pass = false;\n  } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n    pass = false;\n  } else if (move) {\n    pass = event.type === MapBrowserEventType.POINTERMOVE;\n\n    if (pass && this.freehand_) {\n      pass = this.handlePointerMove_(event);\n    } else if (event.pointerEvent.pointerType == POINTER_TYPE || event.type === MapBrowserEventType.POINTERDRAG && !this.downTimeout_) {\n      this.handlePointerMove_(event);\n    }\n  } else if (event.type === MapBrowserEventType.DBLCLICK) {\n    pass = false;\n  }\n\n  return handlePointerEvent.call(this, event) && pass;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} event Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/Draw}\n */\n\nfunction handleDownEvent(event) {\n  this.shouldHandle_ = !this.freehand_;\n\n  if (this.freehand_) {\n    this.downPx_ = event.pixel;\n\n    if (!this.finishCoordinate_) {\n      this.startDrawing_(event);\n    }\n\n    return true;\n  } else if (this.condition_(event)) {\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(function () {\n      this.handlePointerMove_(new MapBrowserPointerEvent(MapBrowserEventType.POINTERMOVE, event.map, event.pointerEvent, event.frameState));\n    }.bind(this), this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} event Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/Draw}\n */\n\n\nfunction handleUpEvent(event) {\n  let pass = true;\n\n  if (this.downTimeout_) {\n    clearTimeout(this.downTimeout_);\n    this.downTimeout_ = undefined;\n  }\n\n  this.handlePointerMove_(event);\n  const circleMode = this.mode_ === Mode.CIRCLE;\n\n  if (this.shouldHandle_) {\n    if (!this.finishCoordinate_) {\n      this.startDrawing_(event);\n\n      if (this.mode_ === Mode.POINT) {\n        this.finishDrawing();\n      }\n    } else if (this.freehand_ || circleMode) {\n      this.finishDrawing();\n    } else if (this.atFinish_(event)) {\n      if (this.finishCondition_(event)) {\n        this.finishDrawing();\n      }\n    } else {\n      this.addToDrawing_(event);\n    }\n\n    pass = false;\n  } else if (this.freehand_) {\n    this.finishCoordinate_ = null;\n    this.abortDrawing_();\n  }\n\n  if (!pass && this.stopClick_) {\n    event.stopPropagation();\n  }\n\n  return pass;\n}\n/**\n * Handle move events.\n * @param {module:ol/MapBrowserEvent} event A move event.\n * @return {boolean} Pass the event to other interactions.\n * @private\n */\n\n\nDraw.prototype.handlePointerMove_ = function (event) {\n  if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n    const downPx = this.downPx_;\n    const clickPx = event.pixel;\n    const dx = downPx[0] - clickPx[0];\n    const dy = downPx[1] - clickPx[1];\n    const squaredDistance = dx * dx + dy * dy;\n    this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;\n\n    if (!this.shouldHandle_) {\n      return true;\n    }\n  }\n\n  if (this.finishCoordinate_) {\n    this.modifyDrawing_(event);\n  } else {\n    this.createOrUpdateSketchPoint_(event);\n  }\n\n  return true;\n};\n/**\n * Determine if an event is within the snapping tolerance of the start coord.\n * @param {module:ol/MapBrowserEvent} event Event.\n * @return {boolean} The event is within the snapping tolerance of the start.\n * @private\n */\n\n\nDraw.prototype.atFinish_ = function (event) {\n  let at = false;\n\n  if (this.sketchFeature_) {\n    let potentiallyDone = false;\n    let potentiallyFinishCoordinates = [this.finishCoordinate_];\n\n    if (this.mode_ === Mode.LINE_STRING) {\n      potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      potentiallyDone = this.sketchCoords_[0].length > this.minPoints_;\n      potentiallyFinishCoordinates = [this.sketchCoords_[0][0], this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];\n    }\n\n    if (potentiallyDone) {\n      const map = event.map;\n\n      for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n        const finishCoordinate = potentiallyFinishCoordinates[i];\n        const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n        const pixel = event.pixel;\n        const dx = pixel[0] - finishPixel[0];\n        const dy = pixel[1] - finishPixel[1];\n        const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n        at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n\n        if (at) {\n          this.finishCoordinate_ = finishCoordinate;\n          break;\n        }\n      }\n    }\n  }\n\n  return at;\n};\n/**\n * @param {module:ol/MapBrowserEvent} event Event.\n * @private\n */\n\n\nDraw.prototype.createOrUpdateSketchPoint_ = function (event) {\n  const coordinates = event.coordinate.slice();\n\n  if (!this.sketchPoint_) {\n    this.sketchPoint_ = new Feature(new Point(coordinates));\n    this.updateSketchFeatures_();\n  } else {\n    const sketchPointGeom =\n    /** @type {module:ol/geom/Point} */\n    this.sketchPoint_.getGeometry();\n    sketchPointGeom.setCoordinates(coordinates);\n  }\n};\n/**\n * Start the drawing.\n * @param {module:ol/MapBrowserEvent} event Event.\n * @private\n */\n\n\nDraw.prototype.startDrawing_ = function (event) {\n  const start = event.coordinate;\n  this.finishCoordinate_ = start;\n\n  if (this.mode_ === Mode.POINT) {\n    this.sketchCoords_ = start.slice();\n  } else if (this.mode_ === Mode.POLYGON) {\n    this.sketchCoords_ = [[start.slice(), start.slice()]];\n    this.sketchLineCoords_ = this.sketchCoords_[0];\n  } else {\n    this.sketchCoords_ = [start.slice(), start.slice()];\n  }\n\n  if (this.sketchLineCoords_) {\n    this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n  }\n\n  const geometry = this.geometryFunction_(this.sketchCoords_);\n  this.sketchFeature_ = new Feature();\n\n  if (this.geometryName_) {\n    this.sketchFeature_.setGeometryName(this.geometryName_);\n  }\n\n  this.sketchFeature_.setGeometry(geometry);\n  this.updateSketchFeatures_();\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n};\n/**\n * Modify the drawing.\n * @param {module:ol/MapBrowserEvent} event Event.\n * @private\n */\n\n\nDraw.prototype.modifyDrawing_ = function (event) {\n  let coordinate = event.coordinate;\n  const geometry =\n  /** @type {module:ol/geom/SimpleGeometry} */\n  this.sketchFeature_.getGeometry();\n  let coordinates, last;\n\n  if (this.mode_ === Mode.POINT) {\n    last = this.sketchCoords_;\n  } else if (this.mode_ === Mode.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n    last = coordinates[coordinates.length - 1];\n\n    if (this.atFinish_(event)) {\n      // snap to finish\n      coordinate = this.finishCoordinate_.slice();\n    }\n  } else {\n    coordinates = this.sketchCoords_;\n    last = coordinates[coordinates.length - 1];\n  }\n\n  last[0] = coordinate[0];\n  last[1] = coordinate[1];\n  this.geometryFunction_(\n  /** @type {!Array.<module:ol/coordinate~Coordinate>} */\n  this.sketchCoords_, geometry);\n\n  if (this.sketchPoint_) {\n    const sketchPointGeom =\n    /** @type {module:ol/geom/Point} */\n    this.sketchPoint_.getGeometry();\n    sketchPointGeom.setCoordinates(coordinate);\n  }\n\n  let sketchLineGeom;\n\n  if (geometry instanceof Polygon && this.mode_ !== Mode.POLYGON) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature(new LineString(null));\n    }\n\n    const ring = geometry.getLinearRing(0);\n    sketchLineGeom =\n    /** @type {module:ol/geom/LineString} */\n    this.sketchLine_.getGeometry();\n    sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n  } else if (this.sketchLineCoords_) {\n    sketchLineGeom =\n    /** @type {module:ol/geom/LineString} */\n    this.sketchLine_.getGeometry();\n    sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n  }\n\n  this.updateSketchFeatures_();\n};\n/**\n * Add a new coordinate to the drawing.\n * @param {module:ol/MapBrowserEvent} event Event.\n * @private\n */\n\n\nDraw.prototype.addToDrawing_ = function (event) {\n  const coordinate = event.coordinate;\n  const geometry =\n  /** @type {module:ol/geom/SimpleGeometry} */\n  this.sketchFeature_.getGeometry();\n  let done;\n  let coordinates;\n\n  if (this.mode_ === Mode.LINE_STRING) {\n    this.finishCoordinate_ = coordinate.slice();\n    coordinates = this.sketchCoords_;\n\n    if (coordinates.length >= this.maxPoints_) {\n      if (this.freehand_) {\n        coordinates.pop();\n      } else {\n        done = true;\n      }\n    }\n\n    coordinates.push(coordinate.slice());\n    this.geometryFunction_(coordinates, geometry);\n  } else if (this.mode_ === Mode.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n\n    if (coordinates.length >= this.maxPoints_) {\n      if (this.freehand_) {\n        coordinates.pop();\n      } else {\n        done = true;\n      }\n    }\n\n    coordinates.push(coordinate.slice());\n\n    if (done) {\n      this.finishCoordinate_ = coordinates[0];\n    }\n\n    this.geometryFunction_(this.sketchCoords_, geometry);\n  }\n\n  this.updateSketchFeatures_();\n\n  if (done) {\n    this.finishDrawing();\n  }\n};\n/**\n * Remove last point of the feature currently being drawn.\n * @api\n */\n\n\nDraw.prototype.removeLastPoint = function () {\n  if (!this.sketchFeature_) {\n    return;\n  }\n\n  const geometry =\n  /** @type {module:ol/geom/SimpleGeometry} */\n  this.sketchFeature_.getGeometry();\n  let coordinates, sketchLineGeom;\n\n  if (this.mode_ === Mode.LINE_STRING) {\n    coordinates = this.sketchCoords_;\n    coordinates.splice(-2, 1);\n    this.geometryFunction_(coordinates, geometry);\n\n    if (coordinates.length >= 2) {\n      this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n    }\n  } else if (this.mode_ === Mode.POLYGON) {\n    coordinates = this.sketchCoords_[0];\n    coordinates.splice(-2, 1);\n    sketchLineGeom =\n    /** @type {module:ol/geom/LineString} */\n    this.sketchLine_.getGeometry();\n    sketchLineGeom.setCoordinates(coordinates);\n    this.geometryFunction_(this.sketchCoords_, geometry);\n  }\n\n  if (coordinates.length === 0) {\n    this.finishCoordinate_ = null;\n  }\n\n  this.updateSketchFeatures_();\n};\n/**\n * Stop drawing and add the sketch feature to the target layer.\n * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n * dispatched before inserting the feature.\n * @api\n */\n\n\nDraw.prototype.finishDrawing = function () {\n  const sketchFeature = this.abortDrawing_();\n\n  if (!sketchFeature) {\n    return;\n  }\n\n  let coordinates = this.sketchCoords_;\n  const geometry =\n  /** @type {module:ol/geom/SimpleGeometry} */\n  sketchFeature.getGeometry();\n\n  if (this.mode_ === Mode.LINE_STRING) {\n    // remove the redundant last point\n    coordinates.pop();\n    this.geometryFunction_(coordinates, geometry);\n  } else if (this.mode_ === Mode.POLYGON) {\n    // remove the redundant last point in ring\n    coordinates[0].pop();\n    this.geometryFunction_(coordinates, geometry);\n    coordinates = geometry.getCoordinates();\n  } // cast multi-part geometries\n\n\n  if (this.type_ === GeometryType.MULTI_POINT) {\n    sketchFeature.setGeometry(new MultiPoint([coordinates]));\n  } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n    sketchFeature.setGeometry(new MultiLineString([coordinates]));\n  } else if (this.type_ === GeometryType.MULTI_POLYGON) {\n    sketchFeature.setGeometry(new MultiPolygon([coordinates]));\n  } // First dispatch event to allow full set up of feature\n\n\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature\n\n  if (this.features_) {\n    this.features_.push(sketchFeature);\n  }\n\n  if (this.source_) {\n    this.source_.addFeature(sketchFeature);\n  }\n};\n/**\n * Stop drawing without adding the sketch feature to the target layer.\n * @return {module:ol/Feature} The sketch feature (or null if none).\n * @private\n */\n\n\nDraw.prototype.abortDrawing_ = function () {\n  this.finishCoordinate_ = null;\n  const sketchFeature = this.sketchFeature_;\n\n  if (sketchFeature) {\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n  }\n\n  return sketchFeature;\n};\n/**\n * Extend an existing geometry by adding additional points. This only works\n * on features with `LineString` geometries, where the interaction will\n * extend lines by adding points to the end of the coordinates array.\n * @param {!module:ol/Feature} feature Feature to be extended.\n * @api\n */\n\n\nDraw.prototype.extend = function (feature) {\n  const geometry = feature.getGeometry();\n  const lineString =\n  /** @type {module:ol/geom/LineString} */\n  geometry;\n  this.sketchFeature_ = feature;\n  this.sketchCoords_ = lineString.getCoordinates();\n  const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n  this.finishCoordinate_ = last.slice();\n  this.sketchCoords_.push(last.slice());\n  this.updateSketchFeatures_();\n  this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n};\n/**\n * @inheritDoc\n */\n\n\nDraw.prototype.shouldStopEvent = FALSE;\n/**\n * Redraw the sketch features.\n * @private\n */\n\nDraw.prototype.updateSketchFeatures_ = function () {\n  const sketchFeatures = [];\n\n  if (this.sketchFeature_) {\n    sketchFeatures.push(this.sketchFeature_);\n  }\n\n  if (this.sketchLine_) {\n    sketchFeatures.push(this.sketchLine_);\n  }\n\n  if (this.sketchPoint_) {\n    sketchFeatures.push(this.sketchPoint_);\n  }\n\n  const overlaySource = this.overlay_.getSource();\n  overlaySource.clear(true);\n  overlaySource.addFeatures(sketchFeatures);\n};\n/**\n * @private\n */\n\n\nDraw.prototype.updateState_ = function () {\n  const map = this.getMap();\n  const active = this.getActive();\n\n  if (!map || !active) {\n    this.abortDrawing_();\n  }\n\n  this.overlay_.setMap(active ? map : null);\n};\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of an\n * `module:ol/geom/Circle~Circle` geometry.\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n *     32.\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a\n *     polygon.\n * @api\n */\n\n\nexport function createRegularPolygon(opt_sides, opt_angle) {\n  return function (coordinates, opt_geometry) {\n    const center = coordinates[0];\n    const end = coordinates[1];\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    const geometry = opt_geometry ?\n    /** @type {module:ol/geom/Polygon} */\n    opt_geometry : fromCircle(new Circle(center), opt_sides);\n    const angle = opt_angle ? opt_angle : Math.atan((end[1] - center[1]) / (end[0] - center[0]));\n    makeRegular(geometry, center, radius, angle);\n    return geometry;\n  };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\n\nexport function createBox() {\n  return function (coordinates, opt_geometry) {\n    const extent = boundingExtent(coordinates);\n    const geometry = opt_geometry || new Polygon(null);\n    geometry.setCoordinates([[getBottomLeft(extent), getBottomRight(extent), getTopRight(extent), getTopLeft(extent), getBottomLeft(extent)]]);\n    return geometry;\n  };\n}\n/**\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\n * their single-part cousins.\n * @param {module:ol/geom/GeometryType} type Geometry type.\n * @return {module:ol/interaction/Draw~Mode} Drawing mode.\n */\n\nfunction getMode(type) {\n  let mode;\n\n  if (type === GeometryType.POINT || type === GeometryType.MULTI_POINT) {\n    mode = Mode.POINT;\n  } else if (type === GeometryType.LINE_STRING || type === GeometryType.MULTI_LINE_STRING) {\n    mode = Mode.LINE_STRING;\n  } else if (type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON) {\n    mode = Mode.POLYGON;\n  } else if (type === GeometryType.CIRCLE) {\n    mode = Mode.CIRCLE;\n  }\n\n  return (\n    /** @type {!module:ol/interaction/Draw~Mode} */\n    mode\n  );\n}\n\nexport default Draw;","map":null,"metadata":{},"sourceType":"module"}