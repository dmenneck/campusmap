{"ast":null,"code":"/**\n * @module ol/format/GML2\n */\nimport { inherits } from '../util.js';\nimport { createOrUpdate } from '../extent.js';\nimport { transformWithOptions } from '../format/Feature.js';\nimport GMLBase, { GMLNS } from '../format/GMLBase.js';\nimport { writeStringTextNode } from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection, transformExtent } from '../proj.js';\nimport { createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender, makeReplacer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\n/**\n * @const\n * @type {string}\n */\n\nconst schemaLocation = GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @constructor\n * @param {module:ol/format/GMLBase~Options=} opt_options Optional configuration object.\n * @extends {module:ol/format/GMLBase}\n * @api\n */\n\nconst GML2 = function (opt_options) {\n  const options =\n  /** @type {module:ol/format/GMLBase~Options} */\n  opt_options ? opt_options : {};\n  GMLBase.call(this, options);\n  this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n  /**\n   * @inheritDoc\n   */\n\n  this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n};\n\ninherits(GML2, GMLBase);\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} Flat coordinates.\n */\n\nGML2.prototype.readFlatCoordinates_ = function (node, objectStack) {\n  const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n  const context =\n  /** @type {module:ol/xml~NodeStackItem} */\n  objectStack[0];\n  const containerSrs = context['srsName'];\n  let axisOrientation = 'enu';\n\n  if (containerSrs) {\n    const proj = getProjection(containerSrs);\n\n    if (proj) {\n      axisOrientation = proj.getAxisOrientation();\n    }\n  }\n\n  const coordsGroups = s.trim().split(/\\s+/);\n  const flatCoordinates = [];\n\n  for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n    const coords = coordsGroups[i].split(/,+/);\n    const x = parseFloat(coords[0]);\n    const y = parseFloat(coords[1]);\n    const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n\n    if (axisOrientation.substr(0, 2) === 'en') {\n      flatCoordinates.push(x, y, z);\n    } else {\n      flatCoordinates.push(y, x, z);\n    }\n  }\n\n  return flatCoordinates;\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/extent~Extent|undefined} Envelope.\n */\n\n\nGML2.prototype.readBox_ = function (node, objectStack) {\n  /** @type {Array.<number>} */\n  const flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);\n  return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\n\n\nGML2.prototype.innerBoundaryIsParser_ = function (node, objectStack) {\n  /** @type {Array.<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n\n  if (flatLinearRing) {\n    const flatLinearRings =\n    /** @type {Array.<Array.<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings.push(flatLinearRing);\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\n\n\nGML2.prototype.outerBoundaryIsParser_ = function (node, objectStack) {\n  /** @type {Array.<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n\n  if (flatLinearRing) {\n    const flatLinearRings =\n    /** @type {Array.<Array.<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings[0] = flatLinearRing;\n  }\n};\n/**\n * @const\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node|undefined} Node.\n * @private\n */\n\n\nGML2.prototype.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n  const context = objectStack[objectStack.length - 1];\n  const multiSurface = context['multiSurface'];\n  const surface = context['surface'];\n  const multiCurve = context['multiCurve'];\n  let nodeName;\n\n  if (!Array.isArray(value)) {\n    nodeName =\n    /** @type {module:ol/geom/Geometry} */\n    value.getType();\n\n    if (nodeName === 'MultiPolygon' && multiSurface === true) {\n      nodeName = 'MultiSurface';\n    } else if (nodeName === 'Polygon' && surface === true) {\n      nodeName = 'Surface';\n    } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n      nodeName = 'MultiCurve';\n    }\n  } else {\n    nodeName = 'Envelope';\n  }\n\n  return createElementNS('http://www.opengis.net/gml', nodeName);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nGML2.prototype.writeFeatureElement = function (node, feature, objectStack) {\n  const fid = feature.getId();\n\n  if (fid) {\n    node.setAttribute('fid', fid);\n  }\n\n  const context =\n  /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const featureNS = context['featureNS'];\n  const geometryName = feature.getGeometryName();\n\n  if (!context.serializers) {\n    context.serializers = {};\n    context.serializers[featureNS] = {};\n  }\n\n  const properties = feature.getProperties();\n  const keys = [];\n  const values = [];\n\n  for (const key in properties) {\n    const value = properties[key];\n\n    if (value !== null) {\n      keys.push(key);\n      values.push(value);\n\n      if (key == geometryName || value instanceof Geometry) {\n        if (!(key in context.serializers[featureNS])) {\n          context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n        }\n      } else {\n        if (!(key in context.serializers[featureNS])) {\n          context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n        }\n      }\n    }\n  }\n\n  const item = assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(\n  /** @type {module:ol/xml~NodeStackItem} */\n  item, context.serializers, makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} geometry LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeCurveOrLineString_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n\n  if (node.nodeName !== 'LineStringSegment' && srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  } else if (node.nodeName === 'Curve') {\n    const segments = createElementNS(node.namespaceURI, 'segments');\n    node.appendChild(segments);\n    this.writeCurveSegments_(segments, geometry, objectStack);\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} line LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeLineStringOrCurveMember_ = function (node, line, objectStack) {\n  const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n\n  if (child) {\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiLineString} geometry MultiLineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeMultiCurveOrLineString_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n  const curve = context['curve'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const lines = geometry.getLineStrings();\n  pushSerializeAndPop({\n    node: node,\n    hasZ: hasZ,\n    srsName: srsName,\n    curve: curve\n  }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Geometry|module:ol/extent~Extent} geometry Geometry.\n * @param {Array.<*>} objectStack Node stack.\n */\n\n\nGML2.prototype.writeGeometryElement = function (node, geometry, objectStack) {\n  const context =\n  /** @type {module:ol/format/Feature~WriteOptions} */\n  objectStack[objectStack.length - 1];\n  const item = assign({}, context);\n  item.node = node;\n  let value;\n\n  if (Array.isArray(geometry)) {\n    if (context.dataProjection) {\n      value = transformExtent(geometry, context.featureProjection, context.dataProjection);\n    } else {\n      value = geometry;\n    }\n  } else {\n    value = transformWithOptions(\n    /** @type {module:ol/geom/Geometry} */\n    geometry, true, context);\n  }\n\n  pushSerializeAndPop(\n  /** @type {module:ol/xml~NodeStackItem} */\n  item, this.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);\n};\n/**\n * @param {string} namespaceURI XML namespace.\n * @returns {Node} coordinates node.\n * @private\n */\n\n\nGML2.prototype.createCoordinatesNode_ = function (namespaceURI) {\n  const coordinates = createElementNS(namespaceURI, 'coordinates');\n  coordinates.setAttribute('decimal', '.');\n  coordinates.setAttribute('cs', ',');\n  coordinates.setAttribute('ts', ' ');\n  return coordinates;\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString|module:ol/geom/LinearRing} value Geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeCoordinates_ = function (node, value, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName']; // only 2d for simple features profile\n\n  const points = value.getCoordinates();\n  const len = points.length;\n  const parts = new Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    const point = points[i];\n    parts[i] = this.getCoords_(point, srsName, hasZ);\n  }\n\n  writeStringTextNode(node, parts.join(' '));\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} line LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeCurveSegments_ = function (node, line, objectStack) {\n  const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n  node.appendChild(child);\n  this.writeCurveOrLineString_(child, line, objectStack);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} geometry Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeSurfaceOrPolygon_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n\n  if (node.nodeName !== 'PolygonPatch' && srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n    const rings = geometry.getLinearRings();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName\n    }, this.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);\n  } else if (node.nodeName === 'Surface') {\n    const patches = createElementNS(node.namespaceURI, 'patches');\n    node.appendChild(patches);\n    this.writeSurfacePatches_(patches, geometry, objectStack);\n  }\n};\n/**\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node} Node.\n * @private\n */\n\n\nGML2.prototype.RING_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n  const context = objectStack[objectStack.length - 1];\n  const parentNode = context.node;\n  const exteriorWritten = context['exteriorWritten'];\n\n  if (exteriorWritten === undefined) {\n    context['exteriorWritten'] = true;\n  }\n\n  return createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeSurfacePatches_ = function (node, polygon, objectStack) {\n  const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n  node.appendChild(child);\n  this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LinearRing} ring LinearRing geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeRing_ = function (node, ring, objectStack) {\n  const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n  node.appendChild(linearRing);\n  this.writeLinearRing_(linearRing, ring, objectStack);\n};\n/**\n * @param {Array.<number>} point Point geometry.\n * @param {string=} opt_srsName Optional srsName\n * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n * @return {string} The coords string.\n * @private\n */\n\n\nGML2.prototype.getCoords_ = function (point, opt_srsName, opt_hasZ) {\n  let axisOrientation = 'enu';\n\n  if (opt_srsName) {\n    axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n  }\n\n  let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];\n\n  if (opt_hasZ) {\n    // For newly created points, Z can be undefined.\n    const z = point[2] || 0;\n    coords += ',' + z;\n  }\n\n  return coords;\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Point} geometry Point geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writePoint_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n  node.appendChild(coordinates);\n  const point = geometry.getCoordinates();\n  const coord = this.getCoords_(point, srsName, hasZ);\n  writeStringTextNode(coordinates, coord);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiPoint} geometry MultiPoint geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeMultiPoint_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const points = geometry.getPoints();\n  pushSerializeAndPop({\n    node: node,\n    hasZ: hasZ,\n    srsName: srsName\n  }, this.POINTMEMBER_SERIALIZERS_, makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Point} point Point geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writePointMember_ = function (node, point, objectStack) {\n  const child = createElementNS(node.namespaceURI, 'Point');\n  node.appendChild(child);\n  this.writePoint_(child, point, objectStack);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LinearRing} geometry LinearRing geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeLinearRing_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n  node.appendChild(coordinates);\n  this.writeCoordinates_(coordinates, geometry, objectStack);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeMultiSurfaceOrPolygon_ = function (node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n  const surface = context['surface'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const polygons = geometry.getPolygons();\n  pushSerializeAndPop({\n    node: node,\n    hasZ: hasZ,\n    srsName: srsName,\n    surface: surface\n  }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeSurfaceOrPolygonMember_ = function (node, polygon, objectStack) {\n  const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n\n  if (child) {\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  }\n};\n/**\n * @param {Node} node Node.\n * @param {module:ol/extent~Extent} extent Extent.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\n\n\nGML2.prototype.writeEnvelope = function (node, extent, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n\n  const keys = ['lowerCorner', 'upperCorner'];\n  const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n  pushSerializeAndPop(\n  /** @type {module:ol/xml~NodeStackItem} */\n  {\n    node: node\n  }, this.ENVELOPE_SERIALIZERS_, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);\n};\n/**\n * @const\n * @type {Object.<string, string>}\n */\n\n\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n/**\n * @const\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node|undefined} Node.\n * @private\n */\n\nGML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS('http://www.opengis.net/gml', MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\n\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser_,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser_\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\n\nGML2.prototype.GEOMETRY_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.GEOMETRY_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString_),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString_),\n    'Point': makeChildAppender(GML2.prototype.writePoint_),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint_),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString_),\n    'MultiLineString': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString_),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing_),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon_),\n    'MultiPolygon': makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon_),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon_),\n    'MultiSurface': makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon_),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope)\n  }\n};\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(GML2.prototype.writeLineStringOrCurveMember_),\n    'curveMember': makeChildAppender(GML2.prototype.writeLineStringOrCurveMember_)\n  }\n};\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.RING_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing_),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing_)\n  }\n};\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.POINTMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember_)\n  }\n};\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember_),\n    'polygonMember': makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember_)\n  }\n};\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\n\nGML2.prototype.ENVELOPE_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\nexport default GML2;","map":null,"metadata":{},"sourceType":"module"}