{"ast":null,"code":"/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport Within from './filter/Within.js';\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!And} `<And>` operator.\n * @api\n */\n\nexport function and(conditions) {\n  var params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params))();\n}\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!Or} `<Or>` operator.\n * @api\n */\n\nexport function or(conditions) {\n  var params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params))();\n}\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @returns {!Not} `<Not>` operator.\n * @api\n */\n\nexport function not(condition) {\n  return new Not(condition);\n}\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Bbox} `<BBOX>` operator.\n * @api\n */\n\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Contains} `<Contains>` operator.\n * @api\n */\n\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Intersects} `<Intersects>` operator.\n * @api\n */\n\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Within} `<Within>` operator.\n * @api\n */\n\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\n\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\n\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\n\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\n\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\n\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\n\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\n\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\n\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\n\nexport function like(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!During} `<During>` operator.\n * @api\n */\n\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}","map":{"version":3,"sources":["../../../src/ol/format/filter.js"],"names":["const"],"mappings":"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","sourcesContent":["/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport Within from './filter/Within.js';\n\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params));\n}\n\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params));\n}\n\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @returns {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(propertyName, pattern,\n  opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern,\n    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n"]},"metadata":{},"sourceType":"module"}