{"ast":null,"code":"/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\nimport { assert } from '../asserts.js';\nimport PBF from 'pbf';\nimport FeatureFormat, { transformWithOptions } from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\nimport Projection from '../proj/Projection.js';\nimport Units from '../proj/Units.js';\nimport RenderFeature from '../render/Feature.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * layers.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options=} opt_options Options.\n * @api\n */\n\nvar MVT =\n/*@__PURE__*/\nfunction (FeatureFormat) {\n  function MVT(opt_options) {\n    FeatureFormat.call(this);\n    var options = opt_options ? opt_options : {};\n    /**\n     * @type {Projection}\n     */\n\n    this.dataProjection = new Projection({\n      code: '',\n      units: Units.TILE_PIXELS\n    });\n    /**\n     * @private\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n\n    this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.layerName_ = options.layerName ? options.layerName : 'layer';\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    this.layers_ = options.layers ? options.layers : null;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.extent_ = null;\n  }\n\n  if (FeatureFormat) MVT.__proto__ = FeatureFormat;\n  MVT.prototype = Object.create(FeatureFormat && FeatureFormat.prototype);\n  MVT.prototype.constructor = MVT;\n  /**\n   * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n   * property.\n   * @suppress {missingProperties}\n   * @param {Object} pbf PBF.\n   * @param {Object} feature Raw feature.\n   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n   * @param {Array<number>} ends Array to store ends in.\n   * @private\n   */\n\n  MVT.prototype.readRawGeometry_ = function readRawGeometry_(pbf, feature, flatCoordinates, ends) {\n    pbf.pos = feature.geometry;\n    var end = pbf.readVarint() + pbf.pos;\n    var cmd = 1;\n    var length = 0;\n    var x = 0;\n    var y = 0;\n    var coordsLen = 0;\n    var currentEnd = 0;\n\n    while (pbf.pos < end) {\n      if (!length) {\n        var cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // moveTo\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n\n        flatCoordinates.push(x, y);\n        coordsLen += 2;\n      } else if (cmd === 7) {\n        if (coordsLen > currentEnd) {\n          // close polygon\n          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n      } else {\n        assert(false, 59); // Invalid command found in the PBF\n      }\n    }\n\n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n  };\n  /**\n   * @private\n   * @param {Object} pbf PBF\n   * @param {Object} rawFeature Raw Mapbox feature.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n\n\n  MVT.prototype.createFeature_ = function createFeature_(pbf, rawFeature, opt_options) {\n    var type = rawFeature.type;\n\n    if (type === 0) {\n      return null;\n    }\n\n    var feature;\n    var id = rawFeature.id;\n    var values = rawFeature.properties;\n    values[this.layerName_] = rawFeature.layer.name;\n    var flatCoordinates = [];\n    var ends = [];\n    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n    var geometryType = getGeometryType(type, ends.length);\n\n    if (this.featureClass_ === RenderFeature) {\n      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n    } else {\n      var geom;\n\n      if (geometryType == GeometryType.POLYGON) {\n        var endss = [];\n        var offset = 0;\n        var prevEndIndex = 0;\n\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n\n          if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i));\n            prevEndIndex = i;\n          }\n\n          offset = end;\n        }\n\n        if (endss.length > 1) {\n          geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n        } else {\n          geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n        }\n      } else {\n        geom = geometryType === GeometryType.POINT ? new Point(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.LINE_STRING ? new LineString(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.POLYGON ? new Polygon(flatCoordinates, GeometryLayout.XY, ends) : geometryType === GeometryType.MULTI_POINT ? new MultiPoint(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends) : null;\n      }\n\n      var ctor =\n      /** @type {typeof import(\"../Feature.js\").default} */\n      this.featureClass_;\n      feature = new ctor();\n\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n\n      var geometry =\n      /** @type {import(\"../geom/Geometry.js\").default} */\n      transformWithOptions(geom, false, this.adaptOptions(opt_options));\n      feature.setGeometry(geometry);\n      feature.setId(id);\n      feature.setProperties(values);\n    }\n\n    return feature;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MVT.prototype.getLastExtent = function getLastExtent() {\n    return this.extent_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MVT.prototype.getType = function getType() {\n    return FormatType.ARRAY_BUFFER;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MVT.prototype.readFeatures = function readFeatures(source, opt_options) {\n    var layers = this.layers_;\n    var pbf = new PBF(\n    /** @type {ArrayBuffer} */\n    source);\n    var pbfLayers = pbf.readFields(layersPBFReader, {});\n    /** @type {Array<import(\"../Feature.js\").FeatureLike>} */\n\n    var features = [];\n\n    for (var name in pbfLayers) {\n      if (layers && layers.indexOf(name) == -1) {\n        continue;\n      }\n\n      var pbfLayer = pbfLayers[name];\n\n      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {\n        var rawFeature = readRawFeature(pbf, pbfLayer, i);\n        features.push(this.createFeature_(pbf, rawFeature));\n      }\n\n      this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MVT.prototype.readProjection = function readProjection(source) {\n    return this.dataProjection;\n  };\n  /**\n   * Sets the layers that features will be read from.\n   * @param {Array<string>} layers Layers.\n   * @api\n   */\n\n\n  MVT.prototype.setLayers = function setLayers(layers) {\n    this.layers_ = layers;\n  };\n\n  return MVT;\n}(FeatureFormat);\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {Object} pbf The PBF.\n */\n\n\nfunction layersPBFReader(tag, layers, pbf) {\n  if (tag === 3) {\n    var layer = {\n      keys: [],\n      values: [],\n      features: []\n    };\n    var end = pbf.readVarint() + pbf.pos;\n    pbf.readFields(layerPBFReader, layer, end);\n    layer.length = layer.features.length;\n\n    if (layer.length) {\n      layers[layer.name] = layer;\n    }\n  }\n}\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {Object} pbf The PBF.\n */\n\n\nfunction layerPBFReader(tag, layer, pbf) {\n  if (tag === 15) {\n    layer.version = pbf.readVarint();\n  } else if (tag === 1) {\n    layer.name = pbf.readString();\n  } else if (tag === 5) {\n    layer.extent = pbf.readVarint();\n  } else if (tag === 2) {\n    layer.features.push(pbf.pos);\n  } else if (tag === 3) {\n    layer.keys.push(pbf.readString());\n  } else if (tag === 4) {\n    var value = null;\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      tag = pbf.readVarint() >> 3;\n      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    layer.values.push(value);\n  }\n}\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {Object} pbf The PBF.\n */\n\n\nfunction featurePBFReader(tag, feature, pbf) {\n  if (tag == 1) {\n    feature.id = pbf.readVarint();\n  } else if (tag == 2) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n      var key = feature.layer.keys[pbf.readVarint()];\n      var value = feature.layer.values[pbf.readVarint()];\n      feature.properties[key] = value;\n    }\n  } else if (tag == 3) {\n    feature.type = pbf.readVarint();\n  } else if (tag == 4) {\n    feature.geometry = pbf.pos;\n  }\n}\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @suppress {missingProperties}\n * @param {Object} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\n\n\nfunction readRawFeature(pbf, layer, i) {\n  pbf.pos = layer.features[i];\n  var end = pbf.readVarint() + pbf.pos;\n  var feature = {\n    layer: layer,\n    type: 0,\n    properties: {}\n  };\n  pbf.readFields(featurePBFReader, feature, end);\n  return feature;\n}\n/**\n * @suppress {missingProperties}\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {GeometryType} The geometry type.\n */\n\n\nfunction getGeometryType(type, numEnds) {\n  /** @type {GeometryType} */\n  var geometryType;\n\n  if (type === 1) {\n    geometryType = numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;\n  } else if (type === 2) {\n    geometryType = numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;\n  } else if (type === 3) {\n    geometryType = GeometryType.POLYGON; // MultiPolygon not relevant for rendering - winding order determines\n    // outer rings of polygons.\n  }\n\n  return geometryType;\n}\n\nexport default MVT;","map":{"version":3,"sources":["../../../src/ol/format/MVT.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/format/MVT\n */\n//FIXME Implement projection handling\n\nimport {assert} from '../asserts.js';\nimport PBF from 'pbf';\nimport FeatureFormat, {transformWithOptions} from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {linearRingIsClockwise} from '../geom/flat/orient.js';\nimport Projection from '../proj/Projection.js';\nimport Units from '../proj/Units.js';\nimport RenderFeature from '../render/Feature.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Feature.js\").FeatureClass} [featureClass] Class for features returned by\n * {@link module:ol/format/MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry\n * support at the cost of decreased rendering performance. The default is\n * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.\n * @property {string} [geometryName='geometry'] Geometry name to use when creating features.\n * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.\n * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all\n * layers.\n */\n\n\n/**\n * @classdesc\n * Feature format for reading data in the Mapbox MVT format.\n *\n * @param {Options=} opt_options Options.\n * @api\n */\nclass MVT extends FeatureFormat {\n\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {Projection}\n     */\n    this.dataProjection = new Projection({\n      code: '',\n      units: Units.TILE_PIXELS\n    });\n\n    /**\n     * @private\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n    this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.layerName_ = options.layerName ? options.layerName : 'layer';\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = null;\n\n  }\n\n  /**\n   * Read the raw geometry from the pbf offset stored in a raw feature's geometry\n   * property.\n   * @suppress {missingProperties}\n   * @param {Object} pbf PBF.\n   * @param {Object} feature Raw feature.\n   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.\n   * @param {Array<number>} ends Array to store ends in.\n   * @private\n   */\n  readRawGeometry_(pbf, feature, flatCoordinates, ends) {\n    pbf.pos = feature.geometry;\n\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let coordsLen = 0;\n    let currentEnd = 0;\n\n    while (pbf.pos < end) {\n      if (!length) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) { // moveTo\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n\n        flatCoordinates.push(x, y);\n        coordsLen += 2;\n\n      } else if (cmd === 7) {\n\n        if (coordsLen > currentEnd) {\n          // close polygon\n          flatCoordinates.push(\n            flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n\n      } else {\n        assert(false, 59); // Invalid command found in the PBF\n      }\n    }\n\n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n\n  }\n\n  /**\n   * @private\n   * @param {Object} pbf PBF\n   * @param {Object} rawFeature Raw Mapbox feature.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n  createFeature_(pbf, rawFeature, opt_options) {\n    const type = rawFeature.type;\n    if (type === 0) {\n      return null;\n    }\n\n    let feature;\n    const id = rawFeature.id;\n    const values = rawFeature.properties;\n    values[this.layerName_] = rawFeature.layer.name;\n\n    const flatCoordinates = [];\n    const ends = [];\n    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);\n\n    const geometryType = getGeometryType(type, ends.length);\n\n    if (this.featureClass_ === RenderFeature) {\n      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);\n    } else {\n      let geom;\n      if (geometryType == GeometryType.POLYGON) {\n        const endss = [];\n        let offset = 0;\n        let prevEndIndex = 0;\n        for (let i = 0, ii = ends.length; i < ii; ++i) {\n          const end = ends[i];\n          if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i));\n            prevEndIndex = i;\n          }\n          offset = end;\n        }\n        if (endss.length > 1) {\n          geom = new MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);\n        } else {\n          geom = new Polygon(flatCoordinates, GeometryLayout.XY, ends);\n        }\n      } else {\n        geom = geometryType === GeometryType.POINT ? new Point(flatCoordinates, GeometryLayout.XY) :\n          geometryType === GeometryType.LINE_STRING ? new LineString(flatCoordinates, GeometryLayout.XY) :\n            geometryType === GeometryType.POLYGON ? new Polygon(flatCoordinates, GeometryLayout.XY, ends) :\n              geometryType === GeometryType.MULTI_POINT ? new MultiPoint(flatCoordinates, GeometryLayout.XY) :\n                geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString(flatCoordinates, GeometryLayout.XY, ends) :\n                  null;\n      }\n      const ctor = /** @type {typeof import(\"../Feature.js\").default} */ (this.featureClass_);\n      feature = new ctor();\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n      const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (transformWithOptions(geom, false,\n        this.adaptOptions(opt_options)));\n      feature.setGeometry(geometry);\n      feature.setId(id);\n      feature.setProperties(values);\n    }\n\n    return feature;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getLastExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getType() {\n    return FormatType.ARRAY_BUFFER;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    const layers = this.layers_;\n\n    const pbf = new PBF(/** @type {ArrayBuffer} */ (source));\n    const pbfLayers = pbf.readFields(layersPBFReader, {});\n    /** @type {Array<import(\"../Feature.js\").FeatureLike>} */\n    const features = [];\n    for (const name in pbfLayers) {\n      if (layers && layers.indexOf(name) == -1) {\n        continue;\n      }\n      const pbfLayer = pbfLayers[name];\n\n      for (let i = 0, ii = pbfLayer.length; i < ii; ++i) {\n        const rawFeature = readRawFeature(pbf, pbfLayer, i);\n        features.push(this.createFeature_(pbf, rawFeature));\n      }\n      this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n    }\n\n    return features;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  readProjection(source) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Sets the layers that features will be read from.\n   * @param {Array<string>} layers Layers.\n   * @api\n   */\n  setLayers(layers) {\n    this.layers_ = layers;\n  }\n\n}\n\n\n/**\n * Reader callback for parsing layers.\n * @param {number} tag The tag.\n * @param {Object} layers The layers object.\n * @param {Object} pbf The PBF.\n */\nfunction layersPBFReader(tag, layers, pbf) {\n  if (tag === 3) {\n    const layer = {\n      keys: [],\n      values: [],\n      features: []\n    };\n    const end = pbf.readVarint() + pbf.pos;\n    pbf.readFields(layerPBFReader, layer, end);\n    layer.length = layer.features.length;\n    if (layer.length) {\n      layers[layer.name] = layer;\n    }\n  }\n}\n\n/**\n * Reader callback for parsing layer.\n * @param {number} tag The tag.\n * @param {Object} layer The layer object.\n * @param {Object} pbf The PBF.\n */\nfunction layerPBFReader(tag, layer, pbf) {\n  if (tag === 15) {\n    layer.version = pbf.readVarint();\n  } else if (tag === 1) {\n    layer.name = pbf.readString();\n  } else if (tag === 5) {\n    layer.extent = pbf.readVarint();\n  } else if (tag === 2) {\n    layer.features.push(pbf.pos);\n  } else if (tag === 3) {\n    layer.keys.push(pbf.readString());\n  } else if (tag === 4) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n      tag = pbf.readVarint() >> 3;\n      value = tag === 1 ? pbf.readString() :\n        tag === 2 ? pbf.readFloat() :\n          tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n              tag === 5 ? pbf.readVarint() :\n                tag === 6 ? pbf.readSVarint() :\n                  tag === 7 ? pbf.readBoolean() : null;\n    }\n    layer.values.push(value);\n  }\n}\n\n/**\n * Reader callback for parsing feature.\n * @param {number} tag The tag.\n * @param {Object} feature The feature object.\n * @param {Object} pbf The PBF.\n */\nfunction featurePBFReader(tag, feature, pbf) {\n  if (tag == 1) {\n    feature.id = pbf.readVarint();\n  } else if (tag == 2) {\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n      const key = feature.layer.keys[pbf.readVarint()];\n      const value = feature.layer.values[pbf.readVarint()];\n      feature.properties[key] = value;\n    }\n  } else if (tag == 3) {\n    feature.type = pbf.readVarint();\n  } else if (tag == 4) {\n    feature.geometry = pbf.pos;\n  }\n}\n\n\n/**\n * Read a raw feature from the pbf offset stored at index `i` in the raw layer.\n * @suppress {missingProperties}\n * @param {Object} pbf PBF.\n * @param {Object} layer Raw layer.\n * @param {number} i Index of the feature in the raw layer's `features` array.\n * @return {Object} Raw feature.\n */\nfunction readRawFeature(pbf, layer, i) {\n  pbf.pos = layer.features[i];\n  const end = pbf.readVarint() + pbf.pos;\n\n  const feature = {\n    layer: layer,\n    type: 0,\n    properties: {}\n  };\n  pbf.readFields(featurePBFReader, feature, end);\n  return feature;\n}\n\n\n/**\n * @suppress {missingProperties}\n * @param {number} type The raw feature's geometry type\n * @param {number} numEnds Number of ends of the flat coordinates of the\n * geometry.\n * @return {GeometryType} The geometry type.\n */\nfunction getGeometryType(type, numEnds) {\n  /** @type {GeometryType} */\n  let geometryType;\n  if (type === 1) {\n    geometryType = numEnds === 1 ?\n      GeometryType.POINT : GeometryType.MULTI_POINT;\n  } else if (type === 2) {\n    geometryType = numEnds === 1 ?\n      GeometryType.LINE_STRING :\n      GeometryType.MULTI_LINE_STRING;\n  } else if (type === 3) {\n    geometryType = GeometryType.POLYGON;\n    // MultiPolygon not relevant for rendering - winding order determines\n    // outer rings of polygons.\n  }\n  return geometryType;\n}\n\nexport default MVT;\n"]},"metadata":{},"sourceType":"module"}