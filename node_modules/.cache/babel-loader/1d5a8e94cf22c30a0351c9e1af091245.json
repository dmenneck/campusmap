{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar logger_1 = require(\"../logger\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar utils_1 = require(\"../utils\");\n\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar MoveColumnController =\n/** @class */\nfunction () {\n  function MoveColumnController(pinned, eContainer) {\n    this.needToMoveLeft = false;\n    this.needToMoveRight = false;\n    this.pinned = pinned;\n    this.eContainer = eContainer;\n    this.centerContainer = !utils_1._.exists(pinned);\n  }\n\n  MoveColumnController.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n  };\n\n  MoveColumnController.prototype.init = function () {\n    this.logger = this.loggerFactory.create('MoveColumnController');\n  };\n\n  MoveColumnController.prototype.getIconName = function () {\n    return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;\n  };\n\n  MoveColumnController.prototype.onDragEnter = function (draggingEvent) {\n    // we do dummy drag, so make sure column appears in the right location when first placed\n    var columns = draggingEvent.dragItem.columns;\n    var dragCameFromToolPanel = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;\n\n    if (dragCameFromToolPanel) {\n      // the if statement doesn't work if drag leaves grid, then enters again\n      this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n    } else {\n      // restore previous state of visible columns upon re-entering. this means if the user drags\n      // a group out, and then drags the group back in, only columns that were originally visible\n      // will be visible again. otherwise a group with three columns (but only two visible) could\n      // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n      var visibleState_1 = draggingEvent.dragItem.visibleState;\n      var visibleColumns = columns.filter(function (column) {\n        return visibleState_1[column.getId()];\n      });\n      this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n    }\n\n    this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n    this.onDragging(draggingEvent, true);\n  };\n\n  MoveColumnController.prototype.onDragLeave = function (draggingEvent) {\n    var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n\n    if (hideColumnOnExit) {\n      var dragItem = draggingEvent.dragSource.dragItemCallback();\n      var columns = dragItem.columns;\n      this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n    }\n\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnController.prototype.setColumnsVisible = function (columns, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockVisible;\n      });\n      this.columnController.setColumnsVisible(allowedCols, visible, source);\n    }\n  };\n\n  MoveColumnController.prototype.setColumnsPinned = function (columns, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n      this.columnController.setColumnsPinned(allowedCols, pinned, source);\n    }\n  };\n\n  MoveColumnController.prototype.onDragStop = function () {\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnController.prototype.normaliseX = function (x) {\n    // flip the coordinate if doing RTL\n    var flipHorizontallyForRtl = this.gridOptionsWrapper.isEnableRtl();\n\n    if (flipHorizontallyForRtl) {\n      var clientWidth = this.eContainer.clientWidth;\n      x = clientWidth - x;\n    } // adjust for scroll only if centre container (the pinned containers dont scroll)\n\n\n    var adjustForScroll = this.centerContainer;\n\n    if (adjustForScroll) {\n      x += this.gridPanel.getCenterViewportScrollLeft();\n    }\n\n    return x;\n  };\n\n  MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n    if (this.centerContainer) {\n      // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n      // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n      var firstVisiblePixel = this.gridPanel.getCenterViewportScrollLeft();\n      var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();\n\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;\n      } else {\n        this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;\n      }\n\n      if (this.needToMoveLeft || this.needToMoveRight) {\n        this.ensureIntervalStarted();\n      } else {\n        this.ensureIntervalCleared();\n      }\n    }\n  };\n\n  MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {\n    var _this = this;\n\n    if (fromEnter === void 0) {\n      fromEnter = false;\n    }\n\n    this.lastDraggingEvent = draggingEvent; // if moving up or down (ie not left or right) then do nothing\n\n    if (utils_1._.missing(draggingEvent.hDirection)) {\n      return;\n    }\n\n    var mouseXNormalised = this.normaliseX(draggingEvent.x); // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n    // we don't want to scroll the grid this time, it would appear like the table is jumping\n    // each time a column is dragged in.\n\n    if (!fromEnter) {\n      this.checkCenterForScrolling(mouseXNormalised);\n    }\n\n    var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n    var dragSourceType = draggingEvent.dragSource.type;\n    var columnsToMove = draggingEvent.dragSource.dragItemCallback().columns;\n    columnsToMove = columnsToMove.filter(function (col) {\n      if (col.getColDef().lockPinned) {\n        // if locked return true only if both col and container are same pin type.\n        // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n        return col.getPinned() == _this.pinned;\n      } else {\n        // if not pin locked, then always allowed to be in this container\n        return true;\n      }\n    });\n    this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n  };\n\n  MoveColumnController.prototype.normaliseDirection = function (hDirection) {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      switch (hDirection) {\n        case dragAndDropService_1.HDirection.Left:\n          return dragAndDropService_1.HDirection.Right;\n\n        case dragAndDropService_1.HDirection.Right:\n          return dragAndDropService_1.HDirection.Left;\n\n        default:\n          console.error(\"ag-Grid: Unknown direction \" + hDirection);\n      }\n    } else {\n      return hDirection;\n    }\n  }; // returns the index of the first column in the list ONLY if the cols are all beside\n  // each other. if the cols are not beside each other, then returns null\n\n\n  MoveColumnController.prototype.calculateOldIndex = function (movingCols) {\n    var gridCols = this.columnController.getAllGridColumns();\n    var indexes = [];\n    movingCols.forEach(function (col) {\n      return indexes.push(gridCols.indexOf(col));\n    });\n\n    utils_1._.sortNumberArray(indexes);\n\n    var firstIndex = indexes[0];\n\n    var lastIndex = utils_1._.last(indexes);\n\n    var spread = lastIndex - firstIndex;\n    var gapsExist = spread !== indexes.length - 1;\n    return gapsExist ? null : firstIndex;\n  };\n\n  MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n    var draggingLeft = hDirection === dragAndDropService_1.HDirection.Left;\n    var draggingRight = hDirection === dragAndDropService_1.HDirection.Right;\n    var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, mouseX); // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n    // (ie left or right) to the mouse direction. however\n\n    var oldIndex = this.calculateOldIndex(allMovingColumns);\n\n    if (validMoves.length === 0) {\n      return;\n    }\n\n    var firstValidMove = validMoves[0]; // the two check below stop an error when the user grabs a group my a middle column, then\n    // it is possible the mouse pointer is to the right of a column while been dragged left.\n    // so we need to make sure that the mouse pointer is actually left of the left most column\n    // if moving left, and right of the right most column if moving right\n    // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n    // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n    // place the column to the RHS even if the mouse is moving left and the column is already on\n    // the LHS. otherwise we stick to the rule described above.\n\n    var constrainDirection = oldIndex !== null && !fromEnter; // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n\n    if (dragSourceType == dragAndDropService_1.DragSourceType.HeaderCell) {\n      constrainDirection = oldIndex !== null;\n    }\n\n    if (constrainDirection) {\n      // only allow left drag if this column is moving left\n      if (draggingLeft && firstValidMove >= oldIndex) {\n        return;\n      } // only allow right drag if this column is moving right\n\n\n      if (draggingRight && firstValidMove <= oldIndex) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < validMoves.length; i++) {\n      var move = validMoves[i];\n\n      if (!this.columnController.doesMovePassRules(allMovingColumns, move)) {\n        continue;\n      }\n\n      this.columnController.moveColumns(allMovingColumns, move, \"uiColumnDragged\"); // important to return here, so once we do the first valid move, we don't try do any more\n\n      return;\n    }\n  };\n\n  MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n    // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n    var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned); // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n    // so the result we return has to be and index location for this list\n\n    var allGridCols = this.columnController.getAllGridColumns();\n\n    var colIsMovingFunc = function (col) {\n      return movingCols.indexOf(col) >= 0;\n    };\n\n    var colIsNotMovingFunc = function (col) {\n      return movingCols.indexOf(col) < 0;\n    };\n\n    var movingDisplayedCols = allDisplayedCols.filter(colIsMovingFunc);\n    var otherDisplayedCols = allDisplayedCols.filter(colIsNotMovingFunc);\n    var otherGridCols = allGridCols.filter(colIsNotMovingFunc); // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n    // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n    // col between b and c (so that it is under the mouse position).\n\n    var displayIndex = 0;\n    var availableWidth = mouseX; // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n    // include the width of the moving columns\n\n    if (draggingRight) {\n      var widthOfMovingDisplayedCols_1 = 0;\n      movingDisplayedCols.forEach(function (col) {\n        return widthOfMovingDisplayedCols_1 += col.getActualWidth();\n      });\n      availableWidth -= widthOfMovingDisplayedCols_1;\n    }\n\n    if (availableWidth > 0) {\n      // now count how many of the displayed columns will fit to the left\n      for (var i = 0; i < otherDisplayedCols.length; i++) {\n        var col = otherDisplayedCols[i];\n        availableWidth -= col.getActualWidth();\n\n        if (availableWidth < 0) {\n          break;\n        }\n\n        displayIndex++;\n      } // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n\n\n      if (draggingRight) {\n        displayIndex++;\n      }\n    } // the display index is with respect to all the showing columns, however when we move, it's with\n    // respect to all grid columns, so we need to translate from display index to grid index\n\n\n    var firstValidMove;\n\n    if (displayIndex > 0) {\n      var leftColumn = otherDisplayedCols[displayIndex - 1];\n      firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n    } else {\n      firstValidMove = 0;\n    }\n\n    var validMoves = [firstValidMove]; // add in other valid moves due to hidden columns and married children. for example, a particular\n    // move might break a group that has married children (so move isn't valid), however there could\n    // be hidden columns (not displayed) that we could jump over to make the move valid. because\n    // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n    // not work. for example imagine a group with 9 columns and all columns are hidden except the\n    // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n    // be relative to the not-shown column, however we need to consider the move jumping over all the\n    // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n    // grid, there would be no way to put a column after it (as the grid would only consider beside the\n    // visible column, which would fail valid move rules).\n\n    if (draggingRight) {\n      // if dragging right, then we add all the additional moves to the right. so in other words\n      // if the next move is not valid, find the next move to the right that is valid.\n      var pointer = firstValidMove + 1;\n      var lastIndex = allGridCols.length - 1;\n\n      while (pointer <= lastIndex) {\n        validMoves.push(pointer);\n        pointer++;\n      }\n    } else {\n      // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n      // left. however we also have to consider moves to the right for all hidden columns first.\n      // (this logic is hard to reason with, it was worked out with trial and error,\n      // move observation rather than science).\n      // add moves to the right\n      var pointer = firstValidMove;\n      var lastIndex = allGridCols.length - 1;\n      var displacedCol = allGridCols[pointer];\n\n      while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n        pointer++;\n        validMoves.push(pointer);\n        displacedCol = allGridCols[pointer];\n      } // add moves to the left\n\n\n      pointer = firstValidMove - 1;\n      var firstDisplayIndex = 0;\n\n      while (pointer >= firstDisplayIndex) {\n        validMoves.push(pointer);\n        pointer--;\n      }\n    }\n\n    return validMoves;\n  }; // isHidden takes into account visible=false and group=closed, ie it is not displayed\n\n\n  MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {\n    return displayedColumns.indexOf(col) < 0;\n  };\n\n  MoveColumnController.prototype.ensureIntervalStarted = function () {\n    if (!this.movingIntervalId) {\n      this.intervalCount = 0;\n      this.failedMoveAttempts = 0;\n      this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n\n      if (this.needToMoveLeft) {\n        this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);\n      } else {\n        this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);\n      }\n    }\n  };\n\n  MoveColumnController.prototype.ensureIntervalCleared = function () {\n    if (this.moveInterval) {\n      window.clearInterval(this.movingIntervalId);\n      this.movingIntervalId = null;\n      this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);\n    }\n  };\n\n  MoveColumnController.prototype.moveInterval = function () {\n    // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n    // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n    var pixelsToMove;\n    this.intervalCount++;\n    pixelsToMove = 10 + this.intervalCount * 5;\n\n    if (pixelsToMove > 100) {\n      pixelsToMove = 100;\n    }\n\n    var pixelsMoved;\n\n    if (this.needToMoveLeft) {\n      pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);\n    } else if (this.needToMoveRight) {\n      pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);\n    }\n\n    if (pixelsMoved !== 0) {\n      this.onDragging(this.lastDraggingEvent);\n      this.failedMoveAttempts = 0;\n    } else {\n      // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n      // this is how we achieve pining by dragging the column to the edge of the grid.\n      this.failedMoveAttempts++;\n      var columns = this.lastDraggingEvent.dragItem.columns;\n      var columnsThatCanPin = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n\n      if (columnsThatCanPin.length > 0) {\n        this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);\n\n        if (this.failedMoveAttempts > 7) {\n          var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;\n          this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n          this.dragAndDropService.nudge();\n        }\n      }\n    }\n  };\n\n  __decorate([context_1.Autowired('loggerFactory'), __metadata(\"design:type\", logger_1.LoggerFactory)], MoveColumnController.prototype, \"loggerFactory\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], MoveColumnController.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('dragAndDropService'), __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)], MoveColumnController.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], MoveColumnController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], MoveColumnController.prototype, \"init\", null);\n\n  return MoveColumnController;\n}();\n\nexports.MoveColumnController = MoveColumnController;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/headerRendering/moveColumnController.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","exports","value","context_1","require","logger_1","columnController_1","column_1","utils_1","dragAndDropService_1","gridOptionsWrapper_1","MoveColumnController","pinned","eContainer","needToMoveLeft","needToMoveRight","centerContainer","_","exists","prototype","registerGridComp","gridPanel","init","logger","loggerFactory","create","getIconName","DragAndDropService","ICON_PINNED","ICON_MOVE","onDragEnter","draggingEvent","columns","dragItem","dragCameFromToolPanel","dragSource","type","DragSourceType","ToolPanel","setColumnsVisible","visibleState_1","visibleState","visibleColumns","filter","column","getId","setColumnsPinned","onDragging","onDragLeave","hideColumnOnExit","gridOptionsWrapper","isSuppressDragLeaveHidesColumns","fromNudge","dragItemCallback","ensureIntervalCleared","visible","source","allowedCols","getColDef","lockVisible","columnController","lockPinned","onDragStop","normaliseX","x","flipHorizontallyForRtl","isEnableRtl","clientWidth","adjustForScroll","getCenterViewportScrollLeft","checkCenterForScrolling","xAdjustedForScroll","firstVisiblePixel","lastVisiblePixel","getCenterWidth","ensureIntervalStarted","fromEnter","_this","lastDraggingEvent","missing","hDirection","mouseXNormalised","hDirectionNormalised","normaliseDirection","dragSourceType","columnsToMove","col","getPinned","attemptMoveColumns","HDirection","Left","Right","console","error","calculateOldIndex","movingCols","gridCols","getAllGridColumns","indexes","forEach","push","indexOf","sortNumberArray","firstIndex","lastIndex","last","spread","gapsExist","allMovingColumns","mouseX","draggingLeft","draggingRight","validMoves","calculateValidMoves","oldIndex","firstValidMove","constrainDirection","HeaderCell","move","doesMovePassRules","moveColumns","allDisplayedCols","getDisplayedColumns","allGridCols","colIsMovingFunc","colIsNotMovingFunc","movingDisplayedCols","otherDisplayedCols","otherGridCols","displayIndex","availableWidth","widthOfMovingDisplayedCols_1","getActualWidth","leftColumn","pointer","displacedCol","isColumnHidden","firstDisplayIndex","displayedColumns","movingIntervalId","intervalCount","failedMoveAttempts","window","setInterval","moveInterval","bind","dragAndDropService","setGhostIcon","ICON_LEFT","ICON_RIGHT","clearInterval","pixelsToMove","pixelsMoved","scrollHorizontally","columnsThatCanPin","pinType","Column","PINNED_LEFT","PINNED_RIGHT","nudge","Autowired","LoggerFactory","ColumnController","GridOptionsWrapper","PostConstruct","Function"],"mappings":"AAAA;;;;;;AAMA;;AACA,IAAIA,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC1D,MAAI,OAAON,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACO,QAAf,KAA4B,UAA/D,EAA2E,OAAOP,OAAO,CAACO,QAAR,CAAiBF,CAAjB,EAAoBC,CAApB,CAAP;AAC9E,CAFD;;AAGAT,MAAM,CAACM,cAAP,CAAsBK,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIE,kBAAkB,GAAGF,OAAO,CAAC,sCAAD,CAAhC;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,oBAAD,CAAtB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIK,oBAAoB,GAAGL,OAAO,CAAC,mCAAD,CAAlC;;AACA,IAAIM,oBAAoB,GAAGN,OAAO,CAAC,uBAAD,CAAlC;;AACA,IAAIO,oBAAoB;AAAG;AAAe,YAAY;AAClD,WAASA,oBAAT,CAA8BC,MAA9B,EAAsCC,UAAtC,EAAkD;AAC9C,SAAKC,cAAL,GAAsB,KAAtB;AACA,SAAKC,eAAL,GAAuB,KAAvB;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKG,eAAL,GAAuB,CAACR,OAAO,CAACS,CAAR,CAAUC,MAAV,CAAiBN,MAAjB,CAAxB;AACH;;AACDD,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BC,gBAA/B,GAAkD,UAAUC,SAAV,EAAqB;AACnE,SAAKA,SAAL,GAAiBA,SAAjB;AACH,GAFD;;AAGAV,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BG,IAA/B,GAAsC,YAAY;AAC9C,SAAKC,MAAL,GAAc,KAAKC,aAAL,CAAmBC,MAAnB,CAA0B,sBAA1B,CAAd;AACH,GAFD;;AAGAd,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BO,WAA/B,GAA6C,YAAY;AACrD,WAAO,KAAKd,MAAL,GAAcH,oBAAoB,CAACkB,kBAArB,CAAwCC,WAAtD,GAAoEnB,oBAAoB,CAACkB,kBAArB,CAAwCE,SAAnH;AACH,GAFD;;AAGAlB,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BW,WAA/B,GAA6C,UAAUC,aAAV,EAAyB;AAClE;AACA,QAAIC,OAAO,GAAGD,aAAa,CAACE,QAAd,CAAuBD,OAArC;AACA,QAAIE,qBAAqB,GAAGH,aAAa,CAACI,UAAd,CAAyBC,IAAzB,KAAkC3B,oBAAoB,CAAC4B,cAArB,CAAoCC,SAAlG;;AACA,QAAIJ,qBAAJ,EAA2B;AACvB;AACA,WAAKK,iBAAL,CAAuBP,OAAvB,EAAgC,IAAhC,EAAsC,iBAAtC;AACH,KAHD,MAIK;AACD;AACA;AACA;AACA;AACA,UAAIQ,cAAc,GAAGT,aAAa,CAACE,QAAd,CAAuBQ,YAA5C;AACA,UAAIC,cAAc,GAAGV,OAAO,CAACW,MAAR,CAAe,UAAUC,MAAV,EAAkB;AAAE,eAAOJ,cAAc,CAACI,MAAM,CAACC,KAAP,EAAD,CAArB;AAAwC,OAA3E,CAArB;AACA,WAAKN,iBAAL,CAAuBG,cAAvB,EAAuC,IAAvC,EAA6C,iBAA7C;AACH;;AACD,SAAKI,gBAAL,CAAsBd,OAAtB,EAA+B,KAAKpB,MAApC,EAA4C,iBAA5C;AACA,SAAKmC,UAAL,CAAgBhB,aAAhB,EAA+B,IAA/B;AACH,GAnBD;;AAoBApB,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B6B,WAA/B,GAA6C,UAAUjB,aAAV,EAAyB;AAClE,QAAIkB,gBAAgB,GAAG,CAAC,KAAKC,kBAAL,CAAwBC,+BAAxB,EAAD,IAA8D,CAACpB,aAAa,CAACqB,SAApG;;AACA,QAAIH,gBAAJ,EAAsB;AAClB,UAAIhB,QAAQ,GAAGF,aAAa,CAACI,UAAd,CAAyBkB,gBAAzB,EAAf;AACA,UAAIrB,OAAO,GAAGC,QAAQ,CAACD,OAAvB;AACA,WAAKO,iBAAL,CAAuBP,OAAvB,EAAgC,KAAhC,EAAuC,iBAAvC;AACH;;AACD,SAAKsB,qBAAL;AACH,GARD;;AASA3C,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BoB,iBAA/B,GAAmD,UAAUP,OAAV,EAAmBuB,OAAnB,EAA4BC,MAA5B,EAAoC;AACnF,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIxB,OAAJ,EAAa;AACT,UAAIyB,WAAW,GAAGzB,OAAO,CAACW,MAAR,CAAe,UAAUzD,CAAV,EAAa;AAAE,eAAO,CAACA,CAAC,CAACwE,SAAF,GAAcC,WAAtB;AAAoC,OAAlE,CAAlB;AACA,WAAKC,gBAAL,CAAsBrB,iBAAtB,CAAwCkB,WAAxC,EAAqDF,OAArD,EAA8DC,MAA9D;AACH;AACJ,GAND;;AAOA7C,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B2B,gBAA/B,GAAkD,UAAUd,OAAV,EAAmBpB,MAAnB,EAA2B4C,MAA3B,EAAmC;AACjF,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,KAAT;AAAiB;;AAC1C,QAAIxB,OAAJ,EAAa;AACT,UAAIyB,WAAW,GAAGzB,OAAO,CAACW,MAAR,CAAe,UAAUzD,CAAV,EAAa;AAAE,eAAO,CAACA,CAAC,CAACwE,SAAF,GAAcG,UAAtB;AAAmC,OAAjE,CAAlB;AACA,WAAKD,gBAAL,CAAsBd,gBAAtB,CAAuCW,WAAvC,EAAoD7C,MAApD,EAA4D4C,MAA5D;AACH;AACJ,GAND;;AAOA7C,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B2C,UAA/B,GAA4C,YAAY;AACpD,SAAKR,qBAAL;AACH,GAFD;;AAGA3C,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B4C,UAA/B,GAA4C,UAAUC,CAAV,EAAa;AACrD;AACA,QAAIC,sBAAsB,GAAG,KAAKf,kBAAL,CAAwBgB,WAAxB,EAA7B;;AACA,QAAID,sBAAJ,EAA4B;AACxB,UAAIE,WAAW,GAAG,KAAKtD,UAAL,CAAgBsD,WAAlC;AACAH,MAAAA,CAAC,GAAGG,WAAW,GAAGH,CAAlB;AACH,KANoD,CAOrD;;;AACA,QAAII,eAAe,GAAG,KAAKpD,eAA3B;;AACA,QAAIoD,eAAJ,EAAqB;AACjBJ,MAAAA,CAAC,IAAI,KAAK3C,SAAL,CAAegD,2BAAf,EAAL;AACH;;AACD,WAAOL,CAAP;AACH,GAbD;;AAcArD,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BmD,uBAA/B,GAAyD,UAAUC,kBAAV,EAA8B;AACnF,QAAI,KAAKvD,eAAT,EAA0B;AACtB;AACA;AACA,UAAIwD,iBAAiB,GAAG,KAAKnD,SAAL,CAAegD,2BAAf,EAAxB;AACA,UAAII,gBAAgB,GAAGD,iBAAiB,GAAG,KAAKnD,SAAL,CAAeqD,cAAf,EAA3C;;AACA,UAAI,KAAKxB,kBAAL,CAAwBgB,WAAxB,EAAJ,EAA2C;AACvC,aAAKnD,eAAL,GAAuBwD,kBAAkB,GAAIC,iBAAiB,GAAG,EAAjE;AACA,aAAK1D,cAAL,GAAsByD,kBAAkB,GAAIE,gBAAgB,GAAG,EAA/D;AACH,OAHD,MAIK;AACD,aAAK3D,cAAL,GAAsByD,kBAAkB,GAAIC,iBAAiB,GAAG,EAAhE;AACA,aAAKzD,eAAL,GAAuBwD,kBAAkB,GAAIE,gBAAgB,GAAG,EAAhE;AACH;;AACD,UAAI,KAAK3D,cAAL,IAAuB,KAAKC,eAAhC,EAAiD;AAC7C,aAAK4D,qBAAL;AACH,OAFD,MAGK;AACD,aAAKrB,qBAAL;AACH;AACJ;AACJ,GArBD;;AAsBA3C,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B4B,UAA/B,GAA4C,UAAUhB,aAAV,EAAyB6C,SAAzB,EAAoC;AAC5E,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,MAAAA,SAAS,GAAG,KAAZ;AAAoB;;AAChD,SAAKE,iBAAL,GAAyB/C,aAAzB,CAH4E,CAI5E;;AACA,QAAIvB,OAAO,CAACS,CAAR,CAAU8D,OAAV,CAAkBhD,aAAa,CAACiD,UAAhC,CAAJ,EAAiD;AAC7C;AACH;;AACD,QAAIC,gBAAgB,GAAG,KAAKlB,UAAL,CAAgBhC,aAAa,CAACiC,CAA9B,CAAvB,CAR4E,CAS5E;AACA;AACA;;AACA,QAAI,CAACY,SAAL,EAAgB;AACZ,WAAKN,uBAAL,CAA6BW,gBAA7B;AACH;;AACD,QAAIC,oBAAoB,GAAG,KAAKC,kBAAL,CAAwBpD,aAAa,CAACiD,UAAtC,CAA3B;AACA,QAAII,cAAc,GAAGrD,aAAa,CAACI,UAAd,CAAyBC,IAA9C;AACA,QAAIiD,aAAa,GAAGtD,aAAa,CAACI,UAAd,CAAyBkB,gBAAzB,GAA4CrB,OAAhE;AACAqD,IAAAA,aAAa,GAAGA,aAAa,CAAC1C,MAAd,CAAqB,UAAU2C,GAAV,EAAe;AAChD,UAAIA,GAAG,CAAC5B,SAAJ,GAAgBG,UAApB,EAAgC;AAC5B;AACA;AACA,eAAOyB,GAAG,CAACC,SAAJ,MAAmBV,KAAK,CAACjE,MAAhC;AACH,OAJD,MAKK;AACD;AACA,eAAO,IAAP;AACH;AACJ,KAVe,CAAhB;AAWA,SAAK4E,kBAAL,CAAwBJ,cAAxB,EAAwCC,aAAxC,EAAuDH,oBAAvD,EAA6ED,gBAA7E,EAA+FL,SAA/F;AACH,GA9BD;;AA+BAjE,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BgE,kBAA/B,GAAoD,UAAUH,UAAV,EAAsB;AACtE,QAAI,KAAK9B,kBAAL,CAAwBgB,WAAxB,EAAJ,EAA2C;AACvC,cAAQc,UAAR;AACI,aAAKvE,oBAAoB,CAACgF,UAArB,CAAgCC,IAArC;AAA2C,iBAAOjF,oBAAoB,CAACgF,UAArB,CAAgCE,KAAvC;;AAC3C,aAAKlF,oBAAoB,CAACgF,UAArB,CAAgCE,KAArC;AAA4C,iBAAOlF,oBAAoB,CAACgF,UAArB,CAAgCC,IAAvC;;AAC5C;AAASE,UAAAA,OAAO,CAACC,KAAR,CAAc,gCAAgCb,UAA9C;AAHb;AAKH,KAND,MAOK;AACD,aAAOA,UAAP;AACH;AACJ,GAXD,CAlIkD,CA8IlD;AACA;;;AACArE,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B2E,iBAA/B,GAAmD,UAAUC,UAAV,EAAsB;AACrE,QAAIC,QAAQ,GAAG,KAAKpC,gBAAL,CAAsBqC,iBAAtB,EAAf;AACA,QAAIC,OAAO,GAAG,EAAd;AACAH,IAAAA,UAAU,CAACI,OAAX,CAAmB,UAAUb,GAAV,EAAe;AAAE,aAAOY,OAAO,CAACE,IAAR,CAAaJ,QAAQ,CAACK,OAAT,CAAiBf,GAAjB,CAAb,CAAP;AAA6C,KAAjF;;AACA9E,IAAAA,OAAO,CAACS,CAAR,CAAUqF,eAAV,CAA0BJ,OAA1B;;AACA,QAAIK,UAAU,GAAGL,OAAO,CAAC,CAAD,CAAxB;;AACA,QAAIM,SAAS,GAAGhG,OAAO,CAACS,CAAR,CAAUwF,IAAV,CAAeP,OAAf,CAAhB;;AACA,QAAIQ,MAAM,GAAGF,SAAS,GAAGD,UAAzB;AACA,QAAII,SAAS,GAAGD,MAAM,KAAKR,OAAO,CAAC9G,MAAR,GAAiB,CAA5C;AACA,WAAOuH,SAAS,GAAG,IAAH,GAAUJ,UAA1B;AACH,GAVD;;AAWA5F,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BqE,kBAA/B,GAAoD,UAAUJ,cAAV,EAA0BwB,gBAA1B,EAA4C5B,UAA5C,EAAwD6B,MAAxD,EAAgEjC,SAAhE,EAA2E;AAC3H,QAAIkC,YAAY,GAAG9B,UAAU,KAAKvE,oBAAoB,CAACgF,UAArB,CAAgCC,IAAlE;AACA,QAAIqB,aAAa,GAAG/B,UAAU,KAAKvE,oBAAoB,CAACgF,UAArB,CAAgCE,KAAnE;AACA,QAAIqB,UAAU,GAAG,KAAKC,mBAAL,CAAyBL,gBAAzB,EAA2CG,aAA3C,EAA0DF,MAA1D,CAAjB,CAH2H,CAI3H;AACA;;AACA,QAAIK,QAAQ,GAAG,KAAKpB,iBAAL,CAAuBc,gBAAvB,CAAf;;AACA,QAAII,UAAU,CAAC5H,MAAX,KAAsB,CAA1B,EAA6B;AACzB;AACH;;AACD,QAAI+H,cAAc,GAAGH,UAAU,CAAC,CAAD,CAA/B,CAV2H,CAW3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAII,kBAAkB,GAAGF,QAAQ,KAAK,IAAb,IAAqB,CAACtC,SAA/C,CAnB2H,CAoB3H;;AACA,QAAIQ,cAAc,IAAI3E,oBAAoB,CAAC4B,cAArB,CAAoCgF,UAA1D,EAAsE;AAClED,MAAAA,kBAAkB,GAAGF,QAAQ,KAAK,IAAlC;AACH;;AACD,QAAIE,kBAAJ,EAAwB;AACpB;AACA,UAAIN,YAAY,IAAIK,cAAc,IAAID,QAAtC,EAAgD;AAC5C;AACH,OAJmB,CAKpB;;;AACA,UAAIH,aAAa,IAAII,cAAc,IAAID,QAAvC,EAAiD;AAC7C;AACH;AACJ;;AACD,SAAK,IAAIvH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqH,UAAU,CAAC5H,MAA/B,EAAuCO,CAAC,EAAxC,EAA4C;AACxC,UAAI2H,IAAI,GAAGN,UAAU,CAACrH,CAAD,CAArB;;AACA,UAAI,CAAC,KAAKiE,gBAAL,CAAsB2D,iBAAtB,CAAwCX,gBAAxC,EAA0DU,IAA1D,CAAL,EAAsE;AAClE;AACH;;AACD,WAAK1D,gBAAL,CAAsB4D,WAAtB,CAAkCZ,gBAAlC,EAAoDU,IAApD,EAA0D,iBAA1D,EALwC,CAMxC;;AACA;AACH;AACJ,GA3CD;;AA4CA3G,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B8F,mBAA/B,GAAqD,UAAUlB,UAAV,EAAsBgB,aAAtB,EAAqCF,MAArC,EAA6C;AAC9F;AACA,QAAIY,gBAAgB,GAAG,KAAK7D,gBAAL,CAAsB8D,mBAAtB,CAA0C,KAAK9G,MAA/C,CAAvB,CAF8F,CAG9F;AACA;;AACA,QAAI+G,WAAW,GAAG,KAAK/D,gBAAL,CAAsBqC,iBAAtB,EAAlB;;AACA,QAAI2B,eAAe,GAAG,UAAUtC,GAAV,EAAe;AAAE,aAAOS,UAAU,CAACM,OAAX,CAAmBf,GAAnB,KAA2B,CAAlC;AAAsC,KAA7E;;AACA,QAAIuC,kBAAkB,GAAG,UAAUvC,GAAV,EAAe;AAAE,aAAOS,UAAU,CAACM,OAAX,CAAmBf,GAAnB,IAA0B,CAAjC;AAAqC,KAA/E;;AACA,QAAIwC,mBAAmB,GAAGL,gBAAgB,CAAC9E,MAAjB,CAAwBiF,eAAxB,CAA1B;AACA,QAAIG,kBAAkB,GAAGN,gBAAgB,CAAC9E,MAAjB,CAAwBkF,kBAAxB,CAAzB;AACA,QAAIG,aAAa,GAAGL,WAAW,CAAChF,MAAZ,CAAmBkF,kBAAnB,CAApB,CAV8F,CAW9F;AACA;AACA;;AACA,QAAII,YAAY,GAAG,CAAnB;AACA,QAAIC,cAAc,GAAGrB,MAArB,CAf8F,CAgB9F;AACA;;AACA,QAAIE,aAAJ,EAAmB;AACf,UAAIoB,4BAA4B,GAAG,CAAnC;AACAL,MAAAA,mBAAmB,CAAC3B,OAApB,CAA4B,UAAUb,GAAV,EAAe;AAAE,eAAO6C,4BAA4B,IAAI7C,GAAG,CAAC8C,cAAJ,EAAvC;AAA8D,OAA3G;AACAF,MAAAA,cAAc,IAAIC,4BAAlB;AACH;;AACD,QAAID,cAAc,GAAG,CAArB,EAAwB;AACpB;AACA,WAAK,IAAIvI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoI,kBAAkB,CAAC3I,MAAvC,EAA+CO,CAAC,EAAhD,EAAoD;AAChD,YAAI2F,GAAG,GAAGyC,kBAAkB,CAACpI,CAAD,CAA5B;AACAuI,QAAAA,cAAc,IAAI5C,GAAG,CAAC8C,cAAJ,EAAlB;;AACA,YAAIF,cAAc,GAAG,CAArB,EAAwB;AACpB;AACH;;AACDD,QAAAA,YAAY;AACf,OATmB,CAUpB;;;AACA,UAAIlB,aAAJ,EAAmB;AACfkB,QAAAA,YAAY;AACf;AACJ,KArC6F,CAsC9F;AACA;;;AACA,QAAId,cAAJ;;AACA,QAAIc,YAAY,GAAG,CAAnB,EAAsB;AAClB,UAAII,UAAU,GAAGN,kBAAkB,CAACE,YAAY,GAAG,CAAhB,CAAnC;AACAd,MAAAA,cAAc,GAAGa,aAAa,CAAC3B,OAAd,CAAsBgC,UAAtB,IAAoC,CAArD;AACH,KAHD,MAIK;AACDlB,MAAAA,cAAc,GAAG,CAAjB;AACH;;AACD,QAAIH,UAAU,GAAG,CAACG,cAAD,CAAjB,CAhD8F,CAiD9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIJ,aAAJ,EAAmB;AACf;AACA;AACA,UAAIuB,OAAO,GAAGnB,cAAc,GAAG,CAA/B;AACA,UAAIX,SAAS,GAAGmB,WAAW,CAACvI,MAAZ,GAAqB,CAArC;;AACA,aAAOkJ,OAAO,IAAI9B,SAAlB,EAA6B;AACzBQ,QAAAA,UAAU,CAACZ,IAAX,CAAgBkC,OAAhB;AACAA,QAAAA,OAAO;AACV;AACJ,KATD,MAUK;AACD;AACA;AACA;AACA;AACA;AACA,UAAIA,OAAO,GAAGnB,cAAd;AACA,UAAIX,SAAS,GAAGmB,WAAW,CAACvI,MAAZ,GAAqB,CAArC;AACA,UAAImJ,YAAY,GAAGZ,WAAW,CAACW,OAAD,CAA9B;;AACA,aAAOA,OAAO,IAAI9B,SAAX,IAAwB,KAAKgC,cAAL,CAAoBf,gBAApB,EAAsCc,YAAtC,CAA/B,EAAoF;AAChFD,QAAAA,OAAO;AACPtB,QAAAA,UAAU,CAACZ,IAAX,CAAgBkC,OAAhB;AACAC,QAAAA,YAAY,GAAGZ,WAAW,CAACW,OAAD,CAA1B;AACH,OAbA,CAcD;;;AACAA,MAAAA,OAAO,GAAGnB,cAAc,GAAG,CAA3B;AACA,UAAIsB,iBAAiB,GAAG,CAAxB;;AACA,aAAOH,OAAO,IAAIG,iBAAlB,EAAqC;AACjCzB,QAAAA,UAAU,CAACZ,IAAX,CAAgBkC,OAAhB;AACAA,QAAAA,OAAO;AACV;AACJ;;AACD,WAAOtB,UAAP;AACH,GA5FD,CAvMkD,CAoSlD;;;AACArG,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BqH,cAA/B,GAAgD,UAAUE,gBAAV,EAA4BpD,GAA5B,EAAiC;AAC7E,WAAOoD,gBAAgB,CAACrC,OAAjB,CAAyBf,GAAzB,IAAgC,CAAvC;AACH,GAFD;;AAGA3E,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BwD,qBAA/B,GAAuD,YAAY;AAC/D,QAAI,CAAC,KAAKgE,gBAAV,EAA4B;AACxB,WAAKC,aAAL,GAAqB,CAArB;AACA,WAAKC,kBAAL,GAA0B,CAA1B;AACA,WAAKF,gBAAL,GAAwBG,MAAM,CAACC,WAAP,CAAmB,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAAnB,EAAiD,GAAjD,CAAxB;;AACA,UAAI,KAAKnI,cAAT,EAAyB;AACrB,aAAKoI,kBAAL,CAAwBC,YAAxB,CAAqC1I,oBAAoB,CAACkB,kBAArB,CAAwCyH,SAA7E,EAAwF,IAAxF;AACH,OAFD,MAGK;AACD,aAAKF,kBAAL,CAAwBC,YAAxB,CAAqC1I,oBAAoB,CAACkB,kBAArB,CAAwC0H,UAA7E,EAAyF,IAAzF;AACH;AACJ;AACJ,GAZD;;AAaA1I,EAAAA,oBAAoB,CAACQ,SAArB,CAA+BmC,qBAA/B,GAAuD,YAAY;AAC/D,QAAI,KAAK0F,YAAT,EAAuB;AACnBF,MAAAA,MAAM,CAACQ,aAAP,CAAqB,KAAKX,gBAA1B;AACA,WAAKA,gBAAL,GAAwB,IAAxB;AACA,WAAKO,kBAAL,CAAwBC,YAAxB,CAAqC1I,oBAAoB,CAACkB,kBAArB,CAAwCE,SAA7E;AACH;AACJ,GAND;;AAOAlB,EAAAA,oBAAoB,CAACQ,SAArB,CAA+B6H,YAA/B,GAA8C,YAAY;AACtD;AACA;AACA,QAAIO,YAAJ;AACA,SAAKX,aAAL;AACAW,IAAAA,YAAY,GAAG,KAAM,KAAKX,aAAL,GAAqB,CAA1C;;AACA,QAAIW,YAAY,GAAG,GAAnB,EAAwB;AACpBA,MAAAA,YAAY,GAAG,GAAf;AACH;;AACD,QAAIC,WAAJ;;AACA,QAAI,KAAK1I,cAAT,EAAyB;AACrB0I,MAAAA,WAAW,GAAG,KAAKnI,SAAL,CAAeoI,kBAAf,CAAkC,CAACF,YAAnC,CAAd;AACH,KAFD,MAGK,IAAI,KAAKxI,eAAT,EAA0B;AAC3ByI,MAAAA,WAAW,GAAG,KAAKnI,SAAL,CAAeoI,kBAAf,CAAkCF,YAAlC,CAAd;AACH;;AACD,QAAIC,WAAW,KAAK,CAApB,EAAuB;AACnB,WAAKzG,UAAL,CAAgB,KAAK+B,iBAArB;AACA,WAAK+D,kBAAL,GAA0B,CAA1B;AACH,KAHD,MAIK;AACD;AACA;AACA,WAAKA,kBAAL;AACA,UAAI7G,OAAO,GAAG,KAAK8C,iBAAL,CAAuB7C,QAAvB,CAAgCD,OAA9C;AACA,UAAI0H,iBAAiB,GAAG1H,OAAO,CAACW,MAAR,CAAe,UAAUzD,CAAV,EAAa;AAAE,eAAO,CAACA,CAAC,CAACwE,SAAF,GAAcG,UAAtB;AAAmC,OAAjE,CAAxB;;AACA,UAAI6F,iBAAiB,CAACtK,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,aAAK8J,kBAAL,CAAwBC,YAAxB,CAAqC1I,oBAAoB,CAACkB,kBAArB,CAAwCC,WAA7E;;AACA,YAAI,KAAKiH,kBAAL,GAA0B,CAA9B,EAAiC;AAC7B,cAAIc,OAAO,GAAG,KAAK7I,cAAL,GAAsBP,QAAQ,CAACqJ,MAAT,CAAgBC,WAAtC,GAAoDtJ,QAAQ,CAACqJ,MAAT,CAAgBE,YAAlF;AACA,eAAKhH,gBAAL,CAAsB4G,iBAAtB,EAAyCC,OAAzC,EAAkD,iBAAlD;AACA,eAAKT,kBAAL,CAAwBa,KAAxB;AACH;AACJ;AACJ;AACJ,GAnCD;;AAoCAlL,EAAAA,UAAU,CAAC,CACPsB,SAAS,CAAC6J,SAAV,CAAoB,eAApB,CADO,EAEPnK,UAAU,CAAC,aAAD,EAAgBQ,QAAQ,CAAC4J,aAAzB,CAFH,CAAD,EAGPtJ,oBAAoB,CAACQ,SAHd,EAGyB,eAHzB,EAG0C,KAAK,CAH/C,CAAV;;AAIAtC,EAAAA,UAAU,CAAC,CACPsB,SAAS,CAAC6J,SAAV,CAAoB,kBAApB,CADO,EAEPnK,UAAU,CAAC,aAAD,EAAgBS,kBAAkB,CAAC4J,gBAAnC,CAFH,CAAD,EAGPvJ,oBAAoB,CAACQ,SAHd,EAGyB,kBAHzB,EAG6C,KAAK,CAHlD,CAAV;;AAIAtC,EAAAA,UAAU,CAAC,CACPsB,SAAS,CAAC6J,SAAV,CAAoB,oBAApB,CADO,EAEPnK,UAAU,CAAC,aAAD,EAAgBY,oBAAoB,CAACkB,kBAArC,CAFH,CAAD,EAGPhB,oBAAoB,CAACQ,SAHd,EAGyB,oBAHzB,EAG+C,KAAK,CAHpD,CAAV;;AAIAtC,EAAAA,UAAU,CAAC,CACPsB,SAAS,CAAC6J,SAAV,CAAoB,oBAApB,CADO,EAEPnK,UAAU,CAAC,aAAD,EAAgBa,oBAAoB,CAACyJ,kBAArC,CAFH,CAAD,EAGPxJ,oBAAoB,CAACQ,SAHd,EAGyB,oBAHzB,EAG+C,KAAK,CAHpD,CAAV;;AAIAtC,EAAAA,UAAU,CAAC,CACPsB,SAAS,CAACiK,aADH,EAEPvK,UAAU,CAAC,aAAD,EAAgBwK,QAAhB,CAFH,EAGPxK,UAAU,CAAC,mBAAD,EAAsB,EAAtB,CAHH,EAIPA,UAAU,CAAC,mBAAD,EAAsB,KAAK,CAA3B,CAJH,CAAD,EAKPc,oBAAoB,CAACQ,SALd,EAKyB,MALzB,EAKiC,IALjC,CAAV;;AAMA,SAAOR,oBAAP;AACH,CAvXyC,EAA1C;;AAwXAV,OAAO,CAACU,oBAAR,GAA+BA,oBAA/B","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"../context/context\");\nvar logger_1 = require(\"../logger\");\nvar columnController_1 = require(\"../columnController/columnController\");\nvar column_1 = require(\"../entities/column\");\nvar utils_1 = require(\"../utils\");\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar MoveColumnController = /** @class */ (function () {\n    function MoveColumnController(pinned, eContainer) {\n        this.needToMoveLeft = false;\n        this.needToMoveRight = false;\n        this.pinned = pinned;\n        this.eContainer = eContainer;\n        this.centerContainer = !utils_1._.exists(pinned);\n    }\n    MoveColumnController.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n    };\n    MoveColumnController.prototype.init = function () {\n        this.logger = this.loggerFactory.create('MoveColumnController');\n    };\n    MoveColumnController.prototype.getIconName = function () {\n        return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;\n    };\n    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {\n        // we do dummy drag, so make sure column appears in the right location when first placed\n        var columns = draggingEvent.dragItem.columns;\n        var dragCameFromToolPanel = draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;\n        if (dragCameFromToolPanel) {\n            // the if statement doesn't work if drag leaves grid, then enters again\n            this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n        }\n        else {\n            // restore previous state of visible columns upon re-entering. this means if the user drags\n            // a group out, and then drags the group back in, only columns that were originally visible\n            // will be visible again. otherwise a group with three columns (but only two visible) could\n            // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n            var visibleState_1 = draggingEvent.dragItem.visibleState;\n            var visibleColumns = columns.filter(function (column) { return visibleState_1[column.getId()]; });\n            this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n        }\n        this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n        this.onDragging(draggingEvent, true);\n    };\n    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {\n        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n        if (hideColumnOnExit) {\n            var dragItem = draggingEvent.dragSource.dragItemCallback();\n            var columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.setColumnsVisible = function (columns, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockVisible; });\n            this.columnController.setColumnsVisible(allowedCols, visible, source);\n        }\n    };\n    MoveColumnController.prototype.setColumnsPinned = function (columns, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            this.columnController.setColumnsPinned(allowedCols, pinned, source);\n        }\n    };\n    MoveColumnController.prototype.onDragStop = function () {\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.normaliseX = function (x) {\n        // flip the coordinate if doing RTL\n        var flipHorizontallyForRtl = this.gridOptionsWrapper.isEnableRtl();\n        if (flipHorizontallyForRtl) {\n            var clientWidth = this.eContainer.clientWidth;\n            x = clientWidth - x;\n        }\n        // adjust for scroll only if centre container (the pinned containers dont scroll)\n        var adjustForScroll = this.centerContainer;\n        if (adjustForScroll) {\n            x += this.gridPanel.getCenterViewportScrollLeft();\n        }\n        return x;\n    };\n    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n        if (this.centerContainer) {\n            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n            var firstVisiblePixel = this.gridPanel.getCenterViewportScrollLeft();\n            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            else {\n                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            if (this.needToMoveLeft || this.needToMoveRight) {\n                this.ensureIntervalStarted();\n            }\n            else {\n                this.ensureIntervalCleared();\n            }\n        }\n    };\n    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {\n        var _this = this;\n        if (fromEnter === void 0) { fromEnter = false; }\n        this.lastDraggingEvent = draggingEvent;\n        // if moving up or down (ie not left or right) then do nothing\n        if (utils_1._.missing(draggingEvent.hDirection)) {\n            return;\n        }\n        var mouseXNormalised = this.normaliseX(draggingEvent.x);\n        // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n        // we don't want to scroll the grid this time, it would appear like the table is jumping\n        // each time a column is dragged in.\n        if (!fromEnter) {\n            this.checkCenterForScrolling(mouseXNormalised);\n        }\n        var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n        var dragSourceType = draggingEvent.dragSource.type;\n        var columnsToMove = draggingEvent.dragSource.dragItemCallback().columns;\n        columnsToMove = columnsToMove.filter(function (col) {\n            if (col.getColDef().lockPinned) {\n                // if locked return true only if both col and container are same pin type.\n                // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n                return col.getPinned() == _this.pinned;\n            }\n            else {\n                // if not pin locked, then always allowed to be in this container\n                return true;\n            }\n        });\n        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n    };\n    MoveColumnController.prototype.normaliseDirection = function (hDirection) {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            switch (hDirection) {\n                case dragAndDropService_1.HDirection.Left: return dragAndDropService_1.HDirection.Right;\n                case dragAndDropService_1.HDirection.Right: return dragAndDropService_1.HDirection.Left;\n                default: console.error(\"ag-Grid: Unknown direction \" + hDirection);\n            }\n        }\n        else {\n            return hDirection;\n        }\n    };\n    // returns the index of the first column in the list ONLY if the cols are all beside\n    // each other. if the cols are not beside each other, then returns null\n    MoveColumnController.prototype.calculateOldIndex = function (movingCols) {\n        var gridCols = this.columnController.getAllGridColumns();\n        var indexes = [];\n        movingCols.forEach(function (col) { return indexes.push(gridCols.indexOf(col)); });\n        utils_1._.sortNumberArray(indexes);\n        var firstIndex = indexes[0];\n        var lastIndex = utils_1._.last(indexes);\n        var spread = lastIndex - firstIndex;\n        var gapsExist = spread !== indexes.length - 1;\n        return gapsExist ? null : firstIndex;\n    };\n    MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n        var draggingLeft = hDirection === dragAndDropService_1.HDirection.Left;\n        var draggingRight = hDirection === dragAndDropService_1.HDirection.Right;\n        var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, mouseX);\n        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n        // (ie left or right) to the mouse direction. however\n        var oldIndex = this.calculateOldIndex(allMovingColumns);\n        if (validMoves.length === 0) {\n            return;\n        }\n        var firstValidMove = validMoves[0];\n        // the two check below stop an error when the user grabs a group my a middle column, then\n        // it is possible the mouse pointer is to the right of a column while been dragged left.\n        // so we need to make sure that the mouse pointer is actually left of the left most column\n        // if moving left, and right of the right most column if moving right\n        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n        // place the column to the RHS even if the mouse is moving left and the column is already on\n        // the LHS. otherwise we stick to the rule described above.\n        var constrainDirection = oldIndex !== null && !fromEnter;\n        // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n        if (dragSourceType == dragAndDropService_1.DragSourceType.HeaderCell) {\n            constrainDirection = oldIndex !== null;\n        }\n        if (constrainDirection) {\n            // only allow left drag if this column is moving left\n            if (draggingLeft && firstValidMove >= oldIndex) {\n                return;\n            }\n            // only allow right drag if this column is moving right\n            if (draggingRight && firstValidMove <= oldIndex) {\n                return;\n            }\n        }\n        for (var i = 0; i < validMoves.length; i++) {\n            var move = validMoves[i];\n            if (!this.columnController.doesMovePassRules(allMovingColumns, move)) {\n                continue;\n            }\n            this.columnController.moveColumns(allMovingColumns, move, \"uiColumnDragged\");\n            // important to return here, so once we do the first valid move, we don't try do any more\n            return;\n        }\n    };\n    MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n        var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned);\n        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n        // so the result we return has to be and index location for this list\n        var allGridCols = this.columnController.getAllGridColumns();\n        var colIsMovingFunc = function (col) { return movingCols.indexOf(col) >= 0; };\n        var colIsNotMovingFunc = function (col) { return movingCols.indexOf(col) < 0; };\n        var movingDisplayedCols = allDisplayedCols.filter(colIsMovingFunc);\n        var otherDisplayedCols = allDisplayedCols.filter(colIsNotMovingFunc);\n        var otherGridCols = allGridCols.filter(colIsNotMovingFunc);\n        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n        // col between b and c (so that it is under the mouse position).\n        var displayIndex = 0;\n        var availableWidth = mouseX;\n        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n        // include the width of the moving columns\n        if (draggingRight) {\n            var widthOfMovingDisplayedCols_1 = 0;\n            movingDisplayedCols.forEach(function (col) { return widthOfMovingDisplayedCols_1 += col.getActualWidth(); });\n            availableWidth -= widthOfMovingDisplayedCols_1;\n        }\n        if (availableWidth > 0) {\n            // now count how many of the displayed columns will fit to the left\n            for (var i = 0; i < otherDisplayedCols.length; i++) {\n                var col = otherDisplayedCols[i];\n                availableWidth -= col.getActualWidth();\n                if (availableWidth < 0) {\n                    break;\n                }\n                displayIndex++;\n            }\n            // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n            if (draggingRight) {\n                displayIndex++;\n            }\n        }\n        // the display index is with respect to all the showing columns, however when we move, it's with\n        // respect to all grid columns, so we need to translate from display index to grid index\n        var firstValidMove;\n        if (displayIndex > 0) {\n            var leftColumn = otherDisplayedCols[displayIndex - 1];\n            firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n        }\n        else {\n            firstValidMove = 0;\n        }\n        var validMoves = [firstValidMove];\n        // add in other valid moves due to hidden columns and married children. for example, a particular\n        // move might break a group that has married children (so move isn't valid), however there could\n        // be hidden columns (not displayed) that we could jump over to make the move valid. because\n        // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n        // not work. for example imagine a group with 9 columns and all columns are hidden except the\n        // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n        // be relative to the not-shown column, however we need to consider the move jumping over all the\n        // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n        // grid, there would be no way to put a column after it (as the grid would only consider beside the\n        // visible column, which would fail valid move rules).\n        if (draggingRight) {\n            // if dragging right, then we add all the additional moves to the right. so in other words\n            // if the next move is not valid, find the next move to the right that is valid.\n            var pointer = firstValidMove + 1;\n            var lastIndex = allGridCols.length - 1;\n            while (pointer <= lastIndex) {\n                validMoves.push(pointer);\n                pointer++;\n            }\n        }\n        else {\n            // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n            // left. however we also have to consider moves to the right for all hidden columns first.\n            // (this logic is hard to reason with, it was worked out with trial and error,\n            // move observation rather than science).\n            // add moves to the right\n            var pointer = firstValidMove;\n            var lastIndex = allGridCols.length - 1;\n            var displacedCol = allGridCols[pointer];\n            while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n                pointer++;\n                validMoves.push(pointer);\n                displacedCol = allGridCols[pointer];\n            }\n            // add moves to the left\n            pointer = firstValidMove - 1;\n            var firstDisplayIndex = 0;\n            while (pointer >= firstDisplayIndex) {\n                validMoves.push(pointer);\n                pointer--;\n            }\n        }\n        return validMoves;\n    };\n    // isHidden takes into account visible=false and group=closed, ie it is not displayed\n    MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {\n        return displayedColumns.indexOf(col) < 0;\n    };\n    MoveColumnController.prototype.ensureIntervalStarted = function () {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.failedMoveAttempts = 0;\n            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n            if (this.needToMoveLeft) {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);\n            }\n            else {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);\n            }\n        }\n    };\n    MoveColumnController.prototype.ensureIntervalCleared = function () {\n        if (this.moveInterval) {\n            window.clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);\n        }\n    };\n    MoveColumnController.prototype.moveInterval = function () {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        var pixelsToMove;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n        var pixelsMoved;\n        if (this.needToMoveLeft) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);\n        }\n        else if (this.needToMoveRight) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);\n        }\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n            this.failedMoveAttempts = 0;\n        }\n        else {\n            // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n            // this is how we achieve pining by dragging the column to the edge of the grid.\n            this.failedMoveAttempts++;\n            var columns = this.lastDraggingEvent.dragItem.columns;\n            var columnsThatCanPin = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            if (columnsThatCanPin.length > 0) {\n                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);\n                if (this.failedMoveAttempts > 7) {\n                    var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;\n                    this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n                    this.dragAndDropService.nudge();\n                }\n            }\n        }\n    };\n    __decorate([\n        context_1.Autowired('loggerFactory'),\n        __metadata(\"design:type\", logger_1.LoggerFactory)\n    ], MoveColumnController.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        context_1.Autowired('columnController'),\n        __metadata(\"design:type\", columnController_1.ColumnController)\n    ], MoveColumnController.prototype, \"columnController\", void 0);\n    __decorate([\n        context_1.Autowired('dragAndDropService'),\n        __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)\n    ], MoveColumnController.prototype, \"dragAndDropService\", void 0);\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], MoveColumnController.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], MoveColumnController.prototype, \"init\", null);\n    return MoveColumnController;\n}());\nexports.MoveColumnController = MoveColumnController;\n"]},"metadata":{},"sourceType":"script"}