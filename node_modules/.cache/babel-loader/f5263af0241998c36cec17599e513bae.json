{"ast":null,"code":"/**\n * @module ol/Image\n */\nimport ImageBase from './ImageBase.js';\nimport ImageState from './ImageState.js';\nimport { listenOnce, unlistenByKey } from './events.js';\nimport EventType from './events/EventType.js';\nimport { getHeight } from './extent.js';\n/**\n * A function that takes an {@link module:ol/Image~Image} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~Image#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(ImageWrapper, string)} LoadFunction\n * @api\n */\n\nvar ImageWrapper =\n/*@__PURE__*/\nfunction (ImageBase) {\n  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {\n    ImageBase.call(this, extent, resolution, pixelRatio, ImageState.IDLE);\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.src_ = src;\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}\n     */\n\n    this.image_ = new Image();\n\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n\n\n    this.imageListenerKeys_ = null;\n    /**\n     * @protected\n     * @type {ImageState}\n     */\n\n    this.state = ImageState.IDLE;\n    /**\n     * @private\n     * @type {LoadFunction}\n     */\n\n    this.imageLoadFunction_ = imageLoadFunction;\n  }\n\n  if (ImageBase) ImageWrapper.__proto__ = ImageBase;\n  ImageWrapper.prototype = Object.create(ImageBase && ImageBase.prototype);\n  ImageWrapper.prototype.constructor = ImageWrapper;\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n  ImageWrapper.prototype.getImage = function getImage() {\n    return this.image_;\n  };\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n\n\n  ImageWrapper.prototype.handleImageError_ = function handleImageError_() {\n    this.state = ImageState.ERROR;\n    this.unlistenImage_();\n    this.changed();\n  };\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n\n\n  ImageWrapper.prototype.handleImageLoad_ = function handleImageLoad_() {\n    if (this.resolution === undefined) {\n      this.resolution = getHeight(this.extent) / this.image_.height;\n    }\n\n    this.state = ImageState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  };\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @override\n   * @api\n   */\n\n\n  ImageWrapper.prototype.load = function load() {\n    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [listenOnce(this.image_, EventType.ERROR, this.handleImageError_, this), listenOnce(this.image_, EventType.LOAD, this.handleImageLoad_, this)];\n      this.imageLoadFunction_(this, this.src_);\n    }\n  };\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   */\n\n\n  ImageWrapper.prototype.setImage = function setImage(image) {\n    this.image_ = image;\n  };\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n\n\n  ImageWrapper.prototype.unlistenImage_ = function unlistenImage_() {\n    this.imageListenerKeys_.forEach(unlistenByKey);\n    this.imageListenerKeys_ = null;\n  };\n\n  return ImageWrapper;\n}(ImageBase);\n\nexport default ImageWrapper;","map":{"version":3,"sources":["../../src/ol/Image.js"],"names":["super"],"mappings":"AAAA;;;AAGA,OAAO,SAAP,MAAsB,gBAAtB;AACA,OAAO,UAAP,MAAuB,iBAAvB;AACA,SAAQ,UAAR,EAAoB,aAApB,QAAwC,aAAxC;AACA,OAAO,SAAP,MAAsB,uBAAtB;AACA,SAAQ,SAAR,QAAwB,aAAxB;;;;;;;;;;;;;;;;;;;AAsBA,IAAM,YAAY;AAAkB;AAAA,UAAA,SAAA,EAAA;AAUlC,WAAA,YAAA,CAAY,MAAZ,EAAoB,UAApB,EAAgC,UAAhC,EAA4C,GAA5C,EAAiD,WAAjD,EAA8D,iBAA9D,EAAiF;AAE/EA,IAAAA,SAAAA,CAAAA,IAAAA,CAAK,IAALA,EAAM,MAANA,EAAc,UAAdA,EAA0B,UAA1BA,EAAsC,UAAU,CAAC,IAAjDA;;;;;;AAMA,SAAK,IAAL,GAAY,GAAZ;;;;;;AAMA,SAAK,MAAL,GAAc,IAAI,KAAJ,EAAd;;AACA,QAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,WAAK,MAAL,CAAY,WAAZ,GAA0B,WAA1B;AACD;;;;;;;AAMD,SAAK,kBAAL,GAA0B,IAA1B;;;;;;AAMA,SAAK,KAAL,GAAa,UAAU,CAAC,IAAxB;;;;;;AAMA,SAAK,kBAAL,GAA0B,iBAA1B;;;;;uCAED,Y;;;;;;yBAMD,Q,GAAA,SAAA,QAAA,GAAW;AACT,WAAO,KAAK,MAAZ;AACD,G;;;;;;;;yBAOD,iB,GAAA,SAAA,iBAAA,GAAoB;AAClB,SAAK,KAAL,GAAa,UAAU,CAAC,KAAxB;AACA,SAAK,cAAL;AACA,SAAK,OAAL;AACD,G;;;;;;;;yBAOD,gB,GAAA,SAAA,gBAAA,GAAmB;AACjB,QAAI,KAAK,UAAL,KAAoB,SAAxB,EAAmC;AACjC,WAAK,UAAL,GAAkB,SAAS,CAAC,KAAK,MAAN,CAAT,GAAyB,KAAK,MAAL,CAAY,MAAvD;AACD;;AACD,SAAK,KAAL,GAAa,UAAU,CAAC,MAAxB;AACA,SAAK,cAAL;AACA,SAAK,OAAL;AACD,G;;;;;;;;;;yBASD,I,GAAA,SAAA,IAAA,GAAO;AACL,QAAI,KAAK,KAAL,IAAc,UAAU,CAAC,IAAzB,IAAiC,KAAK,KAAL,IAAc,UAAU,CAAC,KAA9D,EAAqE;AACnE,WAAK,KAAL,GAAa,UAAU,CAAC,OAAxB;AACA,WAAK,OAAL;AACA,WAAK,kBAAL,GAA0B,CACxB,UAAU,CAAC,KAAK,MAAN,EAAc,SAAS,CAAC,KAAxB,EACR,KAAK,iBADG,EACgB,IADhB,CADc,EAGxB,UAAU,CAAC,KAAK,MAAN,EAAc,SAAS,CAAC,IAAxB,EACR,KAAK,gBADG,EACe,IADf,CAHc,CAA1B;AAMA,WAAK,kBAAL,CAAwB,IAAxB,EAA8B,KAAK,IAAnC;AACD;AACF,G;;;;;;yBAKD,Q,GAAA,SAAA,QAAA,CAAS,KAAT,EAAgB;AACd,SAAK,MAAL,GAAc,KAAd;AACD,G;;;;;;;;yBAOD,c,GAAA,SAAA,cAAA,GAAiB;AACf,SAAK,kBAAL,CAAwB,OAAxB,CAAgC,aAAhC;AACA,SAAK,kBAAL,GAA0B,IAA1B;AACD,G;;;CAtHiC,CAAT,SAAS,CAApC;;AA0HA,eAAe,YAAf","sourcesContent":["/**\n * @module ol/Image\n */\nimport ImageBase from './ImageBase.js';\nimport ImageState from './ImageState.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport EventType from './events/EventType.js';\nimport {getHeight} from './extent.js';\n\n\n/**\n * A function that takes an {@link module:ol/Image~Image} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~Image#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(ImageWrapper, string)} LoadFunction\n * @api\n */\n\n\nclass ImageWrapper extends ImageBase {\n\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {LoadFunction} imageLoadFunction Image load function.\n   */\n  constructor(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {\n\n    super(extent, resolution, pixelRatio, ImageState.IDLE);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.imageListenerKeys_ = null;\n\n    /**\n     * @protected\n     * @type {ImageState}\n     */\n    this.state = ImageState.IDLE;\n\n    /**\n     * @private\n     * @type {LoadFunction}\n     */\n    this.imageLoadFunction_ = imageLoadFunction;\n\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = ImageState.ERROR;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    if (this.resolution === undefined) {\n      this.resolution = getHeight(this.extent) / this.image_.height;\n    }\n    this.state = ImageState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @override\n   * @api\n   */\n  load() {\n    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [\n        listenOnce(this.image_, EventType.ERROR,\n          this.handleImageError_, this),\n        listenOnce(this.image_, EventType.LOAD,\n          this.handleImageLoad_, this)\n      ];\n      this.imageLoadFunction_(this, this.src_);\n    }\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    this.imageListenerKeys_.forEach(unlistenByKey);\n    this.imageListenerKeys_ = null;\n  }\n}\n\n\nexport default ImageWrapper;\n"]},"metadata":{},"sourceType":"module"}