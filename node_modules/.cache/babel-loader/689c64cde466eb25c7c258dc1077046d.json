{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString.js\"));\n\nvar _isArray = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _StringUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/StringUtil/StringUtil\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Helper class for working with OpenLayers features.\n *\n * @class FeatureUtil\n */\n\n\nvar FeatureUtil =\n/*#__PURE__*/\nfunction () {\n  function FeatureUtil() {\n    _classCallCheck(this, FeatureUtil);\n  }\n\n  _createClass(FeatureUtil, null, [{\n    key: \"getFeatureTypeName\",\n\n    /**\n     * Returns the featureType name out of a given feature. It assumes that\n     * the feature has an ID in the following structure FEATURETYPE.FEATUREID.\n     *\n     * @param {ol.Feature} feature The feature to obtain the featureType\n     *                             name from.\n     * @return {string} The (unqualified) name of the featureType or undefined if\n     *                  the name could not be picked.\n     */\n    value: function getFeatureTypeName(feature) {\n      var featureId = feature.getId();\n      var featureIdParts = featureId ? featureId.split('.') : featureId;\n      return (0, _isArray[\"default\"])(featureIdParts) ? featureIdParts[0] : undefined;\n    }\n    /**\n     * Extracts the featureType name from given GetFeatureInfo URL.\n     * This method is mostly useful for raster layers which features could have\n     * no ID set.\n     *\n     * @param {string} url GetFeatureInfo URL possibly containing featureType name.\n     * @param {boolean} qualified Whether the qualified featureType name should be\n     *   returned or not. Default is true.\n     *\n     * @return {string} Obtained featureType name as string.\n     */\n\n  }, {\n    key: \"getFeatureTypeNameFromGetFeatureInfoUrl\",\n    value: function getFeatureTypeNameFromGetFeatureInfoUrl(url) {\n      var qualified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var regex = /query_layers=(.*?)(&|$)/i;\n      var match = url.match(regex);\n      var featureTypeName;\n\n      if (match && match[1]) {\n        featureTypeName = decodeURIComponent(match[1]);\n\n        if (!qualified && featureTypeName.indexOf(':') > 0) {\n          featureTypeName = featureTypeName.split(':')[1];\n        }\n      }\n\n      return featureTypeName;\n    }\n    /**\n     * Resolves the given template string with the given feature attributes, e.g.\n     * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\n     * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\n     * really exists).\n     *\n     * @param {ol.Feature} feature The feature to get the attributes from.\n     * @param {string} template The template string to resolve.\n     * @param {string} [noValueFoundText] The text to apply, if the templated value\n     *   could not be found, default is to 'n.v.'.\n     * @param {Function} [valueAdjust] A method that will be called with each\n     *   key/value match, we'll use what this function returns for the actual\n     *   replacement. Optional, defaults to a function which will return the raw\n     *   value it received. This can be used for last minute adjustments before\n     *   replacing happens, e.g. to filter out falsy values or to do number\n     *   formatting and such.\n     * @return {string} The resolved template string.\n     */\n\n  }, {\n    key: \"resolveAttributeTemplate\",\n    value: function resolveAttributeTemplate(feature, template) {\n      var noValueFoundText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n.v.';\n      var valueAdjust = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (key, val) {\n        return val;\n      };\n      var attributeTemplatePrefix = '\\\\{\\\\{';\n      var attributeTemplateSuffix = '\\\\}\\\\}';\n      var resolved = ''; // Find any character between two braces (including the braces in the result)\n\n      var regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\n      var regExpRes = (0, _isString[\"default\"])(template) ? template.match(regExp) : null; // If we have a regex result, it means we found a placeholder in the\n      // template and have to replace the placeholder with its appropriate value.\n\n      if (regExpRes) {\n        // Iterate over all regex match results and find the proper attribute\n        // for the given placeholder, finally set the desired value to the hover.\n        // field text\n        regExpRes.forEach(function (res) {\n          // We count every non matching candidate. If this count is equal to\n          // the objects length, we assume that there is no match at all and\n          // set the output value to the value of \"noValueFoundText\".\n          var noMatchCnt = 0;\n\n          for (var _i = 0, _Object$entries = Object.entries(feature.getProperties()); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                key = _Object$entries$_i[0],\n                value = _Object$entries$_i[1]; // Remove the suffixes and find the matching attribute column.\n\n\n            var attributeName = res.slice(2, res.length - 2);\n\n            if (attributeName.toLowerCase() === key.toLowerCase()) {\n              template = template.replace(res, valueAdjust(key, value));\n              break;\n            } else {\n              noMatchCnt++;\n            }\n          } // No key match found for this feature (e.g. if key not\n          // present or value is null).\n\n\n          if (noMatchCnt === Object.keys(feature.getProperties()).length) {\n            template = template.replace(res, noValueFoundText);\n          }\n        });\n      }\n\n      resolved = template; // Fallback if no feature attribute is found.\n\n      if (!resolved) {\n        resolved = feature.getId();\n      } // Replace any HTTP url with an <a> element.\n\n\n      resolved = _StringUtil[\"default\"].urlify(resolved); // Replace all newline breaks with a html <br> tag.\n\n      resolved = resolved.replace(/\\n/g, '<br>');\n      return resolved;\n    }\n  }]);\n\n  return FeatureUtil;\n}();\n\nvar _default = FeatureUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/@terrestris/react-geo/node_modules/@terrestris/ol-util/dist/FeatureUtil/FeatureUtil.js"],"names":["Object","defineProperty","exports","value","_isString","_interopRequireDefault","require","_isArray","_StringUtil","obj","__esModule","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","FeatureUtil","getFeatureTypeName","feature","featureId","getId","featureIdParts","split","getFeatureTypeNameFromGetFeatureInfoUrl","url","qualified","arguments","regex","match","featureTypeName","decodeURIComponent","indexOf","resolveAttributeTemplate","template","noValueFoundText","valueAdjust","val","attributeTemplatePrefix","attributeTemplateSuffix","resolved","regExp","RegExp","regExpRes","forEach","res","noMatchCnt","_Object$entries","entries","getProperties","_Object$entries$_i","attributeName","slice","toLowerCase","replace","keys","urlify","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _isString = _interopRequireDefault(require(\"lodash/isString.js\"));\n\nvar _isArray = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _StringUtil = _interopRequireDefault(require(\"@terrestris/base-util/dist/StringUtil/StringUtil\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Helper class for working with OpenLayers features.\n *\n * @class FeatureUtil\n */\nvar FeatureUtil =\n/*#__PURE__*/\nfunction () {\n  function FeatureUtil() {\n    _classCallCheck(this, FeatureUtil);\n  }\n\n  _createClass(FeatureUtil, null, [{\n    key: \"getFeatureTypeName\",\n\n    /**\n     * Returns the featureType name out of a given feature. It assumes that\n     * the feature has an ID in the following structure FEATURETYPE.FEATUREID.\n     *\n     * @param {ol.Feature} feature The feature to obtain the featureType\n     *                             name from.\n     * @return {string} The (unqualified) name of the featureType or undefined if\n     *                  the name could not be picked.\n     */\n    value: function getFeatureTypeName(feature) {\n      var featureId = feature.getId();\n      var featureIdParts = featureId ? featureId.split('.') : featureId;\n      return (0, _isArray[\"default\"])(featureIdParts) ? featureIdParts[0] : undefined;\n    }\n    /**\n     * Extracts the featureType name from given GetFeatureInfo URL.\n     * This method is mostly useful for raster layers which features could have\n     * no ID set.\n     *\n     * @param {string} url GetFeatureInfo URL possibly containing featureType name.\n     * @param {boolean} qualified Whether the qualified featureType name should be\n     *   returned or not. Default is true.\n     *\n     * @return {string} Obtained featureType name as string.\n     */\n\n  }, {\n    key: \"getFeatureTypeNameFromGetFeatureInfoUrl\",\n    value: function getFeatureTypeNameFromGetFeatureInfoUrl(url) {\n      var qualified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var regex = /query_layers=(.*?)(&|$)/i;\n      var match = url.match(regex);\n      var featureTypeName;\n\n      if (match && match[1]) {\n        featureTypeName = decodeURIComponent(match[1]);\n\n        if (!qualified && featureTypeName.indexOf(':') > 0) {\n          featureTypeName = featureTypeName.split(':')[1];\n        }\n      }\n\n      return featureTypeName;\n    }\n    /**\n     * Resolves the given template string with the given feature attributes, e.g.\n     * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\n     * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\n     * really exists).\n     *\n     * @param {ol.Feature} feature The feature to get the attributes from.\n     * @param {string} template The template string to resolve.\n     * @param {string} [noValueFoundText] The text to apply, if the templated value\n     *   could not be found, default is to 'n.v.'.\n     * @param {Function} [valueAdjust] A method that will be called with each\n     *   key/value match, we'll use what this function returns for the actual\n     *   replacement. Optional, defaults to a function which will return the raw\n     *   value it received. This can be used for last minute adjustments before\n     *   replacing happens, e.g. to filter out falsy values or to do number\n     *   formatting and such.\n     * @return {string} The resolved template string.\n     */\n\n  }, {\n    key: \"resolveAttributeTemplate\",\n    value: function resolveAttributeTemplate(feature, template) {\n      var noValueFoundText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n.v.';\n      var valueAdjust = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (key, val) {\n        return val;\n      };\n      var attributeTemplatePrefix = '\\\\{\\\\{';\n      var attributeTemplateSuffix = '\\\\}\\\\}';\n      var resolved = ''; // Find any character between two braces (including the braces in the result)\n\n      var regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\n      var regExpRes = (0, _isString[\"default\"])(template) ? template.match(regExp) : null; // If we have a regex result, it means we found a placeholder in the\n      // template and have to replace the placeholder with its appropriate value.\n\n      if (regExpRes) {\n        // Iterate over all regex match results and find the proper attribute\n        // for the given placeholder, finally set the desired value to the hover.\n        // field text\n        regExpRes.forEach(function (res) {\n          // We count every non matching candidate. If this count is equal to\n          // the objects length, we assume that there is no match at all and\n          // set the output value to the value of \"noValueFoundText\".\n          var noMatchCnt = 0;\n\n          for (var _i = 0, _Object$entries = Object.entries(feature.getProperties()); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                key = _Object$entries$_i[0],\n                value = _Object$entries$_i[1];\n\n            // Remove the suffixes and find the matching attribute column.\n            var attributeName = res.slice(2, res.length - 2);\n\n            if (attributeName.toLowerCase() === key.toLowerCase()) {\n              template = template.replace(res, valueAdjust(key, value));\n              break;\n            } else {\n              noMatchCnt++;\n            }\n          } // No key match found for this feature (e.g. if key not\n          // present or value is null).\n\n\n          if (noMatchCnt === Object.keys(feature.getProperties()).length) {\n            template = template.replace(res, noValueFoundText);\n          }\n        });\n      }\n\n      resolved = template; // Fallback if no feature attribute is found.\n\n      if (!resolved) {\n        resolved = feature.getId();\n      } // Replace any HTTP url with an <a> element.\n\n\n      resolved = _StringUtil[\"default\"].urlify(resolved); // Replace all newline breaks with a html <br> tag.\n\n      resolved = resolved.replace(/\\n/g, '<br>');\n      return resolved;\n    }\n  }]);\n\n  return FeatureUtil;\n}();\n\nvar _default = FeatureUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}