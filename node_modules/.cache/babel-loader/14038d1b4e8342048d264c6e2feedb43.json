{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n\nimport { getUid } from '../../util.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { listen, unlistenByKey } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport { buffer, containsCoordinate, equals, getIntersection, intersects } from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { apply as applyTransform, create as createTransform, reset as resetTransform, scale as scaleTransform, translate as translateTransform, toString as transformToString, makeScale, makeInverse } from '../../transform.js';\nimport CanvasExecutorGroup, { replayDeclutter } from '../../render/canvas/ExecutorGroup.js';\nimport { clear } from '../../obj.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\n\nvar CanvasVectorTileLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n\n\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n\n\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    _this.overlayContext_ = null;\n    /**\n     * @type {string}\n     */\n\n    _this.overlayContextUid_;\n    /**\n     * The transform for rendered pixels to viewport CSS pixels for the overlay canvas.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    _this.overlayPixelTransform_ = createTransform();\n    /**\n     * The transform for viewport CSS pixels to rendered pixels for the overlay canvas.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    _this.inverseOverlayPixelTransform_ = createTransform();\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {!Object<string, import(\"../../VectorRenderTile.js\").default>}\n     */\n\n    _this.renderTileImageQueue_ = {};\n    /**\n     * @type {Object<string, import(\"../../events.js\").EventsKey>}\n     */\n\n    _this.tileListenerKeys_ = {};\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    _this.tmpTransform_ = createTransform();\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.useContainer = function (target, transform, opacity) {\n    var overlayContext;\n\n    if (target && target.childElementCount === 2) {\n      overlayContext = target.lastElementChild.getContext('2d');\n\n      if (!overlayContext) {\n        target = null;\n      }\n    }\n\n    var containerReused = this.containerReused;\n\n    _super.prototype.useContainer.call(this, target, transform, opacity);\n\n    if (containerReused) {\n      this.overlayContext_ = overlayContext || null;\n      this.overlayContextUid_ = overlayContext ? getUid(overlayContext) : undefined;\n    }\n\n    if (!this.overlayContext_) {\n      var overlayContext_1 = createCanvasContext2D();\n      var style = overlayContext_1.canvas.style;\n      style.position = 'absolute';\n      style.transformOrigin = 'top left';\n      this.overlayContext_ = overlayContext_1;\n      this.overlayContextUid_ = getUid(overlayContext_1);\n    }\n\n    if (this.container.childElementCount === 1) {\n      this.container.appendChild(this.overlayContext_.canvas);\n    }\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @param {boolean} queue Queue tile for rendering.\n   * @return {boolean} Tile needs to be rendered.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {\n    var render = false;\n    var tileUid = getUid(tile);\n    var state = tile.getState();\n\n    if ((state === TileState.LOADED && tile.hifi || state === TileState.ERROR || state === TileState.ABORT) && tileUid in this.tileListenerKeys_) {\n      unlistenByKey(this.tileListenerKeys_[tileUid]);\n      delete this.tileListenerKeys_[tileUid];\n    }\n\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n\n      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {\n        render = true;\n\n        if (queue) {\n          this.renderTileImageQueue_[tileUid] = tile;\n        }\n      }\n    }\n\n    return render;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var tile =\n    /** @type {import(\"../../VectorRenderTile.js\").default} */\n    _super.prototype.getTile.call(this, z, x, y, frameState);\n\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n\n    if (tile.getState() < TileState.LOADED) {\n      tile.wantedResolution = resolution;\n      var tileUid = getUid(tile);\n\n      if (!(tileUid in this.tileListenerKeys_)) {\n        var listenerKey = listen(tile, EventType.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));\n        this.tileListenerKeys_[tileUid] = listenerKey;\n      }\n    } else {\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n\n      var render = this.prepareTile(tile, pixelRatio, projection, false);\n\n      if (render) {\n        this.renderTileImage_(tile, frameState);\n      }\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritdoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    return _super.prototype.isDrawableTile.call(this, tile) && tile.hasContext(this.getLayer());\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    layerState.hasOverlay = true;\n    var layerRevision = this.getLayer().getRevision();\n\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {\n      return;\n    }\n\n    var source = layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = getUid(layer);\n    var executorGroups = tile.executorGroups[layerUid];\n\n    if (executorGroups) {\n      for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n        executorGroups[i].dispose();\n      }\n    }\n\n    tile.executorGroups[layerUid] = [];\n\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        return \"continue\";\n      }\n\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      builderState.dirty = false;\n      var builderGroup = new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio, layer.getDeclutter());\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      var features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n\n      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile\n\n      var replayExtent = layer.getDeclutter() && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    };\n\n    var this_1 = this;\n\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n\n    builderState.renderedRevision = revision;\n    builderState.renderedZ = tile.sourceZ;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var declutter = layer.getDeclutter();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    /** @type {!Object<string, boolean>} */\n\n    var features = {};\n    var renderedTiles =\n    /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    var found;\n    var i, ii;\n\n    var _loop_2 = function () {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var tileContainsCoordinate = containsCoordinate(tileExtent, coordinate);\n\n      if (!declutter) {\n        // When not decluttering, we only need to consider the tile that contains the given\n        // coordinate, because each feature will be rendered for each tile that contains it.\n        if (!tileContainsCoordinate) {\n          return \"continue\";\n        }\n      }\n\n      var executorGroups = tile.executorGroups[getUid(layer)];\n\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        found = found || executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          if (tileContainsCoordinate || declutteredFeatures && declutteredFeatures.indexOf(feature) !== -1) {\n            var key = feature.getId();\n\n            if (key === undefined) {\n              key = getUid(feature);\n            }\n\n            if (!(key in features)) {\n              features[key] = true;\n              return callback(feature, layer);\n            }\n          }\n        }, layer.getDeclutter() ? declutteredFeatures : null);\n      }\n    };\n\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      _loop_2();\n    }\n\n    return found;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    clear(this.renderTileImageQueue_);\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    this.renderQueuedTileImages_(hifi, frameState);\n\n    _super.prototype.renderFrame.call(this, frameState, target);\n\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var renderMode = layer.getRenderMode();\n\n    if (renderMode === VectorTileRenderType.IMAGE) {\n      return this.container;\n    }\n\n    var source = layer.getSource(); // Unqueue tiles from the image queue when we don't need any more\n\n    var usedTiles = frameState.usedTiles[getUid(source)];\n\n    for (var tileUid in this.renderTileImageQueue_) {\n      if (!usedTiles || !(tileUid in usedTiles)) {\n        delete this.renderTileImageQueue_[tileUid];\n      }\n    }\n\n    var context = this.overlayContext_;\n    var declutterReplays = layer.getDeclutter() ? {} : null;\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var pixelRatio = frameState.pixelRatio;\n    var rotation = frameState.viewState.rotation;\n    var size = frameState.size; // set forward and inverse pixel transforms\n\n    makeScale(this.overlayPixelTransform_, 1 / pixelRatio, 1 / pixelRatio);\n    makeInverse(this.inverseOverlayPixelTransform_, this.overlayPixelTransform_); // resize and clear\n\n    var canvas = context.canvas;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n      var canvasTransform = transformToString(this.overlayPixelTransform_);\n\n      if (canvas.style.transform !== canvasTransform) {\n        canvas.style.transform = canvasTransform;\n      }\n    } else if (getUid(context) === this.overlayContextUid_) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    var tiles = this.renderedTiles;\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var clips = [];\n    var clipZs = [];\n\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile =\n      /** @type {import(\"../../VectorRenderTile.js\").default} */\n      tiles[i];\n\n      if (tile.getState() == TileState.ABORT) {\n        continue;\n      }\n\n      var tileCoord = tile.tileCoord;\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n      var transform = this.getRenderTransform(frameState, width, height, worldOffset);\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      var clipped = false;\n\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n\n        if (!declutterReplays && !clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n          context.save(); // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n\n            if (currentZ < clipZs[j]) {\n              context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n\n        executorGroup.execute(context, transform, rotation, hifi, replayTypes, declutterReplays);\n\n        if (!declutterReplays && !clipped) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n\n    if (declutterReplays) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      replayDeclutter(declutterReplays, context, rotation, layerState.opacity, hifi, frameState.declutterItems);\n    }\n\n    return this.container;\n  };\n  /**\n   * @param {boolean} hifi We have time to render a high fidelity map image.\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {\n    // When we don't have time to render hifi, only render tiles until we have used up\n    // half of the frame budget of 16 ms\n    for (var uid in this.renderTileImageQueue_) {\n      if (!hifi && Date.now() - frameState.time > 8) {\n        frameState.animate = true;\n        break;\n      }\n\n      var tile = this.renderTileImageQueue_[uid];\n      delete this.renderTileImageQueue_[uid];\n      this.renderTileImage_(tile, frameState);\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} executorGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, executorGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(executorGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_) || loading;\n      }\n    } else {\n      loading = renderFeature(executorGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_);\n    }\n\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var sourceZ = tile.sourceZ;\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    replayState.renderedTileZ = tile.sourceZ;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n\n    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n\n    if (renderScale !== 1) {\n      var canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n    var data = _super.prototype.getDataAtPixel.call(this, pixel, frameState, hitTolerance);\n\n    if (data) {\n      return data;\n    }\n\n    var renderPixel = applyTransform(this.inverseOverlayPixelTransform_, pixel.slice());\n    var context = this.overlayContext_;\n\n    try {\n      data = context.getImageData(Math.round(renderPixel[0]), Math.round(renderPixel[1]), 1, 1).data;\n    } catch (err) {\n      if (err.name === 'SecurityError') {\n        // tainted canvas, we assume there is data at the given pixel (although there might not be)\n        return new Uint8Array();\n      }\n\n      return data;\n    }\n\n    if (data[3] === 0) {\n      return null;\n    }\n\n    return data;\n  };\n\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n\nexport default CanvasVectorTileLayerRenderer;","map":null,"metadata":{},"sourceType":"module"}