{"ast":null,"code":"/**\n * @module ol/interaction/Translate\n */\nimport { inherits } from '../util.js';\nimport Collection from '../Collection.js';\nimport { getChangeEventType } from '../Object.js';\nimport { listen } from '../events.js';\nimport Event from '../events/Event.js';\nimport { TRUE } from '../functions.js';\nimport { includes } from '../array.js';\nimport PointerInteraction from '../interaction/Pointer.js';\nimport InteractionProperty from '../interaction/Property.js';\n/**\n * @enum {string}\n */\n\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend'\n};\n/**\n * @typedef {Object} Options\n * @property {module:ol/Collection.<module:ol/Feature>} [features] Only features contained in this collection will be able to be translated. If\n * not specified, all features on the map will be able to be translated.\n * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features. This only works for the canvas renderer and\n * not for WebGL.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n *\n * @constructor\n * @extends {module:ol/events/Event}\n * @param {module:ol/interaction/Translate~TranslateEventType} type Type.\n * @param {module:ol/Collection.<module:ol/Feature>} features The features translated.\n * @param {module:ol/coordinate~Coordinate} coordinate The event coordinate.\n */\n\nexport const TranslateEvent = function (type, features, coordinate) {\n  Event.call(this, type);\n  /**\n   * The features being translated.\n   * @type {module:ol/Collection.<module:ol/Feature>}\n   * @api\n   */\n\n  this.features = features;\n  /**\n   * The coordinate of the drag event.\n   * @const\n   * @type {module:ol/coordinate~Coordinate}\n   * @api\n   */\n\n  this.coordinate = coordinate;\n};\ninherits(TranslateEvent, Event);\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n *\n * @constructor\n * @extends {module:ol/interaction/Pointer}\n * @fires module:ol/interaction/Translate~TranslateEvent\n * @param {module:ol/interaction/Translate~Options=} opt_options Options.\n * @api\n */\n\nconst Translate = function (opt_options) {\n  PointerInteraction.call(this, {\n    handleDownEvent: handleDownEvent,\n    handleDragEvent: handleDragEvent,\n    handleMoveEvent: handleMoveEvent,\n    handleUpEvent: handleUpEvent\n  });\n  const options = opt_options ? opt_options : {};\n  /**\n   * The last position we translated to.\n   * @type {module:ol/coordinate~Coordinate}\n   * @private\n   */\n\n  this.lastCoordinate_ = null;\n  /**\n   * @type {module:ol/Collection.<module:ol/Feature>}\n   * @private\n   */\n\n  this.features_ = options.features !== undefined ? options.features : null;\n  /** @type {function(module:ol/layer/Layer): boolean} */\n\n  let layerFilter;\n\n  if (options.layers) {\n    if (typeof options.layers === 'function') {\n      layerFilter = options.layers;\n    } else {\n      const layers = options.layers;\n\n      layerFilter = function (layer) {\n        return includes(layers, layer);\n      };\n    }\n  } else {\n    layerFilter = TRUE;\n  }\n  /**\n   * @private\n   * @type {function(module:ol/layer/Layer): boolean}\n   */\n\n\n  this.layerFilter_ = layerFilter;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n  /**\n   * @type {module:ol/Feature}\n   * @private\n   */\n\n  this.lastFeature_ = null;\n  listen(this, getChangeEventType(InteractionProperty.ACTIVE), this.handleActiveChanged_, this);\n};\n\ninherits(Translate, PointerInteraction);\n/**\n * @param {module:ol/MapBrowserPointerEvent} event Event.\n * @return {boolean} Start drag sequence?\n * @this {module:ol/interaction/Translate}\n */\n\nfunction handleDownEvent(event) {\n  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n\n  if (!this.lastCoordinate_ && this.lastFeature_) {\n    this.lastCoordinate_ = event.coordinate;\n    handleMoveEvent.call(this, event);\n    const features = this.features_ || new Collection([this.lastFeature_]);\n    this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate));\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} event Event.\n * @return {boolean} Stop drag sequence?\n * @this {module:ol/interaction/Translate}\n */\n\n\nfunction handleUpEvent(event) {\n  if (this.lastCoordinate_) {\n    this.lastCoordinate_ = null;\n    handleMoveEvent.call(this, event);\n    const features = this.features_ || new Collection([this.lastFeature_]);\n    this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate));\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {module:ol/MapBrowserPointerEvent} event Event.\n * @this {module:ol/interaction/Translate}\n */\n\n\nfunction handleDragEvent(event) {\n  if (this.lastCoordinate_) {\n    const newCoordinate = event.coordinate;\n    const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n    const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n    const features = this.features_ || new Collection([this.lastFeature_]);\n    features.forEach(function (feature) {\n      const geom = feature.getGeometry();\n      geom.translate(deltaX, deltaY);\n      feature.setGeometry(geom);\n    });\n    this.lastCoordinate_ = newCoordinate;\n    this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate));\n  }\n}\n/**\n * @param {module:ol/MapBrowserEvent} event Event.\n * @this {module:ol/interaction/Translate}\n */\n\n\nfunction handleMoveEvent(event) {\n  const elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed\n  // by the interaction\n\n  if (this.featuresAtPixel_(event.pixel, event.map)) {\n    elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n    elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n  } else {\n    elem.classList.remove('ol-grab', 'ol-grabbing');\n  }\n}\n/**\n * Tests to see if the given coordinates intersects any of our selected\n * features.\n * @param {module:ol~Pixel} pixel Pixel coordinate to test for intersection.\n * @param {module:ol/PluggableMap} map Map to test the intersection on.\n * @return {module:ol/Feature} Returns the feature found at the specified pixel\n * coordinates.\n * @private\n */\n\n\nTranslate.prototype.featuresAtPixel_ = function (pixel, map) {\n  return map.forEachFeatureAtPixel(pixel, function (feature) {\n    if (!this.features_ || includes(this.features_.getArray(), feature)) {\n      return feature;\n    }\n  }.bind(this), {\n    layerFilter: this.layerFilter_,\n    hitTolerance: this.hitTolerance_\n  });\n};\n/**\n * Returns the Hit-detection tolerance.\n * @returns {number} Hit tolerance in pixels.\n * @api\n */\n\n\nTranslate.prototype.getHitTolerance = function () {\n  return this.hitTolerance_;\n};\n/**\n * Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features. This only works for the canvas renderer and\n * not for WebGL.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @api\n */\n\n\nTranslate.prototype.setHitTolerance = function (hitTolerance) {\n  this.hitTolerance_ = hitTolerance;\n};\n/**\n * @inheritDoc\n */\n\n\nTranslate.prototype.setMap = function (map) {\n  const oldMap = this.getMap();\n  PointerInteraction.prototype.setMap.call(this, map);\n  this.updateState_(oldMap);\n};\n/**\n * @private\n */\n\n\nTranslate.prototype.handleActiveChanged_ = function () {\n  this.updateState_(null);\n};\n/**\n * @param {module:ol/PluggableMap} oldMap Old map.\n * @private\n */\n\n\nTranslate.prototype.updateState_ = function (oldMap) {\n  let map = this.getMap();\n  const active = this.getActive();\n\n  if (!map || !active) {\n    map = map || oldMap;\n\n    if (map) {\n      const elem = map.getViewport();\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n};\n\nexport default Translate;","map":null,"metadata":{},"sourceType":"module"}