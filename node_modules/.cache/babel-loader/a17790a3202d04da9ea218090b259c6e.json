{"ast":null,"code":"/**\n * @module ol/Collection\n */\nimport { inherits } from './util.js';\nimport AssertionError from './AssertionError.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport BaseObject from './Object.js';\nimport Event from './events/Event.js';\n/**\n * @enum {string}\n * @private\n */\n\nconst Property = {\n  LENGTH: 'length'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\n * type.\n *\n * @constructor\n * @extends {module:ol/events/Event}\n * @param {module:ol/CollectionEventType} type Type.\n * @param {*=} opt_element Element.\n */\n\nexport const CollectionEvent = function (type, opt_element) {\n  Event.call(this, type);\n  /**\n   * The element that is added to or removed from the collection.\n   * @type {*}\n   * @api\n   */\n\n  this.element = opt_element;\n};\ninherits(CollectionEvent, Event);\n/**\n * @typedef {Object} Options\n * @property {boolean} [unique=false] Disallow the same item from being added to\n * the collection twice.\n */\n\n/**\n * @classdesc\n * An expanded version of standard JS Array, adding convenience methods for\n * manipulation. Add and remove changes to the Collection trigger a Collection\n * event. Note that this does not cover changes to the objects _within_ the\n * Collection; they trigger events on the appropriate object, not on the\n * Collection as a whole.\n *\n * @constructor\n * @extends {module:ol/Object}\n * @fires module:ol/Collection~CollectionEvent\n * @param {Array.<T>=} opt_array Array.\n * @param {module:ol/Collection~Options=} opt_options Collection options.\n * @template T\n * @api\n */\n\nconst Collection = function (opt_array, opt_options) {\n  BaseObject.call(this);\n  const options = opt_options || {};\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.unique_ = !!options.unique;\n  /**\n   * @private\n   * @type {!Array.<T>}\n   */\n\n  this.array_ = opt_array ? opt_array : [];\n\n  if (this.unique_) {\n    for (let i = 0, ii = this.array_.length; i < ii; ++i) {\n      this.assertUnique_(this.array_[i], i);\n    }\n  }\n\n  this.updateLength_();\n};\n\ninherits(Collection, BaseObject);\n/**\n * Remove all elements from the collection.\n * @api\n */\n\nCollection.prototype.clear = function () {\n  while (this.getLength() > 0) {\n    this.pop();\n  }\n};\n/**\n * Add elements to the collection.  This pushes each item in the provided array\n * to the end of the collection.\n * @param {!Array.<T>} arr Array.\n * @return {module:ol/Collection.<T>} This collection.\n * @api\n */\n\n\nCollection.prototype.extend = function (arr) {\n  for (let i = 0, ii = arr.length; i < ii; ++i) {\n    this.push(arr[i]);\n  }\n\n  return this;\n};\n/**\n * Iterate over each element, calling the provided callback.\n * @param {function(T, number, Array.<T>): *} f The function to call\n *     for every element. This function takes 3 arguments (the element, the\n *     index and the array). The return value is ignored.\n * @api\n */\n\n\nCollection.prototype.forEach = function (f) {\n  const array = this.array_;\n\n  for (let i = 0, ii = array.length; i < ii; ++i) {\n    f(array[i], i, array);\n  }\n};\n/**\n * Get a reference to the underlying Array object. Warning: if the array\n * is mutated, no events will be dispatched by the collection, and the\n * collection's \"length\" property won't be in sync with the actual length\n * of the array.\n * @return {!Array.<T>} Array.\n * @api\n */\n\n\nCollection.prototype.getArray = function () {\n  return this.array_;\n};\n/**\n * Get the element at the provided index.\n * @param {number} index Index.\n * @return {T} Element.\n * @api\n */\n\n\nCollection.prototype.item = function (index) {\n  return this.array_[index];\n};\n/**\n * Get the length of this collection.\n * @return {number} The length of the array.\n * @observable\n * @api\n */\n\n\nCollection.prototype.getLength = function () {\n  return (\n    /** @type {number} */\n    this.get(Property.LENGTH)\n  );\n};\n/**\n * Insert an element at the provided index.\n * @param {number} index Index.\n * @param {T} elem Element.\n * @api\n */\n\n\nCollection.prototype.insertAt = function (index, elem) {\n  if (this.unique_) {\n    this.assertUnique_(elem);\n  }\n\n  this.array_.splice(index, 0, elem);\n  this.updateLength_();\n  this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem));\n};\n/**\n * Remove the last element of the collection and return it.\n * Return `undefined` if the collection is empty.\n * @return {T|undefined} Element.\n * @api\n */\n\n\nCollection.prototype.pop = function () {\n  return this.removeAt(this.getLength() - 1);\n};\n/**\n * Insert the provided element at the end of the collection.\n * @param {T} elem Element.\n * @return {number} New length of the collection.\n * @api\n */\n\n\nCollection.prototype.push = function (elem) {\n  if (this.unique_) {\n    this.assertUnique_(elem);\n  }\n\n  const n = this.getLength();\n  this.insertAt(n, elem);\n  return this.getLength();\n};\n/**\n * Remove the first occurrence of an element from the collection.\n * @param {T} elem Element.\n * @return {T|undefined} The removed element or undefined if none found.\n * @api\n */\n\n\nCollection.prototype.remove = function (elem) {\n  const arr = this.array_;\n\n  for (let i = 0, ii = arr.length; i < ii; ++i) {\n    if (arr[i] === elem) {\n      return this.removeAt(i);\n    }\n  }\n\n  return undefined;\n};\n/**\n * Remove the element at the provided index and return it.\n * Return `undefined` if the collection does not contain this index.\n * @param {number} index Index.\n * @return {T|undefined} Value.\n * @api\n */\n\n\nCollection.prototype.removeAt = function (index) {\n  const prev = this.array_[index];\n  this.array_.splice(index, 1);\n  this.updateLength_();\n  this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));\n  return prev;\n};\n/**\n * Set the element at the provided index.\n * @param {number} index Index.\n * @param {T} elem Element.\n * @api\n */\n\n\nCollection.prototype.setAt = function (index, elem) {\n  const n = this.getLength();\n\n  if (index < n) {\n    if (this.unique_) {\n      this.assertUnique_(elem, index);\n    }\n\n    const prev = this.array_[index];\n    this.array_[index] = elem;\n    this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));\n    this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem));\n  } else {\n    for (let j = n; j < index; ++j) {\n      this.insertAt(j, undefined);\n    }\n\n    this.insertAt(index, elem);\n  }\n};\n/**\n * @private\n */\n\n\nCollection.prototype.updateLength_ = function () {\n  this.set(Property.LENGTH, this.array_.length);\n};\n/**\n * @private\n * @param {T} elem Element.\n * @param {number=} opt_except Optional index to ignore.\n */\n\n\nCollection.prototype.assertUnique_ = function (elem, opt_except) {\n  for (let i = 0, ii = this.array_.length; i < ii; ++i) {\n    if (this.array_[i] === elem && i !== opt_except) {\n      throw new AssertionError(58);\n    }\n  }\n};\n\nexport default Collection;","map":null,"metadata":{},"sourceType":"module"}