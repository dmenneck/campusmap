{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _sphere = require(\"ol/sphere\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\n\n\nvar MeasureUtil =\n/*#__PURE__*/\nfunction () {\n  function MeasureUtil() {\n    _classCallCheck(this, MeasureUtil);\n  }\n\n  _createClass(MeasureUtil, null, [{\n    key: \"getLength\",\n\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The length of line in meters.\n     */\n    value: function getLength(line, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getLength)(line, opts);\n      } else {\n        return Math.round(line.getLength() * 100) / 100;\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line.\n     */\n\n  }, {\n    key: \"formatLength\",\n    value: function formatLength(line, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var length = MeasureUtil.getLength(line, map, geodesic);\n      var output;\n\n      if (length > 1000) {\n        output = Math.round(length / 1000 * decimalHelper) / decimalHelper + ' km';\n      } else {\n        output = Math.round(length * decimalHelper) / decimalHelper + ' m';\n      }\n\n      return output;\n    }\n    /**\n     * Get the area of a OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea(polygon, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getArea)(polygon, opts);\n      } else {\n        return polygon.getArea();\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n\n  }, {\n    key: \"formatArea\",\n    value: function formatArea(polygon, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var area = MeasureUtil.getArea(polygon, map, geodesic);\n      var output;\n\n      if (area > 10000) {\n        output = Math.round(area / 1000000 * decimalHelper) / decimalHelper + ' km<sup>2</sup>';\n      } else {\n        output = Math.round(area * decimalHelper) / decimalHelper + ' m<sup>2</sup>';\n      }\n\n      return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degreees, ranging from -180° to 180°.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(start, end) {\n      var dx = start[0] - end[0];\n      var dy = start[1] - end[1]; // range (-PI, PI]\n\n      var theta = Math.atan2(dy, dx); // rads to degs, range (-180, 180]\n\n      theta *= 180 / Math.PI;\n      return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n\n  }, {\n    key: \"angle360\",\n    value: function angle360(start, end) {\n      // range (-180, 180]\n      var theta = MeasureUtil.angle(start, end);\n\n      if (theta < 0) {\n        // range [0, 360)\n        theta = 360 + theta;\n      }\n\n      return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n\n  }, {\n    key: \"makeClockwise\",\n    value: function makeClockwise(angle360) {\n      return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n\n  }, {\n    key: \"makeZeroDegreesAtNorth\",\n    value: function makeZeroDegreesAtNorth(angle360) {\n      var corrected = angle360 + 90;\n\n      if (corrected > 360) {\n        corrected = corrected - 360;\n      }\n\n      return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is comming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n\n  }, {\n    key: \"formatAngle\",\n    value: function formatAngle(line) {\n      var decimalPlacesInToolTips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var coords = line.getCoordinates();\n      var numCoords = coords.length;\n\n      if (numCoords < 2) {\n        return '';\n      }\n\n      var lastPoint = coords[numCoords - 1];\n      var prevPoint = coords[numCoords - 2];\n      var angle = MeasureUtil.angle360(prevPoint, lastPoint);\n      angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n      angle = MeasureUtil.makeClockwise(angle);\n      angle = angle.toFixed(decimalPlacesInToolTips);\n      return \"\".concat(angle, \"\\xB0\");\n    }\n  }]);\n\n  return MeasureUtil;\n}();\n\nvar _default = MeasureUtil;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/@terrestris/react-geo/node_modules/@terrestris/ol-util/dist/MeasureUtil/MeasureUtil.js"],"names":["Object","defineProperty","exports","value","_sphere","require","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","MeasureUtil","getLength","line","map","geodesic","arguments","undefined","radius","opts","projection","getView","getProjection","getCode","Math","round","formatLength","decimalPlacesInToolTips","decimalHelper","pow","output","getArea","polygon","formatArea","area","angle","start","end","dx","dy","theta","atan2","PI","angle360","makeClockwise","makeZeroDegreesAtNorth","corrected","formatAngle","coords","getCoordinates","numCoords","lastPoint","prevPoint","toFixed","concat","_default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,OAAO,GAAGC,OAAO,CAAC,WAAD,CAArB;;AAEA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BlB,IAAAA,MAAM,CAACC,cAAP,CAAsBU,MAAtB,EAA8BI,UAAU,CAACI,GAAzC,EAA8CJ,UAA9C;AAA4D;AAAE;;AAE7T,SAASK,YAAT,CAAsBZ,WAAtB,EAAmCa,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBX,iBAAiB,CAACF,WAAW,CAACe,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBZ,iBAAiB,CAACF,WAAD,EAAcc,WAAd,CAAjB;AAA6C,SAAOd,WAAP;AAAqB;AAEvN;;;;;;;;AAMA,IAAIgB,WAAW;AACf;AACA,YAAY;AACV,WAASA,WAAT,GAAuB;AACrBlB,IAAAA,eAAe,CAAC,IAAD,EAAOkB,WAAP,CAAf;AACD;;AAEDJ,EAAAA,YAAY,CAACI,WAAD,EAAc,IAAd,EAAoB,CAAC;AAC/BL,IAAAA,GAAG,EAAE,WAD0B;;AAG/B;;;;;;;;;;;AAWAhB,IAAAA,KAAK,EAAE,SAASsB,SAAT,CAAmBC,IAAnB,EAAyBC,GAAzB,EAA8B;AACnC,UAAIC,QAAQ,GAAGC,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAnF;AACA,UAAIE,MAAM,GAAGF,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,SAAjF;;AAEA,UAAID,QAAJ,EAAc;AACZ,YAAII,IAAI,GAAG;AACTC,UAAAA,UAAU,EAAEN,GAAG,CAACO,OAAJ,GAAcC,aAAd,GAA8BC,OAA9B,EADH;AAETL,UAAAA,MAAM,EAAEA;AAFC,SAAX;AAIA,eAAO,CAAC,GAAG3B,OAAO,CAACqB,SAAZ,EAAuBC,IAAvB,EAA6BM,IAA7B,CAAP;AACD,OAND,MAMO;AACL,eAAOK,IAAI,CAACC,KAAL,CAAWZ,IAAI,CAACD,SAAL,KAAmB,GAA9B,IAAqC,GAA5C;AACD;AACF;AACD;;;;;;;;;;;;AA5B+B,GAAD,EAwC7B;AACDN,IAAAA,GAAG,EAAE,cADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASoC,YAAT,CAAsBb,IAAtB,EAA4BC,GAA5B,EAAiCa,uBAAjC,EAA0D;AAC/D,UAAIZ,QAAQ,GAAGC,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAnF;AACA,UAAIY,aAAa,GAAGJ,IAAI,CAACK,GAAL,CAAS,EAAT,EAAaF,uBAAb,CAApB;AACA,UAAI1B,MAAM,GAAGU,WAAW,CAACC,SAAZ,CAAsBC,IAAtB,EAA4BC,GAA5B,EAAiCC,QAAjC,CAAb;AACA,UAAIe,MAAJ;;AAEA,UAAI7B,MAAM,GAAG,IAAb,EAAmB;AACjB6B,QAAAA,MAAM,GAAGN,IAAI,CAACC,KAAL,CAAWxB,MAAM,GAAG,IAAT,GAAgB2B,aAA3B,IAA4CA,aAA5C,GAA4D,KAArE;AACD,OAFD,MAEO;AACLE,QAAAA,MAAM,GAAGN,IAAI,CAACC,KAAL,CAAWxB,MAAM,GAAG2B,aAApB,IAAqCA,aAArC,GAAqD,IAA9D;AACD;;AAED,aAAOE,MAAP;AACD;AACD;;;;;;;;;;;;AAhBC,GAxC6B,EAoE7B;AACDxB,IAAAA,GAAG,EAAE,SADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASyC,OAAT,CAAiBC,OAAjB,EAA0BlB,GAA1B,EAA+B;AACpC,UAAIC,QAAQ,GAAGC,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAnF;AACA,UAAIE,MAAM,GAAGF,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,SAAjF;;AAEA,UAAID,QAAJ,EAAc;AACZ,YAAII,IAAI,GAAG;AACTC,UAAAA,UAAU,EAAEN,GAAG,CAACO,OAAJ,GAAcC,aAAd,GAA8BC,OAA9B,EADH;AAETL,UAAAA,MAAM,EAAEA;AAFC,SAAX;AAIA,eAAO,CAAC,GAAG3B,OAAO,CAACwC,OAAZ,EAAqBC,OAArB,EAA8Bb,IAA9B,CAAP;AACD,OAND,MAMO;AACL,eAAOa,OAAO,CAACD,OAAR,EAAP;AACD;AACF;AACD;;;;;;;;;;;;AAhBC,GApE6B,EAgG7B;AACDzB,IAAAA,GAAG,EAAE,YADJ;AAEDhB,IAAAA,KAAK,EAAE,SAAS2C,UAAT,CAAoBD,OAApB,EAA6BlB,GAA7B,EAAkCa,uBAAlC,EAA2D;AAChE,UAAIZ,QAAQ,GAAGC,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAnF;AACA,UAAIY,aAAa,GAAGJ,IAAI,CAACK,GAAL,CAAS,EAAT,EAAaF,uBAAb,CAApB;AACA,UAAIO,IAAI,GAAGvB,WAAW,CAACoB,OAAZ,CAAoBC,OAApB,EAA6BlB,GAA7B,EAAkCC,QAAlC,CAAX;AACA,UAAIe,MAAJ;;AAEA,UAAII,IAAI,GAAG,KAAX,EAAkB;AAChBJ,QAAAA,MAAM,GAAGN,IAAI,CAACC,KAAL,CAAWS,IAAI,GAAG,OAAP,GAAiBN,aAA5B,IAA6CA,aAA7C,GAA6D,iBAAtE;AACD,OAFD,MAEO;AACLE,QAAAA,MAAM,GAAGN,IAAI,CAACC,KAAL,CAAWS,IAAI,GAAGN,aAAlB,IAAmCA,aAAnC,GAAmD,gBAA5D;AACD;;AAED,aAAOE,MAAP;AACD;AACD;;;;;;;;;;;;;;;AAhBC,GAhG6B,EA+H7B;AACDxB,IAAAA,GAAG,EAAE,OADJ;AAEDhB,IAAAA,KAAK,EAAE,SAAS6C,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2B;AAChC,UAAIC,EAAE,GAAGF,KAAK,CAAC,CAAD,CAAL,GAAWC,GAAG,CAAC,CAAD,CAAvB;AACA,UAAIE,EAAE,GAAGH,KAAK,CAAC,CAAD,CAAL,GAAWC,GAAG,CAAC,CAAD,CAAvB,CAFgC,CAEJ;;AAE5B,UAAIG,KAAK,GAAGhB,IAAI,CAACiB,KAAL,CAAWF,EAAX,EAAeD,EAAf,CAAZ,CAJgC,CAIA;;AAEhCE,MAAAA,KAAK,IAAI,MAAMhB,IAAI,CAACkB,EAApB;AACA,aAAOF,KAAP;AACD;AACD;;;;;;;;;;;;;;;AAXC,GA/H6B,EAyJ7B;AACDlC,IAAAA,GAAG,EAAE,UADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASqD,QAAT,CAAkBP,KAAlB,EAAyBC,GAAzB,EAA8B;AACnC;AACA,UAAIG,KAAK,GAAG7B,WAAW,CAACwB,KAAZ,CAAkBC,KAAlB,EAAyBC,GAAzB,CAAZ;;AAEA,UAAIG,KAAK,GAAG,CAAZ,EAAe;AACb;AACAA,QAAAA,KAAK,GAAG,MAAMA,KAAd;AACD;;AAED,aAAOA,KAAP;AACD;AACD;;;;;;;;;;AAbC,GAzJ6B,EAgL7B;AACDlC,IAAAA,GAAG,EAAE,eADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASsD,aAAT,CAAuBD,QAAvB,EAAiC;AACtC,aAAO,MAAMA,QAAb;AACD;AACD;;;;;;;;;;AALC,GAhL6B,EA+L7B;AACDrC,IAAAA,GAAG,EAAE,wBADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASuD,sBAAT,CAAgCF,QAAhC,EAA0C;AAC/C,UAAIG,SAAS,GAAGH,QAAQ,GAAG,EAA3B;;AAEA,UAAIG,SAAS,GAAG,GAAhB,EAAqB;AACnBA,QAAAA,SAAS,GAAGA,SAAS,GAAG,GAAxB;AACD;;AAED,aAAOA,SAAP;AACD;AACD;;;;;;;;;;;;;AAXC,GA/L6B,EAuN7B;AACDxC,IAAAA,GAAG,EAAE,aADJ;AAEDhB,IAAAA,KAAK,EAAE,SAASyD,WAAT,CAAqBlC,IAArB,EAA2B;AAChC,UAAIc,uBAAuB,GAAGX,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlG;AACA,UAAIgC,MAAM,GAAGnC,IAAI,CAACoC,cAAL,EAAb;AACA,UAAIC,SAAS,GAAGF,MAAM,CAAC/C,MAAvB;;AAEA,UAAIiD,SAAS,GAAG,CAAhB,EAAmB;AACjB,eAAO,EAAP;AACD;;AAED,UAAIC,SAAS,GAAGH,MAAM,CAACE,SAAS,GAAG,CAAb,CAAtB;AACA,UAAIE,SAAS,GAAGJ,MAAM,CAACE,SAAS,GAAG,CAAb,CAAtB;AACA,UAAIf,KAAK,GAAGxB,WAAW,CAACgC,QAAZ,CAAqBS,SAArB,EAAgCD,SAAhC,CAAZ;AACAhB,MAAAA,KAAK,GAAGxB,WAAW,CAACkC,sBAAZ,CAAmCV,KAAnC,CAAR;AACAA,MAAAA,KAAK,GAAGxB,WAAW,CAACiC,aAAZ,CAA0BT,KAA1B,CAAR;AACAA,MAAAA,KAAK,GAAGA,KAAK,CAACkB,OAAN,CAAc1B,uBAAd,CAAR;AACA,aAAO,GAAG2B,MAAH,CAAUnB,KAAV,EAAiB,MAAjB,CAAP;AACD;AAlBA,GAvN6B,CAApB,CAAZ;;AA4OA,SAAOxB,WAAP;AACD,CAlPD,EAFA;;AAsPA,IAAI4C,QAAQ,GAAG5C,WAAf;AACAtB,OAAO,CAAC,SAAD,CAAP,GAAqBkE,QAArB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _sphere = require(\"ol/sphere\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * This class provides some static methods which might be helpful when working\n * with measurements.\n *\n * @class MeasureUtil\n */\nvar MeasureUtil =\n/*#__PURE__*/\nfunction () {\n  function MeasureUtil() {\n    _classCallCheck(this, MeasureUtil);\n  }\n\n  _createClass(MeasureUtil, null, [{\n    key: \"getLength\",\n\n    /**\n     * Get the length of a OlGeomLineString.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The length of line in meters.\n     */\n    value: function getLength(line, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getLength)(line, opts);\n      } else {\n        return Math.round(line.getLength() * 100) / 100;\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomLineString} line The drawn line.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     *\n     * @return {string} The formatted length of the line.\n     */\n\n  }, {\n    key: \"formatLength\",\n    value: function formatLength(line, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var length = MeasureUtil.getLength(line, map, geodesic);\n      var output;\n\n      if (length > 1000) {\n        output = Math.round(length / 1000 * decimalHelper) / decimalHelper + ' km';\n      } else {\n        output = Math.round(length * decimalHelper) / decimalHelper + ' m';\n      }\n\n      return output;\n    }\n    /**\n     * Get the area of a OlGeomPolygon.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {boolean} geodesic Is the measurement geodesic (default is true).\n     * @param {number} radius Sphere radius. By default, the radius of the earth\n     *                        is used (Clarke 1866 Authalic Sphere, 6371008.8).\n     *\n     * @return {number} The area of the polygon in square meter.\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea(polygon, map) {\n      var geodesic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371008.8;\n\n      if (geodesic) {\n        var opts = {\n          projection: map.getView().getProjection().getCode(),\n          radius: radius\n        };\n        return (0, _sphere.getArea)(polygon, opts);\n      } else {\n        return polygon.getArea();\n      }\n    }\n    /**\n     * Format length output for the tooltip.\n     *\n     * @param {OlGeomPolygon} polygon The drawn polygon.\n     * @param {OlMap} map An OlMap.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     * @param {boolean} geodesic Is the measurement geodesic.\n     *\n     * @return {string} The formatted area of the polygon.\n     */\n\n  }, {\n    key: \"formatArea\",\n    value: function formatArea(polygon, map, decimalPlacesInToolTips) {\n      var geodesic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var decimalHelper = Math.pow(10, decimalPlacesInToolTips);\n      var area = MeasureUtil.getArea(polygon, map, geodesic);\n      var output;\n\n      if (area > 10000) {\n        output = Math.round(area / 1000000 * decimalHelper) / decimalHelper + ' km<sup>2</sup>';\n      } else {\n        output = Math.round(area * decimalHelper) / decimalHelper + ' m<sup>2</sup>';\n      }\n\n      return output;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * -180° and 180°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degreees, ranging from -180° to 180°.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(start, end) {\n      var dx = start[0] - end[0];\n      var dy = start[1] - end[1]; // range (-PI, PI]\n\n      var theta = Math.atan2(dy, dx); // rads to degs, range (-180, 180]\n\n      theta *= 180 / Math.PI;\n      return theta;\n    }\n    /**\n     * Determine the angle between two coordinates. The angle will be between\n     * 0° and 360°, with 0° being in the east. The angle will increase\n     * counter-clockwise.\n     *\n     * Inspired by https://stackoverflow.com/a/31136507\n     *\n     * @param {Array<number>} start The start coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     * @param {Array<number>} end The end coordinates of the line with the\n     *     x-coordinate being at index `0` and y-coordinate being at index `1`.\n     *\n     * @return {number} the angle in degrees, ranging from 0° and 360°.\n     */\n\n  }, {\n    key: \"angle360\",\n    value: function angle360(start, end) {\n      // range (-180, 180]\n      var theta = MeasureUtil.angle(start, end);\n\n      if (theta < 0) {\n        // range [0, 360)\n        theta = 360 + theta;\n      }\n\n      return theta;\n    }\n    /**\n     * Given an angle between 0° and 360° this angle returns the exact opposite\n     * of the angle, e.g. for 90° you'll get back 270°. This effectively turns\n     * the direction of the angle from counter-clockwise to clockwise.\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise.\n     *\n     * @return {number} The clockwise angle.\n     */\n\n  }, {\n    key: \"makeClockwise\",\n    value: function makeClockwise(angle360) {\n      return 360 - angle360;\n    }\n    /**\n     * This methods adds an offset of 90° to an counter-clockwise increasing\n     * angle of a line so that the origin (0°) lies at the top (in the north).\n     *\n     * @param {number} angle360 The input angle obtained counter-clockwise, with\n     *     0° degrees being in the east.\n     *\n     * @return {number} The adjusted angle, with 0° being in the north.\n     */\n\n  }, {\n    key: \"makeZeroDegreesAtNorth\",\n    value: function makeZeroDegreesAtNorth(angle360) {\n      var corrected = angle360 + 90;\n\n      if (corrected > 360) {\n        corrected = corrected - 360;\n      }\n\n      return corrected;\n    }\n    /**\n     * Returns the angle of the passed linestring in degrees, with 'N' being the\n     * 0°-line and the angle increases in clockwise direction.\n     *\n     * @param {OlGeomLineString} line The linestring to get the\n     *   angle from. As this line is comming from our internal draw\n     *   interaction, we know that it will only consist of two points.\n     * @param {number} decimalPlacesInToolTips How many decimal places will be\n     *   allowed for the measure tooltips.\n     *\n     * @return {string} The formatted angle of the line.\n     */\n\n  }, {\n    key: \"formatAngle\",\n    value: function formatAngle(line) {\n      var decimalPlacesInToolTips = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var coords = line.getCoordinates();\n      var numCoords = coords.length;\n\n      if (numCoords < 2) {\n        return '';\n      }\n\n      var lastPoint = coords[numCoords - 1];\n      var prevPoint = coords[numCoords - 2];\n      var angle = MeasureUtil.angle360(prevPoint, lastPoint);\n      angle = MeasureUtil.makeZeroDegreesAtNorth(angle);\n      angle = MeasureUtil.makeClockwise(angle);\n      angle = angle.toFixed(decimalPlacesInToolTips);\n      return \"\".concat(angle, \"\\xB0\");\n    }\n  }]);\n\n  return MeasureUtil;\n}();\n\nvar _default = MeasureUtil;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}