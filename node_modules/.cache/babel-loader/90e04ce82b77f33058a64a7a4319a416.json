{"ast":null,"code":"/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport { ENABLE_RASTER_REPROJECTION } from '../../reproj/common.js';\nimport { inherits } from '../../util.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { equals } from '../../array.js';\nimport { getHeight, getIntersection, getWidth, isEmpty } from '../../extent.js';\nimport VectorRenderType from '../../layer/VectorRenderType.js';\nimport { assign } from '../../obj.js';\nimport { layerRendererConstructors } from './Map.js';\nimport IntermediateCanvasRenderer from '../canvas/IntermediateCanvas.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n/**\n * @constructor\n * @extends {module:ol/renderer/canvas/IntermediateCanvas}\n * @param {module:ol/layer/Image|module:ol/layer/Vector} imageLayer Image or vector layer.\n * @api\n */\n\nconst CanvasImageLayerRenderer = function (imageLayer) {\n  IntermediateCanvasRenderer.call(this, imageLayer);\n  /**\n   * @private\n   * @type {?module:ol/ImageBase}\n   */\n\n  this.image_ = null;\n  /**\n   * @private\n   * @type {module:ol/transform~Transform}\n   */\n\n  this.imageTransform_ = createTransform();\n  /**\n   * @type {!Array.<string>}\n   */\n\n  this.skippedFeatures_ = [];\n  /**\n   * @private\n   * @type {module:ol/renderer/canvas/VectorLayer}\n   */\n\n  this.vectorRenderer_ = null;\n\n  if (imageLayer.getType() === LayerType.VECTOR) {\n    for (let i = 0, ii = layerRendererConstructors.length; i < ii; ++i) {\n      const ctor = layerRendererConstructors[i];\n\n      if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {\n        this.vectorRenderer_ = new ctor(imageLayer);\n        break;\n      }\n    }\n  }\n};\n\ninherits(CanvasImageLayerRenderer, IntermediateCanvasRenderer);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {module:ol/layer/Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\nCanvasImageLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.IMAGE || layer.getType() === LayerType.VECTOR &&\n  /** @type {module:ol/layer/Vector} */\n  layer.getRenderMode() === VectorRenderType.IMAGE;\n};\n/**\n * Create a layer renderer.\n * @param {module:ol/renderer/Map} mapRenderer The map renderer.\n * @param {module:ol/layer/Layer} layer The layer to be rendererd.\n * @return {module:ol/renderer/canvas/ImageLayer} The layer renderer.\n */\n\n\nCanvasImageLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasImageLayerRenderer(\n  /** @type {module:ol/layer/Image} */\n  layer);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasImageLayerRenderer.prototype.disposeInternal = function () {\n  if (this.vectorRenderer_) {\n    this.vectorRenderer_.dispose();\n  }\n\n  IntermediateCanvasRenderer.prototype.disposeInternal.call(this);\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasImageLayerRenderer.prototype.getImage = function () {\n  return !this.image_ ? null : this.image_.getImage();\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasImageLayerRenderer.prototype.getImageTransform = function () {\n  return this.imageTransform_;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasImageLayerRenderer.prototype.prepareFrame = function (frameState, layerState) {\n  const pixelRatio = frameState.pixelRatio;\n  const size = frameState.size;\n  const viewState = frameState.viewState;\n  const viewCenter = viewState.center;\n  const viewResolution = viewState.resolution;\n  let image;\n  const imageLayer =\n  /** @type {module:ol/layer/Image} */\n  this.getLayer();\n  const imageSource = imageLayer.getSource();\n  const hints = frameState.viewHints;\n  const vectorRenderer = this.vectorRenderer_;\n  let renderedExtent = frameState.extent;\n\n  if (!vectorRenderer && layerState.extent !== undefined) {\n    renderedExtent = getIntersection(renderedExtent, layerState.extent);\n  }\n\n  if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n    let projection = viewState.projection;\n\n    if (!ENABLE_RASTER_REPROJECTION) {\n      const sourceProjection = imageSource.getProjection();\n\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n    }\n\n    let skippedFeatures = this.skippedFeatures_;\n\n    if (vectorRenderer) {\n      const context = vectorRenderer.context;\n      const imageFrameState =\n      /** @type {module:ol/PluggableMap~FrameState} */\n      assign({}, frameState, {\n        size: [getWidth(renderedExtent) / viewResolution, getHeight(renderedExtent) / viewResolution],\n        viewState:\n        /** @type {module:ol/View~State} */\n        assign({}, frameState.viewState, {\n          rotation: 0\n        })\n      });\n      const newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();\n      image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {\n        if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !equals(skippedFeatures, newSkippedFeatures))) {\n          context.canvas.width = imageFrameState.size[0] * pixelRatio;\n          context.canvas.height = imageFrameState.size[1] * pixelRatio;\n          vectorRenderer.compose(context, imageFrameState, layerState);\n          skippedFeatures = newSkippedFeatures;\n          callback();\n        }\n      });\n    } else {\n      image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n    }\n\n    if (image && this.loadImage(image)) {\n      this.image_ = image;\n      this.skippedFeatures_ = skippedFeatures;\n    }\n  }\n\n  if (this.image_) {\n    image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n    const transform = composeTransform(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n    composeTransform(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n  }\n\n  return !!this.image_;\n};\n/**\n * @inheritDoc\n */\n\n\nCanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\n  if (this.vectorRenderer_) {\n    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\n  } else {\n    return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);\n  }\n};\n\nexport default CanvasImageLayerRenderer;","map":null,"metadata":{},"sourceType":"module"}