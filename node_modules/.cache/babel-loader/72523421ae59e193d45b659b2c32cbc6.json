{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\n\nvar compressions = require('./compressions');\n\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\n\n\nexports.string2binary = function (str) {\n  var result = \"\";\n\n  for (var i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n  }\n\n  return result;\n};\n\nexports.arrayBuffer2Blob = function (buffer, mimeType) {\n  exports.checkSupport(\"blob\");\n  mimeType = mimeType || 'application/zip';\n\n  try {\n    // Blob constructor\n    return new Blob([buffer], {\n      type: mimeType\n    });\n  } catch (e) {\n    try {\n      // deprecated, browser only, old way\n      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n      var builder = new Builder();\n      builder.append(buffer);\n      return builder.getBlob(mimeType);\n    } catch (e) {\n      // well, fuck ?!\n      throw new Error(\"Bug : can't construct the Blob.\");\n    }\n  }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\n\n\nfunction identity(input) {\n  return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\n\n\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n\n  return array;\n}\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\n\n\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  var chunk = 65536;\n  var result = [],\n      len = array.length,\n      type = exports.getTypeOf(array),\n      k = 0,\n      canUseApply = true;\n\n  try {\n    switch (type) {\n      case \"uint8array\":\n        String.fromCharCode.apply(null, new Uint8Array(0));\n        break;\n\n      case \"nodebuffer\":\n        String.fromCharCode.apply(null, nodeBuffer(0));\n        break;\n    }\n  } catch (e) {\n    canUseApply = false;\n  } // no apply : slow and painful algorithm\n  // default browser on android 4.*\n\n\n  if (!canUseApply) {\n    var resultStr = \"\";\n\n    for (var i = 0; i < array.length; i++) {\n      resultStr += String.fromCharCode(array[i]);\n    }\n\n    return resultStr;\n  }\n\n  while (k < len && chunk > 1) {\n    try {\n      if (type === \"array\" || type === \"nodebuffer\") {\n        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n      } else {\n        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n      }\n\n      k += chunk;\n    } catch (e) {\n      chunk = Math.floor(chunk / 2);\n    }\n  }\n\n  return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\n\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n\n  return arrayTo;\n} // a matrix containing functions to transform everything into everything.\n\n\nvar transform = {}; // string to ?\n\ntransform[\"string\"] = {\n  \"string\": identity,\n  \"array\": function (input) {\n    return stringToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"string\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return stringToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": function (input) {\n    return stringToArrayLike(input, nodeBuffer(input.length));\n  }\n}; // array to ?\n\ntransform[\"array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": identity,\n  \"arraybuffer\": function (input) {\n    return new Uint8Array(input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n}; // arraybuffer to ?\n\ntransform[\"arraybuffer\"] = {\n  \"string\": function (input) {\n    return arrayLikeToString(new Uint8Array(input));\n  },\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n  },\n  \"arraybuffer\": identity,\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(new Uint8Array(input));\n  }\n}; // uint8array to ?\n\ntransform[\"uint8array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return input.buffer;\n  },\n  \"uint8array\": identity,\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n}; // nodebuffer to ?\n\ntransform[\"nodebuffer\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\n\nexports.transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n\n  if (!outputType) {\n    return input;\n  }\n\n  exports.checkSupport(outputType);\n  var inputType = exports.getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\n\n\nexports.getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n\n  if (support.nodebuffer && nodeBuffer.test(input)) {\n    return \"nodebuffer\";\n  }\n\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\n\n\nexports.checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n\n  if (!supported) {\n    throw new Error(type + \" is not supported by this browser\");\n  }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\n\nexports.pretty = function (str) {\n  var res = '',\n      code,\n      i;\n\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n\n  return res;\n};\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\n\n\nexports.findCompression = function (compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n\n  return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\n\n\nexports.isRegExp = function (object) {\n  return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\n\n\nexports.extend = function () {\n  var result = {},\n      i,\n      attr;\n\n  for (i = 0; i < arguments.length; i++) {\n    // arguments is not enumerable in some browsers\n    for (attr in arguments[i]) {\n      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n        result[attr] = arguments[i][attr];\n      }\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/jszip/lib/utils.js"],"names":["support","require","compressions","nodeBuffer","exports","string2binary","str","result","i","length","String","fromCharCode","charCodeAt","arrayBuffer2Blob","buffer","mimeType","checkSupport","Blob","type","e","Builder","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","append","getBlob","Error","identity","input","stringToArrayLike","array","arrayLikeToString","chunk","len","getTypeOf","k","canUseApply","apply","Uint8Array","resultStr","push","slice","Math","min","subarray","floor","join","applyFromCharCode","arrayLikeToArrayLike","arrayFrom","arrayTo","transform","Array","byteLength","transformTo","outputType","inputType","Object","prototype","toString","call","nodebuffer","test","uint8array","arraybuffer","ArrayBuffer","supported","toLowerCase","MAX_VALUE_16BITS","MAX_VALUE_32BITS","pretty","res","code","toUpperCase","findCompression","compressionMethod","method","hasOwnProperty","magic","isRegExp","object","extend","attr","arguments"],"mappings":"AAAA;;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,cAAD,CAAxB;AACA;;;;;;;AAKAG,OAAO,CAACC,aAAR,GAAwB,UAASC,GAAT,EAAc;AAClC,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACG,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACjCD,IAAAA,MAAM,IAAIG,MAAM,CAACC,YAAP,CAAoBL,GAAG,CAACM,UAAJ,CAAeJ,CAAf,IAAoB,IAAxC,CAAV;AACH;;AACD,SAAOD,MAAP;AACH,CAND;;AAOAH,OAAO,CAACS,gBAAR,GAA2B,UAASC,MAAT,EAAiBC,QAAjB,EAA2B;AAClDX,EAAAA,OAAO,CAACY,YAAR,CAAqB,MAArB;AACHD,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,iBAAvB;;AAEG,MAAI;AACA;AACA,WAAO,IAAIE,IAAJ,CAAS,CAACH,MAAD,CAAT,EAAmB;AACtBI,MAAAA,IAAI,EAAEH;AADgB,KAAnB,CAAP;AAGH,GALD,CAMA,OAAOI,CAAP,EAAU;AAEN,QAAI;AACA;AACA,UAAIC,OAAO,GAAGC,MAAM,CAACC,WAAP,IAAsBD,MAAM,CAACE,iBAA7B,IAAkDF,MAAM,CAACG,cAAzD,IAA2EH,MAAM,CAACI,aAAhG;AACA,UAAIC,OAAO,GAAG,IAAIN,OAAJ,EAAd;AACAM,MAAAA,OAAO,CAACC,MAAR,CAAeb,MAAf;AACA,aAAOY,OAAO,CAACE,OAAR,CAAgBb,QAAhB,CAAP;AACH,KAND,CAOA,OAAOI,CAAP,EAAU;AAEN;AACA,YAAM,IAAIU,KAAJ,CAAU,iCAAV,CAAN;AACH;AACJ;AAGJ,CA3BD;AA4BA;;;;;;;AAKA,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AACrB,SAAOA,KAAP;AACH;AAED;;;;;;;;AAMA,SAASC,iBAAT,CAA2B1B,GAA3B,EAAgC2B,KAAhC,EAAuC;AACnC,OAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAAG,CAACG,MAAxB,EAAgC,EAAED,CAAlC,EAAqC;AACjCyB,IAAAA,KAAK,CAACzB,CAAD,CAAL,GAAWF,GAAG,CAACM,UAAJ,CAAeJ,CAAf,IAAoB,IAA/B;AACH;;AACD,SAAOyB,KAAP;AACH;AAED;;;;;;;AAKA,SAASC,iBAAT,CAA2BD,KAA3B,EAAkC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIE,KAAK,GAAG,KAAZ;AACA,MAAI5B,MAAM,GAAG,EAAb;AAAA,MACI6B,GAAG,GAAGH,KAAK,CAACxB,MADhB;AAAA,MAEIS,IAAI,GAAGd,OAAO,CAACiC,SAAR,CAAkBJ,KAAlB,CAFX;AAAA,MAGIK,CAAC,GAAG,CAHR;AAAA,MAIIC,WAAW,GAAG,IAJlB;;AAKE,MAAI;AACD,YAAOrB,IAAP;AACG,WAAK,YAAL;AACGR,QAAAA,MAAM,CAACC,YAAP,CAAoB6B,KAApB,CAA0B,IAA1B,EAAgC,IAAIC,UAAJ,CAAe,CAAf,CAAhC;AACA;;AACH,WAAK,YAAL;AACG/B,QAAAA,MAAM,CAACC,YAAP,CAAoB6B,KAApB,CAA0B,IAA1B,EAAgCrC,UAAU,CAAC,CAAD,CAA1C;AACA;AANN;AAQF,GATD,CASE,OAAMgB,CAAN,EAAS;AACRoB,IAAAA,WAAW,GAAG,KAAd;AACF,GA3B2B,CA6B5B;AACA;;;AACA,MAAI,CAACA,WAAL,EAAkB;AACf,QAAIG,SAAS,GAAG,EAAhB;;AACA,SAAI,IAAIlC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGyB,KAAK,CAACxB,MAAzB,EAAgCD,CAAC,EAAjC,EAAqC;AAClCkC,MAAAA,SAAS,IAAIhC,MAAM,CAACC,YAAP,CAAoBsB,KAAK,CAACzB,CAAD,CAAzB,CAAb;AACF;;AACN,WAAOkC,SAAP;AACC;;AACD,SAAOJ,CAAC,GAAGF,GAAJ,IAAWD,KAAK,GAAG,CAA1B,EAA6B;AACzB,QAAI;AACA,UAAIjB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,YAAjC,EAA+C;AAC3CX,QAAAA,MAAM,CAACoC,IAAP,CAAYjC,MAAM,CAACC,YAAP,CAAoB6B,KAApB,CAA0B,IAA1B,EAAgCP,KAAK,CAACW,KAAN,CAAYN,CAAZ,EAAeO,IAAI,CAACC,GAAL,CAASR,CAAC,GAAGH,KAAb,EAAoBC,GAApB,CAAf,CAAhC,CAAZ;AACH,OAFD,MAGK;AACD7B,QAAAA,MAAM,CAACoC,IAAP,CAAYjC,MAAM,CAACC,YAAP,CAAoB6B,KAApB,CAA0B,IAA1B,EAAgCP,KAAK,CAACc,QAAN,CAAeT,CAAf,EAAkBO,IAAI,CAACC,GAAL,CAASR,CAAC,GAAGH,KAAb,EAAoBC,GAApB,CAAlB,CAAhC,CAAZ;AACH;;AACDE,MAAAA,CAAC,IAAIH,KAAL;AACH,KARD,CASA,OAAOhB,CAAP,EAAU;AACNgB,MAAAA,KAAK,GAAGU,IAAI,CAACG,KAAL,CAAWb,KAAK,GAAG,CAAnB,CAAR;AACH;AACJ;;AACD,SAAO5B,MAAM,CAAC0C,IAAP,CAAY,EAAZ,CAAP;AACH;;AAED7C,OAAO,CAAC8C,iBAAR,GAA4BhB,iBAA5B;AAGA;;;;;;;AAMA,SAASiB,oBAAT,CAA8BC,SAA9B,EAAyCC,OAAzC,EAAkD;AAC9C,OAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4C,SAAS,CAAC3C,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACvC6C,IAAAA,OAAO,CAAC7C,CAAD,CAAP,GAAa4C,SAAS,CAAC5C,CAAD,CAAtB;AACH;;AACD,SAAO6C,OAAP;AACH,C,CAED;;;AACA,IAAIC,SAAS,GAAG,EAAhB,C,CAEA;;AACAA,SAAS,CAAC,QAAD,CAAT,GAAsB;AAClB,YAAUxB,QADQ;AAElB,WAAS,UAASC,KAAT,EAAgB;AACrB,WAAOC,iBAAiB,CAACD,KAAD,EAAQ,IAAIwB,KAAJ,CAAUxB,KAAK,CAACtB,MAAhB,CAAR,CAAxB;AACH,GAJiB;AAKlB,iBAAe,UAASsB,KAAT,EAAgB;AAC3B,WAAOuB,SAAS,CAAC,QAAD,CAAT,CAAoB,YAApB,EAAkCvB,KAAlC,EAAyCjB,MAAhD;AACH,GAPiB;AAQlB,gBAAc,UAASiB,KAAT,EAAgB;AAC1B,WAAOC,iBAAiB,CAACD,KAAD,EAAQ,IAAIU,UAAJ,CAAeV,KAAK,CAACtB,MAArB,CAAR,CAAxB;AACH,GAViB;AAWlB,gBAAc,UAASsB,KAAT,EAAgB;AAC1B,WAAOC,iBAAiB,CAACD,KAAD,EAAQ5B,UAAU,CAAC4B,KAAK,CAACtB,MAAP,CAAlB,CAAxB;AACH;AAbiB,CAAtB,C,CAgBA;;AACA6C,SAAS,CAAC,OAAD,CAAT,GAAqB;AACjB,YAAUpB,iBADO;AAEjB,WAASJ,QAFQ;AAGjB,iBAAe,UAASC,KAAT,EAAgB;AAC3B,WAAQ,IAAIU,UAAJ,CAAeV,KAAf,CAAD,CAAwBjB,MAA/B;AACH,GALgB;AAMjB,gBAAc,UAASiB,KAAT,EAAgB;AAC1B,WAAO,IAAIU,UAAJ,CAAeV,KAAf,CAAP;AACH,GARgB;AASjB,gBAAc,UAASA,KAAT,EAAgB;AAC1B,WAAO5B,UAAU,CAAC4B,KAAD,CAAjB;AACH;AAXgB,CAArB,C,CAcA;;AACAuB,SAAS,CAAC,aAAD,CAAT,GAA2B;AACvB,YAAU,UAASvB,KAAT,EAAgB;AACtB,WAAOG,iBAAiB,CAAC,IAAIO,UAAJ,CAAeV,KAAf,CAAD,CAAxB;AACH,GAHsB;AAIvB,WAAS,UAASA,KAAT,EAAgB;AACrB,WAAOoB,oBAAoB,CAAC,IAAIV,UAAJ,CAAeV,KAAf,CAAD,EAAwB,IAAIwB,KAAJ,CAAUxB,KAAK,CAACyB,UAAhB,CAAxB,CAA3B;AACH,GANsB;AAOvB,iBAAe1B,QAPQ;AAQvB,gBAAc,UAASC,KAAT,EAAgB;AAC1B,WAAO,IAAIU,UAAJ,CAAeV,KAAf,CAAP;AACH,GAVsB;AAWvB,gBAAc,UAASA,KAAT,EAAgB;AAC1B,WAAO5B,UAAU,CAAC,IAAIsC,UAAJ,CAAeV,KAAf,CAAD,CAAjB;AACH;AAbsB,CAA3B,C,CAgBA;;AACAuB,SAAS,CAAC,YAAD,CAAT,GAA0B;AACtB,YAAUpB,iBADY;AAEtB,WAAS,UAASH,KAAT,EAAgB;AACrB,WAAOoB,oBAAoB,CAACpB,KAAD,EAAQ,IAAIwB,KAAJ,CAAUxB,KAAK,CAACtB,MAAhB,CAAR,CAA3B;AACH,GAJqB;AAKtB,iBAAe,UAASsB,KAAT,EAAgB;AAC3B,WAAOA,KAAK,CAACjB,MAAb;AACH,GAPqB;AAQtB,gBAAcgB,QARQ;AAStB,gBAAc,UAASC,KAAT,EAAgB;AAC1B,WAAO5B,UAAU,CAAC4B,KAAD,CAAjB;AACH;AAXqB,CAA1B,C,CAcA;;AACAuB,SAAS,CAAC,YAAD,CAAT,GAA0B;AACtB,YAAUpB,iBADY;AAEtB,WAAS,UAASH,KAAT,EAAgB;AACrB,WAAOoB,oBAAoB,CAACpB,KAAD,EAAQ,IAAIwB,KAAJ,CAAUxB,KAAK,CAACtB,MAAhB,CAAR,CAA3B;AACH,GAJqB;AAKtB,iBAAe,UAASsB,KAAT,EAAgB;AAC3B,WAAOuB,SAAS,CAAC,YAAD,CAAT,CAAwB,YAAxB,EAAsCvB,KAAtC,EAA6CjB,MAApD;AACH,GAPqB;AAQtB,gBAAc,UAASiB,KAAT,EAAgB;AAC1B,WAAOoB,oBAAoB,CAACpB,KAAD,EAAQ,IAAIU,UAAJ,CAAeV,KAAK,CAACtB,MAArB,CAAR,CAA3B;AACH,GAVqB;AAWtB,gBAAcqB;AAXQ,CAA1B;AAcA;;;;;;;;;AAQA1B,OAAO,CAACqD,WAAR,GAAsB,UAASC,UAAT,EAAqB3B,KAArB,EAA4B;AAC9C,MAAI,CAACA,KAAL,EAAY;AACR;AACA;AACAA,IAAAA,KAAK,GAAG,EAAR;AACH;;AACD,MAAI,CAAC2B,UAAL,EAAiB;AACb,WAAO3B,KAAP;AACH;;AACD3B,EAAAA,OAAO,CAACY,YAAR,CAAqB0C,UAArB;AACA,MAAIC,SAAS,GAAGvD,OAAO,CAACiC,SAAR,CAAkBN,KAAlB,CAAhB;AACA,MAAIxB,MAAM,GAAG+C,SAAS,CAACK,SAAD,CAAT,CAAqBD,UAArB,EAAiC3B,KAAjC,CAAb;AACA,SAAOxB,MAAP;AACH,CAbD;AAeA;;;;;;;;AAMAH,OAAO,CAACiC,SAAR,GAAoB,UAASN,KAAT,EAAgB;AAChC,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO,QAAP;AACH;;AACD,MAAI6B,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BhC,KAA/B,MAA0C,gBAA9C,EAAgE;AAC5D,WAAO,OAAP;AACH;;AACD,MAAI/B,OAAO,CAACgE,UAAR,IAAsB7D,UAAU,CAAC8D,IAAX,CAAgBlC,KAAhB,CAA1B,EAAkD;AAC9C,WAAO,YAAP;AACH;;AACD,MAAI/B,OAAO,CAACkE,UAAR,IAAsBnC,KAAK,YAAYU,UAA3C,EAAuD;AACnD,WAAO,YAAP;AACH;;AACD,MAAIzC,OAAO,CAACmE,WAAR,IAAuBpC,KAAK,YAAYqC,WAA5C,EAAyD;AACrD,WAAO,aAAP;AACH;AACJ,CAhBD;AAkBA;;;;;;;AAKAhE,OAAO,CAACY,YAAR,GAAuB,UAASE,IAAT,EAAe;AAClC,MAAImD,SAAS,GAAGrE,OAAO,CAACkB,IAAI,CAACoD,WAAL,EAAD,CAAvB;;AACA,MAAI,CAACD,SAAL,EAAgB;AACZ,UAAM,IAAIxC,KAAJ,CAAUX,IAAI,GAAG,mCAAjB,CAAN;AACH;AACJ,CALD;;AAMAd,OAAO,CAACmE,gBAAR,GAA2B,KAA3B;AACAnE,OAAO,CAACoE,gBAAR,GAA2B,CAAC,CAA5B,C,CAA+B;;AAE/B;;;;;;AAKApE,OAAO,CAACqE,MAAR,GAAiB,UAASnE,GAAT,EAAc;AAC3B,MAAIoE,GAAG,GAAG,EAAV;AAAA,MACIC,IADJ;AAAA,MACUnE,CADV;;AAEA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAACF,GAAG,IAAI,EAAR,EAAYG,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrCmE,IAAAA,IAAI,GAAGrE,GAAG,CAACM,UAAJ,CAAeJ,CAAf,CAAP;AACAkE,IAAAA,GAAG,IAAI,SAASC,IAAI,GAAG,EAAP,GAAY,GAAZ,GAAkB,EAA3B,IAAiCA,IAAI,CAACb,QAAL,CAAc,EAAd,EAAkBc,WAAlB,EAAxC;AACH;;AACD,SAAOF,GAAP;AACH,CARD;AAUA;;;;;;;AAKAtE,OAAO,CAACyE,eAAR,GAA0B,UAASC,iBAAT,EAA4B;AAClD,OAAK,IAAIC,MAAT,IAAmB7E,YAAnB,EAAiC;AAC7B,QAAI,CAACA,YAAY,CAAC8E,cAAb,CAA4BD,MAA5B,CAAL,EAA0C;AACtC;AACH;;AACD,QAAI7E,YAAY,CAAC6E,MAAD,CAAZ,CAAqBE,KAArB,KAA+BH,iBAAnC,EAAsD;AAClD,aAAO5E,YAAY,CAAC6E,MAAD,CAAnB;AACH;AACJ;;AACD,SAAO,IAAP;AACH,CAVD;AAWA;;;;;;;;AAMA3E,OAAO,CAAC8E,QAAR,GAAmB,UAAUC,MAAV,EAAkB;AACjC,SAAOvB,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BoB,MAA/B,MAA2C,iBAAlD;AACH,CAFD;AAIA;;;;;;;;AAMA/E,OAAO,CAACgF,MAAR,GAAiB,YAAW;AACxB,MAAI7E,MAAM,GAAG,EAAb;AAAA,MAAiBC,CAAjB;AAAA,MAAoB6E,IAApB;;AACA,OAAK7E,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG8E,SAAS,CAAC7E,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE;AACrC,SAAK6E,IAAL,IAAaC,SAAS,CAAC9E,CAAD,CAAtB,EAA2B;AACvB,UAAI8E,SAAS,CAAC9E,CAAD,CAAT,CAAawE,cAAb,CAA4BK,IAA5B,KAAqC,OAAO9E,MAAM,CAAC8E,IAAD,CAAb,KAAwB,WAAjE,EAA8E;AAC1E9E,QAAAA,MAAM,CAAC8E,IAAD,CAAN,GAAeC,SAAS,CAAC9E,CAAD,CAAT,CAAa6E,IAAb,CAAf;AACH;AACJ;AACJ;;AACD,SAAO9E,MAAP;AACH,CAVD","sourcesContent":["'use strict';\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer, mimeType) {\n    exports.checkSupport(\"blob\");\n\tmimeType = mimeType || 'application/zip';\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: mimeType\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob(mimeType);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n"]},"metadata":{},"sourceType":"script"}