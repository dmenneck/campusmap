{"ast":null,"code":"/**\n * @module ol/renderer/Map\n */\nimport { getUid, inherits } from '../util.js';\nimport Disposable from '../Disposable.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getWidth } from '../extent.js';\nimport { TRUE, UNDEFINED } from '../functions.js';\nimport { visibleAtResolution } from '../layer/Layer.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { compose as composeTransform, invert as invertTransform, setFromArray as transformSetFromArray } from '../transform.js';\n/**\n * @constructor\n * @abstract\n * @extends {module:ol/Disposable}\n * @param {module:ol/PluggableMap} map Map.\n * @struct\n */\n\nconst MapRenderer = function (map) {\n  Disposable.call(this);\n  /**\n   * @private\n   * @type {module:ol/PluggableMap}\n   */\n\n  this.map_ = map;\n  /**\n   * @private\n   * @type {!Object.<string, module:ol/renderer/Layer>}\n   */\n\n  this.layerRenderers_ = {};\n  /**\n   * @private\n   * @type {Object.<string, module:ol/events~EventsKey>}\n   */\n\n  this.layerRendererListeners_ = {};\n  /**\n   * @private\n   * @type {Array.<module:ol/renderer/Layer>}\n   */\n\n  this.layerRendererConstructors_ = [];\n};\n\ninherits(MapRenderer, Disposable);\n/**\n * Register layer renderer constructors.\n * @param {Array.<module:ol/renderer/Layer>} constructors Layer renderers.\n */\n\nMapRenderer.prototype.registerLayerRenderers = function (constructors) {\n  this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);\n};\n/**\n * Get the registered layer renderer constructors.\n * @return {Array.<module:ol/renderer/Layer>} Registered layer renderers.\n */\n\n\nMapRenderer.prototype.getLayerRendererConstructors = function () {\n  return this.layerRendererConstructors_;\n};\n/**\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\n * @protected\n */\n\n\nMapRenderer.prototype.calculateMatrices2D = function (frameState) {\n  const viewState = frameState.viewState;\n  const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n  const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n  composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n  invertTransform(transformSetFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));\n};\n/**\n * Removes all layer renderers.\n */\n\n\nMapRenderer.prototype.removeLayerRenderers = function () {\n  for (const key in this.layerRenderers_) {\n    this.removeLayerRendererByKey_(key).dispose();\n  }\n};\n/**\n * @param {module:ol/PluggableMap} map Map.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n */\n\n\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),\n *     module:ol/layer/Layer): T} callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\n *     function, only layers which are visible and for which this function\n *     returns `true` will be tested for features.  By default, all visible\n *     layers will be tested.\n * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n * @return {T|undefined} Callback result.\n * @template S,T,U\n */\n\n\nMapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n  let result;\n  const viewState = frameState.viewState;\n  const viewResolution = viewState.resolution;\n  /**\n   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.\n   * @param {module:ol/layer/Layer} layer Layer.\n   * @return {?} Callback result.\n   */\n\n  function forEachFeatureAtCoordinate(feature, layer) {\n    const key = getUid(feature).toString();\n    const managed = frameState.layerStates[getUid(layer)].managed;\n\n    if (!(key in frameState.skippedFeatureUids && !managed)) {\n      return callback.call(thisArg, feature, managed ? layer : null);\n    }\n  }\n\n  const projection = viewState.projection;\n  let translatedCoordinate = coordinate;\n\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    const x = coordinate[0];\n\n    if (x < projectionExtent[0] || x > projectionExtent[2]) {\n      const worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);\n      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];\n    }\n  }\n\n  const layerStates = frameState.layerStatesArray;\n  const numLayers = layerStates.length;\n  let i;\n\n  for (i = numLayers - 1; i >= 0; --i) {\n    const layerState = layerStates[i];\n    const layer = layerState.layer;\n\n    if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n      const layerRenderer = this.getLayerRenderer(layer);\n\n      if (layer.getSource()) {\n        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);\n      }\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  return undefined;\n};\n/**\n * @abstract\n * @param {module:ol~Pixel} pixel Pixel.\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n *     callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\n *     function, only layers which are visible and for which this function\n *     returns `true` will be tested for features.  By default, all visible\n *     layers will be tested.\n * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n * @return {T|undefined} Callback result.\n * @template S,T,U\n */\n\n\nMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {};\n/**\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {module:ol/PluggableMap~FrameState} frameState FrameState.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter\n *     function, only layers which are visible and for which this function\n *     returns `true` will be tested for features.  By default, all visible\n *     layers will be tested.\n * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n * @return {boolean} Is there a feature at the given coordinate?\n * @template U\n */\n\n\nMapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n  const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, TRUE, this, layerFilter, thisArg);\n  return hasFeature !== undefined;\n};\n/**\n * @param {module:ol/layer/Layer} layer Layer.\n * @protected\n * @return {module:ol/renderer/Layer} Layer renderer.\n */\n\n\nMapRenderer.prototype.getLayerRenderer = function (layer) {\n  const layerKey = getUid(layer).toString();\n\n  if (layerKey in this.layerRenderers_) {\n    return this.layerRenderers_[layerKey];\n  } else {\n    let renderer;\n\n    for (let i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {\n      const candidate = this.layerRendererConstructors_[i];\n\n      if (candidate['handles'](layer)) {\n        renderer = candidate['create'](this, layer);\n        break;\n      }\n    }\n\n    if (renderer) {\n      this.layerRenderers_[layerKey] = renderer;\n      this.layerRendererListeners_[layerKey] = listen(renderer, EventType.CHANGE, this.handleLayerRendererChange_, this);\n    } else {\n      throw new Error('Unable to create renderer for layer: ' + layer.getType());\n    }\n\n    return renderer;\n  }\n};\n/**\n * @param {string} layerKey Layer key.\n * @protected\n * @return {module:ol/renderer/Layer} Layer renderer.\n */\n\n\nMapRenderer.prototype.getLayerRendererByKey = function (layerKey) {\n  return this.layerRenderers_[layerKey];\n};\n/**\n * @protected\n * @return {Object.<string, module:ol/renderer/Layer>} Layer renderers.\n */\n\n\nMapRenderer.prototype.getLayerRenderers = function () {\n  return this.layerRenderers_;\n};\n/**\n * @return {module:ol/PluggableMap} Map.\n */\n\n\nMapRenderer.prototype.getMap = function () {\n  return this.map_;\n};\n/**\n * Handle changes in a layer renderer.\n * @private\n */\n\n\nMapRenderer.prototype.handleLayerRendererChange_ = function () {\n  this.map_.render();\n};\n/**\n * @param {string} layerKey Layer key.\n * @return {module:ol/renderer/Layer} Layer renderer.\n * @private\n */\n\n\nMapRenderer.prototype.removeLayerRendererByKey_ = function (layerKey) {\n  const layerRenderer = this.layerRenderers_[layerKey];\n  delete this.layerRenderers_[layerKey];\n  unlistenByKey(this.layerRendererListeners_[layerKey]);\n  delete this.layerRendererListeners_[layerKey];\n  return layerRenderer;\n};\n/**\n * Render.\n * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.\n */\n\n\nMapRenderer.prototype.renderFrame = UNDEFINED;\n/**\n * @param {module:ol/PluggableMap} map Map.\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @private\n */\n\nMapRenderer.prototype.removeUnusedLayerRenderers_ = function (map, frameState) {\n  for (const layerKey in this.layerRenderers_) {\n    if (!frameState || !(layerKey in frameState.layerStates)) {\n      this.removeLayerRendererByKey_(layerKey).dispose();\n    }\n  }\n};\n/**\n * @param {module:ol/PluggableMap~FrameState} frameState Frame state.\n * @protected\n */\n\n\nMapRenderer.prototype.scheduleExpireIconCache = function (frameState) {\n  frameState.postRenderFunctions.push(\n  /** @type {module:ol/PluggableMap~PostRenderFunction} */\n  expireIconCache);\n};\n/**\n * @param {!module:ol/PluggableMap~FrameState} frameState Frame state.\n * @protected\n */\n\n\nMapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function (frameState) {\n  for (const layerKey in this.layerRenderers_) {\n    if (!(layerKey in frameState.layerStates)) {\n      frameState.postRenderFunctions.push(\n      /** @type {module:ol/PluggableMap~PostRenderFunction} */\n      this.removeUnusedLayerRenderers_.bind(this));\n      return;\n    }\n  }\n};\n/**\n * @param {module:ol/layer/Layer~State} state1 First layer state.\n * @param {module:ol/layer/Layer~State} state2 Second layer state.\n * @return {number} The zIndex difference.\n */\n\n\nexport function sortByZIndex(state1, state2) {\n  return state1.zIndex - state2.zIndex;\n}\nexport default MapRenderer;","map":null,"metadata":{},"sourceType":"module"}