{"ast":null,"code":"/**\n * @module ol/VectorImageTile\n */\nimport { getUid } from './util.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { getHeight, getIntersection, getWidth } from './extent.js';\nimport EventType from './events/EventType.js';\nimport { loadFeaturesXhr } from './featureloader.js';\nimport { VOID } from './functions.js';\n/**\n * @typedef {Object} ReplayState\n * @property {boolean} dirty\n * @property {null|import(\"./render.js\").OrderFunction} renderedRenderOrder\n * @property {number} renderedTileRevision\n * @property {number} renderedRevision\n */\n\nvar VectorImageTile =\n/*@__PURE__*/\nfunction (Tile) {\n  function VectorImageTile(tileCoord, state, sourceRevision, format, tileLoadFunction, urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection, tileClass, handleTileChange, zoom) {\n    Tile.call(this, tileCoord, state, {\n      transition: 0\n    });\n    /**\n     * @private\n     * @type {!Object<string, CanvasRenderingContext2D>}\n     */\n\n    this.context_ = {};\n    /**\n     * @private\n     * @type {import(\"./featureloader.js\").FeatureLoader}\n     */\n\n    this.loader_;\n    /**\n     * @private\n     * @type {!Object<string, ReplayState>}\n     */\n\n    this.replayState_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"./VectorTile.js\").default>}\n     */\n\n    this.sourceTiles_ = sourceTiles;\n    /**\n     * Keys of source tiles used by this tile. Use with {@link #getTile}.\n     * @type {Array<string>}\n     */\n\n    this.tileKeys = [];\n    /**\n     * @type {import(\"./extent.js\").Extent}\n     */\n\n    this.extent = null;\n    /**\n     * @type {number}\n     */\n\n    this.sourceRevision_ = sourceRevision;\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n\n    this.wrappedTileCoord = urlTileCoord;\n    /**\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n\n    this.loadListenerKeys_ = [];\n    /**\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n\n    this.sourceTileListenerKeys_ = [];\n\n    if (urlTileCoord) {\n      var extent = this.extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      var resolution = tileGrid.getResolution(zoom);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution);\n      var useLoadedOnly = zoom != tileCoord[0];\n      var loadCount = 0;\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        var sharedExtent = getIntersection(extent, sourceTileGrid.getTileCoordExtent(sourceTileCoord));\n        var sourceExtent = sourceTileGrid.getExtent();\n\n        if (sourceExtent) {\n          sharedExtent = getIntersection(sharedExtent, sourceExtent, sharedExtent);\n        }\n\n        if (getWidth(sharedExtent) / resolution >= 0.5 && getHeight(sharedExtent) / resolution >= 0.5) {\n          // only include source tile if overlap is at least 1 pixel\n          ++loadCount;\n          var sourceTileKey = sourceTileCoord.toString();\n          var sourceTile = sourceTiles[sourceTileKey];\n\n          if (!sourceTile && !useLoadedOnly) {\n            var tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord, tileUrl == undefined ? TileState.EMPTY : TileState.IDLE, tileUrl == undefined ? '' : tileUrl, format, tileLoadFunction);\n            this.sourceTileListenerKeys_.push(listen(sourceTile, EventType.CHANGE, handleTileChange));\n          }\n\n          if (sourceTile && (!useLoadedOnly || sourceTile.getState() == TileState.LOADED)) {\n            sourceTile.consumers++;\n            this.tileKeys.push(sourceTileKey);\n          }\n        }\n      }.bind(this));\n\n      if (useLoadedOnly && loadCount == this.tileKeys.length) {\n        this.finishLoading_();\n      }\n\n      if (zoom <= tileCoord[0] && this.state != TileState.LOADED) {\n        while (zoom > tileGrid.getMinZoom()) {\n          var tile = new VectorImageTile(tileCoord, state, sourceRevision, format, tileLoadFunction, urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection, tileClass, VOID, --zoom);\n\n          if (tile.state == TileState.LOADED) {\n            this.interimTile = tile;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (Tile) VectorImageTile.__proto__ = Tile;\n  VectorImageTile.prototype = Object.create(Tile && Tile.prototype);\n  VectorImageTile.prototype.constructor = VectorImageTile;\n  /**\n   * @inheritDoc\n   */\n\n  VectorImageTile.prototype.disposeInternal = function disposeInternal() {\n    this.state = TileState.ABORT;\n    this.changed();\n\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n\n    for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {\n      var sourceTileKey = this.tileKeys[i];\n      var sourceTile = this.getTile(sourceTileKey);\n      sourceTile.consumers--;\n\n      if (sourceTile.consumers == 0) {\n        delete this.sourceTiles_[sourceTileKey];\n        sourceTile.dispose();\n      }\n    }\n\n    this.tileKeys.length = 0;\n    this.sourceTiles_ = null;\n    this.loadListenerKeys_.forEach(unlistenByKey);\n    this.loadListenerKeys_.length = 0;\n    this.sourceTileListenerKeys_.forEach(unlistenByKey);\n    this.sourceTileListenerKeys_.length = 0;\n    Tile.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {CanvasRenderingContext2D} The rendering context.\n   */\n\n\n  VectorImageTile.prototype.getContext = function getContext(layer) {\n    var key = getUid(layer);\n\n    if (!(key in this.context_)) {\n      this.context_[key] = createCanvasContext2D();\n    }\n\n    return this.context_[key];\n  };\n  /**\n   * Get the Canvas for this tile.\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  VectorImageTile.prototype.getImage = function getImage(layer) {\n    return this.getReplayState(layer).renderedTileRevision == -1 ? null : this.getContext(layer).canvas;\n  };\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {ReplayState} The replay state.\n   */\n\n\n  VectorImageTile.prototype.getReplayState = function getReplayState(layer) {\n    var key = getUid(layer);\n\n    if (!(key in this.replayState_)) {\n      this.replayState_[key] = {\n        dirty: false,\n        renderedRenderOrder: null,\n        renderedRevision: -1,\n        renderedTileRevision: -1\n      };\n    }\n\n    return this.replayState_[key];\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorImageTile.prototype.getKey = function getKey() {\n    return this.tileKeys.join('/') + '-' + this.sourceRevision_;\n  };\n  /**\n   * @param {string} tileKey Key (tileCoord) of the source tile.\n   * @return {import(\"./VectorTile.js\").default} Source tile.\n   */\n\n\n  VectorImageTile.prototype.getTile = function getTile(tileKey) {\n    return this.sourceTiles_[tileKey];\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  VectorImageTile.prototype.load = function load() {\n    // Source tiles with LOADED state - we just count them because once they are\n    // loaded, we're no longer listening to state changes.\n    var leftToLoad = 0; // Source tiles with ERROR state - we track them because they can still have\n    // an ERROR state after another load attempt.\n\n    var errorSourceTiles = {};\n\n    if (this.state == TileState.IDLE) {\n      this.setState(TileState.LOADING);\n    }\n\n    if (this.state == TileState.LOADING) {\n      this.tileKeys.forEach(function (sourceTileKey) {\n        var sourceTile = this.getTile(sourceTileKey);\n\n        if (sourceTile.state == TileState.IDLE) {\n          sourceTile.setLoader(this.loader_);\n          sourceTile.load();\n        }\n\n        if (sourceTile.state == TileState.LOADING) {\n          var key = listen(sourceTile, EventType.CHANGE, function (e) {\n            var state = sourceTile.getState();\n\n            if (state == TileState.LOADED || state == TileState.ERROR) {\n              var uid = getUid(sourceTile);\n\n              if (state == TileState.ERROR) {\n                errorSourceTiles[uid] = true;\n              } else {\n                --leftToLoad;\n                delete errorSourceTiles[uid];\n              }\n\n              if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n                this.finishLoading_();\n              }\n            }\n          }.bind(this));\n          this.loadListenerKeys_.push(key);\n          ++leftToLoad;\n        }\n      }.bind(this));\n    }\n\n    if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n      setTimeout(this.finishLoading_.bind(this), 0);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  VectorImageTile.prototype.finishLoading_ = function finishLoading_() {\n    var loaded = this.tileKeys.length;\n    var empty = 0;\n\n    for (var i = loaded - 1; i >= 0; --i) {\n      var state = this.getTile(this.tileKeys[i]).getState();\n\n      if (state != TileState.LOADED) {\n        --loaded;\n      }\n\n      if (state == TileState.EMPTY) {\n        ++empty;\n      }\n    }\n\n    if (loaded == this.tileKeys.length) {\n      this.loadListenerKeys_.forEach(unlistenByKey);\n      this.loadListenerKeys_.length = 0;\n      this.setState(TileState.LOADED);\n    } else {\n      this.setState(empty == this.tileKeys.length ? TileState.EMPTY : TileState.ERROR);\n    }\n  };\n\n  return VectorImageTile;\n}(Tile);\n\nexport default VectorImageTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"./VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  var loader = loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}","map":{"version":3,"sources":["../../src/ol/VectorImageTile.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/VectorImageTile\n */\nimport {getUid} from './util.js';\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {getHeight, getIntersection, getWidth} from './extent.js';\nimport EventType from './events/EventType.js';\nimport {loadFeaturesXhr} from './featureloader.js';\nimport {VOID} from './functions.js';\n\n\n/**\n * @typedef {Object} ReplayState\n * @property {boolean} dirty\n * @property {null|import(\"./render.js\").OrderFunction} renderedRenderOrder\n * @property {number} renderedTileRevision\n * @property {number} renderedRevision\n */\n\n\nclass VectorImageTile extends Tile {\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {TileState} state State.\n   * @param {number} sourceRevision Source revision.\n   * @param {import(\"./format/Feature.js\").default} format Feature format.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./tilecoord.js\").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.\n   * @param {import(\"./Tile.js\").UrlFunction} tileUrlFunction Tile url function.\n   * @param {import(\"./tilegrid/TileGrid.js\").default} sourceTileGrid Tile grid of the source.\n   * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid of the renderer.\n   * @param {Object<string, import(\"./VectorTile.js\").default>} sourceTiles Source tiles.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {typeof import(\"./VectorTile.js\").default} tileClass Class to\n   *     instantiate for source tiles.\n   * @param {function(this: import(\"./source/VectorTile.js\").default, import(\"./events/Event.js\").default)} handleTileChange\n   *     Function to call when a source tile's state changes.\n   * @param {number} zoom Integer zoom to render the tile for.\n   */\n  constructor(tileCoord, state, sourceRevision, format, tileLoadFunction,\n    urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles,\n    pixelRatio, projection, tileClass, handleTileChange, zoom) {\n\n    super(tileCoord, state, {transition: 0});\n\n    /**\n     * @private\n     * @type {!Object<string, CanvasRenderingContext2D>}\n     */\n    this.context_ = {};\n\n    /**\n     * @private\n     * @type {import(\"./featureloader.js\").FeatureLoader}\n     */\n    this.loader_;\n\n    /**\n     * @private\n     * @type {!Object<string, ReplayState>}\n     */\n    this.replayState_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, import(\"./VectorTile.js\").default>}\n     */\n    this.sourceTiles_ = sourceTiles;\n\n    /**\n     * Keys of source tiles used by this tile. Use with {@link #getTile}.\n     * @type {Array<string>}\n     */\n    this.tileKeys = [];\n\n    /**\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = null;\n\n    /**\n     * @type {number}\n     */\n    this.sourceRevision_ = sourceRevision;\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord = urlTileCoord;\n\n    /**\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.loadListenerKeys_ = [];\n\n    /**\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.sourceTileListenerKeys_ = [];\n\n    if (urlTileCoord) {\n      const extent = this.extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const resolution = tileGrid.getResolution(zoom);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution);\n      const useLoadedOnly = zoom != tileCoord[0];\n      let loadCount = 0;\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {\n        let sharedExtent = getIntersection(extent,\n          sourceTileGrid.getTileCoordExtent(sourceTileCoord));\n        const sourceExtent = sourceTileGrid.getExtent();\n        if (sourceExtent) {\n          sharedExtent = getIntersection(sharedExtent, sourceExtent, sharedExtent);\n        }\n        if (getWidth(sharedExtent) / resolution >= 0.5 &&\n            getHeight(sharedExtent) / resolution >= 0.5) {\n          // only include source tile if overlap is at least 1 pixel\n          ++loadCount;\n          const sourceTileKey = sourceTileCoord.toString();\n          let sourceTile = sourceTiles[sourceTileKey];\n          if (!sourceTile && !useLoadedOnly) {\n            const tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord,\n              tileUrl == undefined ? TileState.EMPTY : TileState.IDLE,\n              tileUrl == undefined ? '' : tileUrl,\n              format, tileLoadFunction);\n            this.sourceTileListenerKeys_.push(\n              listen(sourceTile, EventType.CHANGE, handleTileChange));\n          }\n          if (sourceTile && (!useLoadedOnly || sourceTile.getState() == TileState.LOADED)) {\n            sourceTile.consumers++;\n            this.tileKeys.push(sourceTileKey);\n          }\n        }\n      }.bind(this));\n\n      if (useLoadedOnly && loadCount == this.tileKeys.length) {\n        this.finishLoading_();\n      }\n\n      if (zoom <= tileCoord[0] && this.state != TileState.LOADED) {\n        while (zoom > tileGrid.getMinZoom()) {\n          const tile = new VectorImageTile(tileCoord, state, sourceRevision,\n            format, tileLoadFunction, urlTileCoord, tileUrlFunction,\n            sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection,\n            tileClass, VOID, --zoom);\n          if (tile.state == TileState.LOADED) {\n            this.interimTile = tile;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    this.state = TileState.ABORT;\n    this.changed();\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n\n    for (let i = 0, ii = this.tileKeys.length; i < ii; ++i) {\n      const sourceTileKey = this.tileKeys[i];\n      const sourceTile = this.getTile(sourceTileKey);\n      sourceTile.consumers--;\n      if (sourceTile.consumers == 0) {\n        delete this.sourceTiles_[sourceTileKey];\n        sourceTile.dispose();\n      }\n    }\n    this.tileKeys.length = 0;\n    this.sourceTiles_ = null;\n    this.loadListenerKeys_.forEach(unlistenByKey);\n    this.loadListenerKeys_.length = 0;\n    this.sourceTileListenerKeys_.forEach(unlistenByKey);\n    this.sourceTileListenerKeys_.length = 0;\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {CanvasRenderingContext2D} The rendering context.\n   */\n  getContext(layer) {\n    const key = getUid(layer);\n    if (!(key in this.context_)) {\n      this.context_[key] = createCanvasContext2D();\n    }\n    return this.context_[key];\n  }\n\n  /**\n   * Get the Canvas for this tile.\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage(layer) {\n    return this.getReplayState(layer).renderedTileRevision == -1 ?\n      null : this.getContext(layer).canvas;\n  }\n\n  /**\n   * @param {import(\"./layer/Layer.js\").default} layer Layer.\n   * @return {ReplayState} The replay state.\n   */\n  getReplayState(layer) {\n    const key = getUid(layer);\n    if (!(key in this.replayState_)) {\n      this.replayState_[key] = {\n        dirty: false,\n        renderedRenderOrder: null,\n        renderedRevision: -1,\n        renderedTileRevision: -1\n      };\n    }\n    return this.replayState_[key];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getKey() {\n    return this.tileKeys.join('/') + '-' + this.sourceRevision_;\n  }\n\n  /**\n   * @param {string} tileKey Key (tileCoord) of the source tile.\n   * @return {import(\"./VectorTile.js\").default} Source tile.\n   */\n  getTile(tileKey) {\n    return this.sourceTiles_[tileKey];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {\n    // Source tiles with LOADED state - we just count them because once they are\n    // loaded, we're no longer listening to state changes.\n    let leftToLoad = 0;\n    // Source tiles with ERROR state - we track them because they can still have\n    // an ERROR state after another load attempt.\n    const errorSourceTiles = {};\n\n    if (this.state == TileState.IDLE) {\n      this.setState(TileState.LOADING);\n    }\n    if (this.state == TileState.LOADING) {\n      this.tileKeys.forEach(function(sourceTileKey) {\n        const sourceTile = this.getTile(sourceTileKey);\n        if (sourceTile.state == TileState.IDLE) {\n          sourceTile.setLoader(this.loader_);\n          sourceTile.load();\n        }\n        if (sourceTile.state == TileState.LOADING) {\n          const key = listen(sourceTile, EventType.CHANGE, function(e) {\n            const state = sourceTile.getState();\n            if (state == TileState.LOADED ||\n                state == TileState.ERROR) {\n              const uid = getUid(sourceTile);\n              if (state == TileState.ERROR) {\n                errorSourceTiles[uid] = true;\n              } else {\n                --leftToLoad;\n                delete errorSourceTiles[uid];\n              }\n              if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n                this.finishLoading_();\n              }\n            }\n          }.bind(this));\n          this.loadListenerKeys_.push(key);\n          ++leftToLoad;\n        }\n      }.bind(this));\n    }\n    if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {\n      setTimeout(this.finishLoading_.bind(this), 0);\n    }\n  }\n\n  /**\n   * @private\n   */\n  finishLoading_() {\n    let loaded = this.tileKeys.length;\n    let empty = 0;\n    for (let i = loaded - 1; i >= 0; --i) {\n      const state = this.getTile(this.tileKeys[i]).getState();\n      if (state != TileState.LOADED) {\n        --loaded;\n      }\n      if (state == TileState.EMPTY) {\n        ++empty;\n      }\n    }\n    if (loaded == this.tileKeys.length) {\n      this.loadListenerKeys_.forEach(unlistenByKey);\n      this.loadListenerKeys_.length = 0;\n      this.setState(TileState.LOADED);\n    } else {\n      this.setState(empty == this.tileKeys.length ? TileState.EMPTY : TileState.ERROR);\n    }\n  }\n}\n\n\nexport default VectorImageTile;\n\n/**\n * Sets the loader for a tile.\n * @param {import(\"./VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  const loader = loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}\n"]},"metadata":{},"sourceType":"module"}