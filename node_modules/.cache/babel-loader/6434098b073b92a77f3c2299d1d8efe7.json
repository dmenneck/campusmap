{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar logger_1 = require(\"../logger\");\n\nvar columnUtils_1 = require(\"./columnUtils\");\n\nvar columnKeyCreator_1 = require(\"./columnKeyCreator\");\n\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar context_1 = require(\"../context/context\");\n\nvar defaultColumnTypes_1 = require(\"../entities/defaultColumnTypes\");\n\nvar utils_1 = require(\"../utils\"); // takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n\n\nvar ColumnFactory =\n/** @class */\nfunction () {\n  function ColumnFactory() {}\n\n  ColumnFactory.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ColumnFactory');\n  };\n\n  ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingColumns) {\n    // column key creator dishes out unique column id's in a deterministic way,\n    // so if we have two grids (that could be master/slave) with same column definitions,\n    // then this ensures the two grids use identical id's.\n    var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();\n\n    if (existingColumns) {\n      var existingKeys = existingColumns.map(function (col) {\n        return col.getId();\n      });\n      columnKeyCreator.addExistingKeys(existingKeys);\n    } // we take a copy of the columns as we are going to be removing from them\n\n\n    var existingColsCopy = existingColumns ? existingColumns.slice() : null; // create am unbalanced tree that maps the provided definitions\n\n    var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingColsCopy, columnKeyCreator, null);\n    var treeDept = this.findMaxDept(unbalancedTree, 0);\n    this.logger.log('Number of levels for grouped columns is ' + treeDept);\n    var res = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n    var deptFirstCallback = function (child, parent) {\n      if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        child.setupExpandable();\n      } // we set the original parents at the end, rather than when we go along, as balancing the tree\n      // adds extra levels into the tree. so we can only set parents when balancing is done.\n\n\n      child.setOriginalParent(parent);\n    };\n\n    this.columnUtils.depthFirstOriginalTreeSearch(null, res, deptFirstCallback);\n    return {\n      columnTree: res,\n      treeDept: treeDept\n    };\n  };\n\n  ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n    var _this = this;\n\n    var autoColBalancedTree = [];\n    autoGroupCols.forEach(function (col) {\n      var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n\n      autoColBalancedTree.push(fakeTreeItem);\n    });\n    return autoColBalancedTree;\n  };\n\n  ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n    var dept = this.findDepth(balancedColumnTree); // at the end, this will be the top of the tree item.\n\n    var nextChild = column;\n\n    for (var i = dept - 1; i >= 0; i--) {\n      var autoGroup = new originalColumnGroup_1.OriginalColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n      this.context.wireBean(autoGroup);\n      autoGroup.setChildren([nextChild]);\n      nextChild.setOriginalParent(autoGroup);\n      nextChild = autoGroup;\n    } // at this point, the nextChild is the top most item in the tree\n\n\n    return nextChild;\n  };\n\n  ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n    var dept = 0;\n    var pointer = balancedColumnTree;\n\n    while (pointer && pointer[0] && pointer[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {\n      dept++;\n      pointer = pointer[0].getChildren();\n    }\n\n    return dept;\n  };\n\n  ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n    var result = []; // go through each child, for groups, recurse a level deeper,\n    // for columns we need to pad\n\n    for (var i = 0; i < unbalancedTree.length; i++) {\n      var child = unbalancedTree[i];\n\n      if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        // child is a group, all we do is go to the next level of recursion\n        var originalGroup = child;\n        var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n        originalGroup.setChildren(newChildren);\n        result.push(originalGroup);\n      } else {\n        // child is a column - so here we add in the padded column groups if needed\n        var firstPaddedGroup = void 0;\n        var currentPaddedGroup = void 0; // this for loop will NOT run any loops if no padded column groups are needed\n\n        for (var j = columnDept - 1; j >= currentDept; j--) {\n          var newColId = columnKeyCreator.getUniqueKey(null, null);\n          var colGroupDefMerged = this.createMergedColGroupDef(null);\n          var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n          this.context.wireBean(paddedGroup);\n\n          if (currentPaddedGroup) {\n            currentPaddedGroup.setChildren([paddedGroup]);\n          }\n\n          currentPaddedGroup = paddedGroup;\n\n          if (!firstPaddedGroup) {\n            firstPaddedGroup = currentPaddedGroup;\n          }\n        } // likewise this if statement will not run if no padded groups\n\n\n        if (firstPaddedGroup) {\n          result.push(firstPaddedGroup);\n          var hasGroups = unbalancedTree.some(function (child) {\n            return child instanceof originalColumnGroup_1.OriginalColumnGroup;\n          });\n\n          if (hasGroups) {\n            currentPaddedGroup.setChildren([child]);\n            continue;\n          } else {\n            currentPaddedGroup.setChildren(unbalancedTree);\n            break;\n          }\n        }\n\n        result.push(child);\n      }\n    }\n\n    return result;\n  };\n\n  ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n    var maxDeptThisLevel = dept;\n\n    for (var i = 0; i < treeChildren.length; i++) {\n      var abstractColumn = treeChildren[i];\n\n      if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        var originalGroup = abstractColumn;\n        var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n\n        if (maxDeptThisLevel < newDept) {\n          maxDeptThisLevel = newDept;\n        }\n      }\n    }\n\n    return maxDeptThisLevel;\n  };\n\n  ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, parent) {\n    var _this = this;\n\n    var result = [];\n\n    if (!defs) {\n      return result;\n    }\n\n    defs.forEach(function (def) {\n      var newGroupOrColumn;\n\n      if (_this.isColumnGroup(def)) {\n        newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, parent);\n      } else {\n        newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator, parent);\n      }\n\n      result.push(newGroupOrColumn);\n    });\n    return result;\n  };\n\n  ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, parent) {\n    var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n    var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n    var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n    this.context.wireBean(originalGroup);\n    var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n    originalGroup.setChildren(children);\n    return originalGroup;\n  };\n\n  ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n    var colGroupDefMerged = {};\n\n    utils_1._.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n\n    utils_1._.assign(colGroupDefMerged, colGroupDef);\n\n    this.checkForDeprecatedItems(colGroupDefMerged);\n    return colGroupDefMerged;\n  };\n\n  ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator, parent) {\n    var colDefMerged = this.mergeColDefs(colDef);\n    this.checkForDeprecatedItems(colDefMerged); // see if column already exists\n\n    var column = this.findExistingColumn(colDef, existingColsCopy);\n\n    if (!column) {\n      // no existing column, need to create one\n      var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n      column = new column_1.Column(colDefMerged, colDef, colId, primaryColumns);\n      this.context.wireBean(column);\n    } else {\n      column.setColDef(colDefMerged, colDef);\n    }\n\n    return column;\n  };\n\n  ColumnFactory.prototype.findExistingColumn = function (colDef, existingColsCopy) {\n    var res = utils_1._.find(existingColsCopy, function (col) {\n      var oldColDef = col.getUserProvidedColDef();\n\n      if (!oldColDef) {\n        return false;\n      } // first check object references\n\n\n      if (oldColDef === colDef) {\n        return true;\n      } // second check id's\n\n\n      var oldColHadId = oldColDef.colId !== null && oldColDef.colId !== undefined;\n\n      if (oldColHadId) {\n        return oldColDef.colId === colDef.colId;\n      } else {\n        return false;\n      }\n    }); // make sure we remove, so if user provided duplicate id, then we don't have more than\n    // one column instance for colDef with common id\n\n\n    if (res) {\n      utils_1._.removeFromArray(existingColsCopy, res);\n    }\n\n    return res;\n  };\n\n  ColumnFactory.prototype.mergeColDefs = function (colDef) {\n    // start with empty merged definition\n    var colDefMerged = {}; // merge properties from default column definitions\n\n    utils_1._.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef()); // merge properties from column type properties\n\n\n    if (colDef.type) {\n      this.assignColumnTypes(colDef, colDefMerged);\n    } // merge properties from column definitions\n\n\n    utils_1._.assign(colDefMerged, colDef);\n\n    return colDefMerged;\n  };\n\n  ColumnFactory.prototype.assignColumnTypes = function (colDef, colDefMerged) {\n    var typeKeys;\n\n    if (colDef.type instanceof Array) {\n      var invalidArray = colDef.type.some(function (a) {\n        return typeof a !== 'string';\n      });\n\n      if (invalidArray) {\n        console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n      } else {\n        typeKeys = colDef.type;\n      }\n    } else if (typeof colDef.type === 'string') {\n      typeKeys = colDef.type.split(',');\n    } else {\n      console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n      return;\n    } // merge user defined with default column types\n\n\n    var allColumnTypes = utils_1._.assign({}, this.gridOptionsWrapper.getColumnTypes(), defaultColumnTypes_1.DefaultColumnTypes);\n\n    typeKeys.forEach(function (t) {\n      var typeColDef = allColumnTypes[t.trim()];\n\n      if (typeColDef) {\n        utils_1._.assign(colDefMerged, typeColDef);\n      } else {\n        console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n      }\n    });\n  };\n\n  ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n    if (colDef) {\n      var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n\n      if (colDefNoType.group !== undefined) {\n        console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroup !== undefined) {\n        console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroupShow !== undefined) {\n        console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.suppressRowGroup !== undefined) {\n        console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressAggregation !== undefined) {\n        console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n        console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n      }\n\n      if (colDefNoType.displayName) {\n        console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n        colDefNoType.headerName = colDefNoType.displayName;\n      }\n    }\n  }; // if object has children, we assume it's a group\n\n\n  ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n    return abstractColDef.children !== undefined;\n  };\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], ColumnFactory.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('columnUtils'), __metadata(\"design:type\", columnUtils_1.ColumnUtils)], ColumnFactory.prototype, \"columnUtils\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], ColumnFactory.prototype, \"context\", void 0);\n\n  __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], ColumnFactory.prototype, \"setBeans\", null);\n\n  ColumnFactory = __decorate([context_1.Bean('columnFactory')], ColumnFactory);\n  return ColumnFactory;\n}();\n\nexports.ColumnFactory = ColumnFactory;","map":{"version":3,"sources":["/Users/dirkmennecke77/Desktop/Lageplan/node_modules/ag-grid-community/dist/lib/columnController/columnFactory.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","__param","paramIndex","decorator","exports","value","gridOptionsWrapper_1","require","logger_1","columnUtils_1","columnKeyCreator_1","originalColumnGroup_1","column_1","context_1","defaultColumnTypes_1","utils_1","ColumnFactory","prototype","setBeans","loggerFactory","logger","create","createColumnTree","defs","primaryColumns","existingColumns","columnKeyCreator","ColumnKeyCreator","existingKeys","map","col","getId","addExistingKeys","existingColsCopy","slice","unbalancedTree","recursivelyCreateColumns","treeDept","findMaxDept","log","res","balanceColumnTree","deptFirstCallback","child","parent","OriginalColumnGroup","setupExpandable","setOriginalParent","columnUtils","depthFirstOriginalTreeSearch","columnTree","createForAutoGroups","autoGroupCols","gridBalancedTree","_this","autoColBalancedTree","forEach","fakeTreeItem","createAutoGroupTreeItem","push","balancedColumnTree","column","dept","findDepth","nextChild","autoGroup","context","wireBean","setChildren","pointer","getChildren","currentDept","columnDept","result","originalGroup","newChildren","firstPaddedGroup","currentPaddedGroup","j","newColId","getUniqueKey","colGroupDefMerged","createMergedColGroupDef","paddedGroup","hasGroups","some","treeChildren","maxDeptThisLevel","abstractColumn","newDept","level","def","newGroupOrColumn","isColumnGroup","createColumnGroup","createColumn","colGroupDef","groupId","children","_","assign","gridOptionsWrapper","getDefaultColGroupDef","checkForDeprecatedItems","colDef","colDefMerged","mergeColDefs","findExistingColumn","colId","field","Column","setColDef","find","oldColDef","getUserProvidedColDef","oldColHadId","undefined","removeFromArray","getDefaultColDef","type","assignColumnTypes","typeKeys","Array","invalidArray","a","console","warn","split","allColumnTypes","getColumnTypes","DefaultColumnTypes","t","typeColDef","trim","colDefNoType","group","headerGroup","headerGroupShow","suppressRowGroup","suppressAggregation","displayName","headerName","abstractColDef","Autowired","GridOptionsWrapper","ColumnUtils","Context","Qualifier","Function","LoggerFactory","Bean"],"mappings":"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","sourcesContent":["/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.2.2\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\nvar logger_1 = require(\"../logger\");\nvar columnUtils_1 = require(\"./columnUtils\");\nvar columnKeyCreator_1 = require(\"./columnKeyCreator\");\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\nvar column_1 = require(\"../entities/column\");\nvar context_1 = require(\"../context/context\");\nvar defaultColumnTypes_1 = require(\"../entities/defaultColumnTypes\");\nvar utils_1 = require(\"../utils\");\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\nvar ColumnFactory = /** @class */ (function () {\n    function ColumnFactory() {\n    }\n    ColumnFactory.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    };\n    ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingColumns) {\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();\n        if (existingColumns) {\n            var existingKeys = existingColumns.map(function (col) { return col.getId(); });\n            columnKeyCreator.addExistingKeys(existingKeys);\n        }\n        // we take a copy of the columns as we are going to be removing from them\n        var existingColsCopy = existingColumns ? existingColumns.slice() : null;\n        // create am unbalanced tree that maps the provided definitions\n        var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingColsCopy, columnKeyCreator, null);\n        var treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        var res = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n        var deptFirstCallback = function (child, parent) {\n            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n        this.columnUtils.depthFirstOriginalTreeSearch(null, res, deptFirstCallback);\n        return {\n            columnTree: res,\n            treeDept: treeDept\n        };\n    };\n    ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n        var _this = this;\n        var autoColBalancedTree = [];\n        autoGroupCols.forEach(function (col) {\n            var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n        return autoColBalancedTree;\n    };\n    ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n        var dept = this.findDepth(balancedColumnTree);\n        // at the end, this will be the top of the tree item.\n        var nextChild = column;\n        for (var i = dept - 1; i >= 0; i--) {\n            var autoGroup = new originalColumnGroup_1.OriginalColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n            this.context.wireBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    };\n    ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n        var dept = 0;\n        var pointer = balancedColumnTree;\n        while (pointer && pointer[0] && pointer[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {\n            dept++;\n            pointer = pointer[0].getChildren();\n        }\n        return dept;\n    };\n    ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n        var result = [];\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (var i = 0; i < unbalancedTree.length; i++) {\n            var child = unbalancedTree[i];\n            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                var originalGroup = child;\n                var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            }\n            else {\n                // child is a column - so here we add in the padded column groups if needed\n                var firstPaddedGroup = void 0;\n                var currentPaddedGroup = void 0;\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (var j = columnDept - 1; j >= currentDept; j--) {\n                    var newColId = columnKeyCreator.getUniqueKey(null, null);\n                    var colGroupDefMerged = this.createMergedColGroupDef(null);\n                    var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.wireBean(paddedGroup);\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n                    currentPaddedGroup = paddedGroup;\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    var hasGroups = unbalancedTree.some(function (child) { return child instanceof originalColumnGroup_1.OriginalColumnGroup; });\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    }\n                    else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n                result.push(child);\n            }\n        }\n        return result;\n    };\n    ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n        var maxDeptThisLevel = dept;\n        for (var i = 0; i < treeChildren.length; i++) {\n            var abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {\n                var originalGroup = abstractColumn;\n                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n        return maxDeptThisLevel;\n    };\n    ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, parent) {\n        var _this = this;\n        var result = [];\n        if (!defs) {\n            return result;\n        }\n        defs.forEach(function (def) {\n            var newGroupOrColumn;\n            if (_this.isColumnGroup(def)) {\n                newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, parent);\n            }\n            else {\n                newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator, parent);\n            }\n            result.push(newGroupOrColumn);\n        });\n        return result;\n    };\n    ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, parent) {\n        var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n        var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n        this.context.wireBean(originalGroup);\n        var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n        originalGroup.setChildren(children);\n        return originalGroup;\n    };\n    ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n        var colGroupDefMerged = {};\n        utils_1._.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        utils_1._.assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n        return colGroupDefMerged;\n    };\n    ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator, parent) {\n        var colDefMerged = this.mergeColDefs(colDef);\n        this.checkForDeprecatedItems(colDefMerged);\n        // see if column already exists\n        var column = this.findExistingColumn(colDef, existingColsCopy);\n        if (!column) {\n            // no existing column, need to create one\n            var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new column_1.Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.wireBean(column);\n        }\n        else {\n            column.setColDef(colDefMerged, colDef);\n        }\n        return column;\n    };\n    ColumnFactory.prototype.findExistingColumn = function (colDef, existingColsCopy) {\n        var res = utils_1._.find(existingColsCopy, function (col) {\n            var oldColDef = col.getUserProvidedColDef();\n            if (!oldColDef) {\n                return false;\n            }\n            // first check object references\n            if (oldColDef === colDef) {\n                return true;\n            }\n            // second check id's\n            var oldColHadId = oldColDef.colId !== null && oldColDef.colId !== undefined;\n            if (oldColHadId) {\n                return oldColDef.colId === colDef.colId;\n            }\n            else {\n                return false;\n            }\n        });\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            utils_1._.removeFromArray(existingColsCopy, res);\n        }\n        return res;\n    };\n    ColumnFactory.prototype.mergeColDefs = function (colDef) {\n        // start with empty merged definition\n        var colDefMerged = {};\n        // merge properties from default column definitions\n        utils_1._.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef());\n        // merge properties from column type properties\n        if (colDef.type) {\n            this.assignColumnTypes(colDef, colDefMerged);\n        }\n        // merge properties from column definitions\n        utils_1._.assign(colDefMerged, colDef);\n        return colDefMerged;\n    };\n    ColumnFactory.prototype.assignColumnTypes = function (colDef, colDefMerged) {\n        var typeKeys;\n        if (colDef.type instanceof Array) {\n            var invalidArray = colDef.type.some(function (a) { return typeof a !== 'string'; });\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            }\n            else {\n                typeKeys = colDef.type;\n            }\n        }\n        else if (typeof colDef.type === 'string') {\n            typeKeys = colDef.type.split(',');\n        }\n        else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n        // merge user defined with default column types\n        var allColumnTypes = utils_1._.assign({}, this.gridOptionsWrapper.getColumnTypes(), defaultColumnTypes_1.DefaultColumnTypes);\n        typeKeys.forEach(function (t) {\n            var typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                utils_1._.assign(colDefMerged, typeColDef);\n            }\n            else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    };\n    ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n        if (colDef) {\n            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    };\n    // if object has children, we assume it's a group\n    ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n        return abstractColDef.children !== undefined;\n    };\n    __decorate([\n        context_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)\n    ], ColumnFactory.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        context_1.Autowired('columnUtils'),\n        __metadata(\"design:type\", columnUtils_1.ColumnUtils)\n    ], ColumnFactory.prototype, \"columnUtils\", void 0);\n    __decorate([\n        context_1.Autowired('context'),\n        __metadata(\"design:type\", context_1.Context)\n    ], ColumnFactory.prototype, \"context\", void 0);\n    __decorate([\n        __param(0, context_1.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], ColumnFactory.prototype, \"setBeans\", null);\n    ColumnFactory = __decorate([\n        context_1.Bean('columnFactory')\n    ], ColumnFactory);\n    return ColumnFactory;\n}());\nexports.ColumnFactory = ColumnFactory;\n"]},"metadata":{},"sourceType":"script"}