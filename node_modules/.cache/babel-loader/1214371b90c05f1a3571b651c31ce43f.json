{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/format/GML3\n */\n\n\nimport { extend } from '../array.js';\nimport { createOrUpdate } from '../extent.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport { readNonNegativeIntegerString, writeStringTextNode } from './xsd.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport { assign } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender, makeReplacer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, parseNode, pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI } from '../xml.js';\n/**\n * @const\n * @type {string}\n * @private\n */\n\nvar schemaLocation = GMLNS + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';\n/**\n * @const\n * @type {Object<string, string>}\n */\n\nvar MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\n\nvar GML3 =\n/** @class */\nfunction (_super) {\n  __extends(GML3, _super);\n  /**\n   * @param {import(\"./GMLBase.js\").Options=} opt_options Optional configuration object.\n   */\n\n\n  function GML3(opt_options) {\n    var _this = this;\n\n    var options =\n    /** @type {import(\"./GMLBase.js\").Options} */\n    opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.surface_ = options.surface !== undefined ? options.surface : false;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.curve_ = options.curve !== undefined ? options.curve : false;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;\n    /**\n     * @inheritDoc\n     */\n\n    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n    return _this;\n  }\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n\n\n  GML3.prototype.readMultiCurve_ = function (node, objectStack) {\n    /** @type {Array<LineString>} */\n    var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS_, node, objectStack, this);\n\n    if (lineStrings) {\n      var multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n\n\n  GML3.prototype.readMultiSurface_ = function (node, objectStack) {\n    /** @type {Array<Polygon>} */\n    var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS_, node, objectStack, this);\n\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GML3.prototype.curveMemberParser_ = function (node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GML3.prototype.surfaceMemberParser_ = function (node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n\n\n  GML3.prototype.readPatch_ = function (node, objectStack) {\n    return pushParseAndPop([null], this.PATCHES_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n\n\n  GML3.prototype.readSegment_ = function (node, objectStack) {\n    return pushParseAndPop([null], this.SEGMENTS_PARSERS_, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n\n\n  GML3.prototype.readPolygonPatch_ = function (node, objectStack) {\n    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n\n\n  GML3.prototype.readLineStringSegment_ = function (node, objectStack) {\n    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GML3.prototype.interiorParser_ = function (node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    var flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n\n    if (flatLinearRing) {\n      var flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n\n\n  GML3.prototype.exteriorParser_ = function (node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    var flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n\n    if (flatLinearRing) {\n      var flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Polygon|undefined} Polygon.\n   */\n\n\n  GML3.prototype.readSurface_ = function (node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS_, node, objectStack, this);\n\n    if (flatLinearRings && flatLinearRings[0]) {\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i = void 0,\n          ii = void 0;\n\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {LineString|undefined} LineString.\n   */\n\n\n  GML3.prototype.readCurve_ = function (node, objectStack) {\n    /** @type {Array<number>} */\n    var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS_, node, objectStack, this);\n\n    if (flatCoordinates) {\n      var lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n\n\n  GML3.prototype.readEnvelope_ = function (node, objectStack) {\n    /** @type {Array<number>} */\n    var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS_, node, objectStack, this);\n    return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n\n\n  GML3.prototype.readFlatPos_ = function (node, objectStack) {\n    var s = getAllTextContent(node, false);\n    var re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n\n    var flatCoordinates = [];\n    var m;\n\n    while (m = re.exec(s)) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n\n    if (s !== '') {\n      return undefined;\n    }\n\n    var context = objectStack[0];\n    var containerSrs = context['srsName'];\n    var axisOrientation = 'enu';\n\n    if (containerSrs) {\n      var proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n\n    if (axisOrientation === 'neu') {\n      var i = void 0,\n          ii = void 0;\n\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        var y = flatCoordinates[i];\n        var x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n\n    var len = flatCoordinates.length;\n\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n\n    if (len === 0) {\n      return undefined;\n    }\n\n    return flatCoordinates;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n\n\n  GML3.prototype.readFlatPosList_ = function (node, objectStack) {\n    var s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    var context = objectStack[0];\n    var containerSrs = context['srsName'];\n    var contextDimension = context['srsDimension'];\n    var axisOrientation = 'enu';\n\n    if (containerSrs) {\n      var proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n\n    var coords = s.split(/\\s+/); // The \"dimension\" attribute is from the GML 3.0.1 spec.\n\n    var dim = 2;\n\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n    /** @type {Element} */\n    node.parentNode.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(\n      /** @type {Element} */\n      node.parentNode.getAttribute('srsDimension'));\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n\n    var x, y, z;\n    var flatCoordinates = [];\n\n    for (var i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n\n    return flatCoordinates;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writePos_ = function (node, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    var srsName = context['srsName'];\n    var axisOrientation = 'enu';\n\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n\n    var point = value.getCoordinates();\n    var coords; // only 2d for simple features profile\n\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      var z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    writeStringTextNode(node, coords);\n  };\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n\n\n  GML3.prototype.getCoords_ = function (point, opt_srsName, opt_hasZ) {\n    var axisOrientation = 'enu';\n\n    if (opt_srsName) {\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n    }\n\n    var coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];\n\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      var z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writePosList_ = function (node, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    var srsName = context['srsName']; // only 2d for simple features profile\n\n    var points = value.getCoordinates();\n    var len = points.length;\n    var parts = new Array(len);\n    var point;\n\n    for (var i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n\n    writeStringTextNode(node, parts.join(' '));\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writePoint_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n\n\n  GML3.prototype.writeEnvelope = function (node, extent, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var keys = ['lowerCorner', 'upperCorner'];\n    var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    {\n      node: node\n    }, this.ENVELOPE_SERIALIZERS_, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeLinearRing_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  };\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n\n\n  GML3.prototype.RING_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var exteriorWritten = context['exteriorWritten'];\n\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n\n    return createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeSurfaceOrPolygon_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      var rings = geometry.getLinearRings();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName\n      }, this.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      var patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeCurveOrLineString_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {\n      var posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      var segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeMultiSurfaceOrPolygon_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var surface = context['surface'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var polygons = geometry.getPolygons();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      surface: surface\n    }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeMultiPoint_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context['srsName'];\n    var hasZ = context['hasZ'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var points = geometry.getPoints();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName\n    }, this.POINTMEMBER_SERIALIZERS_, makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeMultiCurveOrLineString_ = function (node, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context['hasZ'];\n    var srsName = context['srsName'];\n    var curve = context['curve'];\n\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n\n    var lines = geometry.getLineStrings();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      curve: curve\n    }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeRing_ = function (node, ring, objectStack) {\n    var linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing_(linearRing, ring, objectStack);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeSurfaceOrPolygonMember_ = function (node, polygon, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n    }\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writePointMember_ = function (node, point, objectStack) {\n    var child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint_(child, point, objectStack);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeLineStringOrCurveMember_ = function (node, line, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString_(child, line, objectStack);\n    }\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeSurfacePatches_ = function (node, polygon, objectStack) {\n    var child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeCurveSegments_ = function (node, line, objectStack) {\n    var child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n\n\n  GML3.prototype.writeGeometryElement = function (node, geometry, objectStack) {\n    var context =\n    /** @type {import(\"./Feature.js\").WriteOptions} */\n    objectStack[objectStack.length - 1];\n    var item = assign({}, context);\n    item['node'] = node;\n    var value;\n\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n      /** @type {import(\"../extent.js\").Extent} */\n      geometry, context);\n    } else {\n      value = transformGeometryWithOptions(\n      /** @type {import(\"../geom/Geometry.js\").default} */\n      geometry, true, context);\n    }\n\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, this.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);\n  };\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n\n\n  GML3.prototype.writeFeatureElement = function (node, feature, objectStack) {\n    var fid = feature.getId();\n\n    if (fid) {\n      node.setAttribute('fid',\n      /** @type {string} */\n      fid);\n    }\n\n    var context =\n    /** @type {Object} */\n    objectStack[objectStack.length - 1];\n    var featureNS = context['featureNS'];\n    var geometryName = feature.getGeometryName();\n\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n\n    var properties = feature.getProperties();\n    var keys = [];\n    var values = [];\n\n    for (var key in properties) {\n      var value = properties[key];\n\n      if (value !== null) {\n        keys.push(key);\n        values.push(value);\n\n        if (key == geometryName || typeof\n        /** @type {?} */\n        value.getSimplifiedGeometry === 'function') {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n          }\n        } else {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n          }\n        }\n      }\n    }\n\n    var item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, context.serializers, makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);\n  };\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n\n\n  GML3.prototype.writeFeatureMembers_ = function (node, features, objectStack) {\n    var context =\n    /** @type {Object} */\n    objectStack[objectStack.length - 1];\n    var featureType = context['featureType'];\n    var featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n\n    var serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);\n    var item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);\n  };\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n\n\n  GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  };\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n\n\n  GML3.prototype.GEOMETRY_NODE_FACTORY_ = function (value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var multiSurface = context['multiSurface'];\n    var surface = context['surface'];\n    var curve = context['curve'];\n    var multiCurve = context['multiCurve'];\n    var nodeName;\n\n    if (!Array.isArray(value)) {\n      nodeName =\n      /** @type {import(\"../geom/Geometry.js\").default} */\n      value.getType();\n\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n\n    return createElementNS(this.namespace, nodeName);\n  };\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n\n\n  GML3.prototype.writeGeometryNode = function (geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var geom = createElementNS(this.namespace, 'geom');\n    var context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_\n    };\n\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  };\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Element} Node.\n   * @override\n   * @api\n   */\n\n\n  GML3.prototype.writeFeaturesNode = function (features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n    var context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  };\n\n  return GML3;\n}(GMLBase);\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\n\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos_),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser_,\n    'exterior': GML3.prototype.exteriorParser_\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\n\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface_),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface_),\n    'Curve': makeReplacer(GML3.prototype.readCurve_),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve_),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.MULTICURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser_),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.MULTISURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser_),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.CURVEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.SURFACEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.SURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.CURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.ENVELOPE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList_),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.PATCHES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch_)\n  }\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\n\nGML3.prototype.SEGMENTS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeReplacer(GML3.prototype.readLineStringSegment_)\n  }\n};\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n * @return {string} Result.\n * @api\n */\n\nGML3.prototype.writeFeatures;\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.RING_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing_),\n    'interior': makeChildAppender(GML3.prototype.writeRing_)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.ENVELOPE_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember_),\n    'polygonMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember_)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.POINTMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember_)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember_),\n    'curveMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember_)\n  }\n};\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\n\nGML3.prototype.GEOMETRY_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString_),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString_),\n    'Point': makeChildAppender(GML3.prototype.writePoint_),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint_),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString_),\n    'MultiLineString': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString_),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing_),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiPolygon': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiSurface': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope)\n  }\n};\nexport default GML3;","map":null,"metadata":{},"sourceType":"module"}