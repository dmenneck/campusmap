{"ast":null,"code":"/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport { asString } from '../../color.js';\nimport { snap } from '../../geom/flat/simplify.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport CanvasInstruction, { fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction } from './Instruction.js';\nimport CanvasReplay from './Replay.js';\n\nvar CanvasPolygonReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if (CanvasReplay) CanvasPolygonReplay.__proto__ = CanvasReplay;\n  CanvasPolygonReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n\n    this.endGeometry(circleGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, asString(defaultFillStyle)]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.finish = function finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    var tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n\n\n  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_(geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonReplay;\n}(CanvasReplay);\n\nexport default CanvasPolygonReplay;","map":{"version":3,"sources":["../../../../src/ol/render/canvas/PolygonReplay.js"],"names":["super","const","let"],"mappings":"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","sourcesContent":["/**\n * @module ol/render/canvas/PolygonReplay\n */\nimport {asString} from '../../color.js';\nimport {snap} from '../../geom/flat/simplify.js';\nimport {defaultFillStyle} from '../canvas.js';\nimport CanvasInstruction, {\n  fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction\n} from './Instruction.js';\nimport CanvasReplay from './Replay.js';\n\n\nclass CanvasPolygonReplay extends CanvasReplay {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    super(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle != undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawCircle(circleGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(\n      flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(fillInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(circleGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawPolygon(polygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        asString(defaultFillStyle)\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n        state.miterLimit, state.lineDash, state.lineDashOffset\n      ]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(multiPolygonGeometry, feature);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n  setFillStrokeStyles_(geometry) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\n\n\nexport default CanvasPolygonReplay;\n"]},"metadata":{},"sourceType":"module"}